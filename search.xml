<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>webpack HMR（热模块替换）</title>
    <url>/2020/07/05/webpack%20HMR%EF%BC%88%E7%83%AD%E6%A8%A1%E5%9D%97%E6%9B%BF%E6%8D%A2%EF%BC%89/</url>
    <content><![CDATA[<p>之前入门时，也是学习过 <code>glup</code>、<code>grunt</code> 和 <code>webpack</code>，但由于平时一般都是在脚手架环境下进行开发，记的越来越模糊了。打算再次系统的学习一次 <code>webpack</code>。至于另外二者，那就需要时再说。</p>
<p><strong><code>HMR</code></strong> 是 <code>hot module replacement</code> 的缩写，也就是<strong>热模块替换</strong>，或者叫模块热替换。</p>
<a id="more"></a>

<p>它的作用就是：<strong>当项目中的一个模块发生改变时，只会重新打包这一个模块</strong>。</p>
<p>这样，当项目中拥有很多模块时，如果修改了一个模块，<code>webpack</code> 只会重新打包这一个模块，而不是将全部模块重新打包。这样可以很大提升项目开发时的构建速度。</p>
<p>开启方式很简单，由于<code>devServer</code> 内部支持 <code>HMR</code> 功能，所以只需要在 <code>webpack</code> 的 <code>devServer</code> 配置中新增 <code>hot: true</code> 选项即可，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	...</span><br><span class="line">	devServer: &#123;</span><br><span class="line">		contentBase: <span class="string">'build'</span>,</span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 开启HMR</span></span><br><span class="line">    hot: <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步完成，就可以实现样式文件的热模块替换了（因为 <code>style-loader</code> 已经内部实现了 <code>HMR</code>）</p>
<p>那 <code>html</code> 文件和 <code>js</code> 文件该如何实现呢？</p>
<p>答案是：</p>
<p><code>html</code> 文件不需要实现热模块替换，因为 <code>html</code> 文件只有一个，当发生改变时一定会重新打包，因此无需处理，也没有办法处理；</p>
<p>而且，当开启了 <code>HMR</code> 时，还会有一个问题：修改了 <code>html</code>，<code>webpack</code> 不会重新打包。只需要将 <code>entry</code> 入口改为一个数组，同时将 <code>html</code> 的相对路径添加到数组中。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  entry: [<span class="string">'./src/js/index.js'</span>, <span class="string">'./src/index.html'</span>]</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有 <code>js</code> 文件，假设有一个 <code>print.js</code> 模块，向外暴露函数对象 <code>print</code>。</p>
<p>若需要为其实现热模块替换，则需在入口文件中新增如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 判断HMR是否开启</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="comment">// 监听print.js文件的变化，一旦其发生变化，不会重新打包，而是执行后续的回调函数</span></span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">'./print.js'</span>, () =&gt; &#123;</span><br><span class="line">    print()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>HMR</code> 对 <code>js</code> 文件的处理，只能处理非入口文件的 <code>js</code> 文件，因为一旦入口文件发生变化，各模块就会重新引入处理打包，这也是合情合理的。</p>
<hr>
<p>一些原因，很久没有写博客了，以后一定抽时间多进行输出！</p>
]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>对JavaScript再次审视的总结</title>
    <url>/2020/05/21/%E5%AF%B9JavaScript%E5%86%8D%E6%AC%A1%E5%AE%A1%E8%A7%86%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>此文没有什么长篇大论，仅仅是个人再次深入学习 <code>JavaScript</code> 的记录，以及遗忘知识点的回顾。</p>
<a id="more"></a>



<hr>
<ul>
<li><p>翻阅 <code>ECMAScript Specification</code>，解决了我很长时间的一个疑惑。<strong><code>Object.prototype</code> 是浏览器基于 spec 而创建的一个 <code>built-in</code> 的对象</strong>。</p>
<p>对此，很多人说的 “<code>JavaScript</code> 中所有函数的 <code>prototype</code> 属性值都是 <code>Object</code> 构造函数的实例对象” 这句话，是不完全正确的。</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong><code>instanceof</code></strong> <strong>运算符</strong>仅仅用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p>
<p><code>Object instanceof Function</code> 为 <code>true</code> 是由于 <code>Object.__proto__ === Function.prototype</code>。而 <code>Function instanceof Object</code> 、<code>Function instanceof Function</code>、<code>Object instanceof Object</code> 也都可以用原型链证实。</p>
</li>
</ul>
<p>因此 <code>instanceof</code> 无法判断 <code>Function</code> 和 <code>Object</code> 哪个是鸡哪个是蛋。</p>
<hr>
<ul>
<li><code>JavaScript</code> 的作用域为<strong>词法作用域</strong>（即静态作用域）。<strong>函数的作用域在函数定义的时候就决定了</strong>。</li>
</ul>
<hr>
<ul>
<li><p><code>JS</code> 引擎在<strong>代码执行之前</strong>，会创建执行上下文环境，做出以下操作：</p>
<ul>
<li>收集变量、函数以及函数的参数 <code>arguments</code> （如果是函数执行上下文的话）作为<strong>变量对象</strong>（Variable Object，VO）（在进入执行上下文阶段为 VO，在执行代码阶段变为AO。AO即 Activation Object）。</li>
<li>确认 <code>this</code> 的指向</li>
<li>创建作用域链</li>
</ul>
<p>“收集变量、函数” 就是 <strong>“使用 <code>var</code> 声明的变量存在提升，即函数声明提升”</strong>的原因（切记是声明提升，就是只声明，并不赋值）。</p>
<p><strong>函数声明提升的优先级高于变量声明提升的优先级</strong>，就像下方代码这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>最后会输出<code>foo</code> 函数体。是因为<strong>在进入执行上下文时，首先会处理函数声明，其次会处理变量声明。如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</strong>。（这句话，如果用下方模拟的这个例子来解释的话，就是：在进入全局执行上下文阶段，由于函数声明提升的优先级比变量声明提升的优先级高，所以 <code>foo</code> 函数先声明，再 <code>var foo</code> 声明，没有任何卵用！） </p>
<p>如果模拟一下 <code>JS</code> 引擎实际的执行流程，那就是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo</span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line">foo = <span class="number">1</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<hr>
<ul>
<li><p>关于闭包</p>
<ul>
<li>从理论角度来说，<code>JavaScript</code> 中所有的函数都会产生闭包，这是因为：函数在创建的时候，就会将外层执行上下文中的作用域链保存当前执行上下文的作用域 <code>[[Scopes]]</code> 中。</li>
<li>从实践角度来说，<strong>闭包</strong>的产生实际就是：<strong>即使执行上下文中的变量对象已经销毁了，而变量仍可以使用</strong>。实际开发时有两种情况：①函数中引用了外部的变量；②外层函数将内层函数 <code>return</code> （实际开发意义很大）</li>
</ul>
<p>理论角度的闭包就是理论而已，确实时这个理，实际开发中没啥卵用。</p>
<p>闭包就是为了延长变量对象的生命周期而已，并无其他深奥之处。</p>
</li>
</ul>
<hr>
<ul>
<li><code>let</code> 与 <code>const</code> 没有提升的原因是：使用 <code>let</code> 和 <code>const</code> 声明的变量， <code>JavaScript</code> 引擎在扫描代码发现变量声明时（也就是进入执行上下文时），将二者声明的变量放入临时性死区（ Temporal Dead Zone，TDZ ）。访问 <code>TDZ</code> 内的变量会报错。在执行代码时，将变量从 <code>TDZ</code> 内取出，这事方可访问。</li>
</ul>
<hr>
<ul>
<li><p><code>Symbol</code> 作为属性名时，该属性不会出现在  <code>for...in</code>、<code>for...of</code> 循环中，也不会被 <code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code> 返回。<strong>可以使用<code>Object.getOwnPropertySymbols</code> 方法，获取指定对象的所有 <code>Symbol</code> 属性名。</strong></p>
<p>如果希望使用同一个 <code>Symbol</code> 值，可以使用 <code>Symbol.for</code>。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 <code>Symbol</code> 值。如果有，就返回这个 <code>Symbol</code> 值，否则就新建并返回一个以该字符串为名称的 <code>Symbol</code> 值。就像下方这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>以前一直搞不懂 <code>Symbol</code> 在实际开发中的用途，在 issue 中发现了解答，用途如下：</p>
<ul>
<li>定义类的私有变量/方法</li>
<li>运用在单例模式中   </li>
</ul>
</li>
</ul>
<p>以上，大部分取经自 <a href="[https://github.com/mqyqingfeng/Blog#%E5%86%B4%E7%BE%BD%E7%9A%84%E5%8D%9A%E5%AE%A2](https://github.com/mqyqingfeng/Blog#冴羽的博客)">冴羽的博客</a>。</p>
<hr>
<ul>
<li><strong>继承</strong><ul>
<li><strong>原型链继承</strong>。即将子类的原型指向父类的实例，并校正子类原型的 <code>constructor</code> 属性。</li>
<li>借用构造函数继承（伪继承）。使用 <code>call</code> 或 <code>apply</code> 在子类中调用父类，将父类的 <code>this</code> 指向子类的 <code>this</code>。</li>
<li>组合继承。实际上就是 原型链继承 + 借用构造函数继承。<ul>
<li>原型链继承的作用：实现真正的继承</li>
<li>借用构造函数继承的作用：当子类中有与父类相同的属性时，节省代码量</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>mint-ui按需引入的问题</title>
    <url>/2020/05/07/mint-ui%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>按 <strong>Mint UI</strong> 官网中描述，实现<strong>按需打包</strong>的步骤如下：</p>
<ol>
<li>安装开发依赖 <code>babel-plugin-component</code></li>
<li>配置：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    [<span class="string">"es2015"</span>, &#123; <span class="string">"modules"</span>: <span class="literal">false</span> &#125;]</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"plugins"</span>: [[<span class="string">"component"</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"libraryName"</span>: <span class="string">"mint-ui"</span>,</span><br><span class="line">      <span class="string">"style"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>在项目中配置后，<code>npm run serve</code> 重新运行报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR  Error: .plugins[0][1] must be an object, false, or undefined</span><br></pre></td></tr></table></figure>

<p>就是说 <strong><code>plugins</code> 索引为0的第一个元素 的 索引为1的第二个元素必须是个 <code>object</code> 或 <code>false</code> 或 <code>undefined</code>。</strong></p>
<p>又回去官网瞅了瞅，发现官网说的是在 <code>.babelrc</code> 中配置。</p>
<p>所以官网应该是没有更新，说的还是二版本脚手架 <code>vue-cli2</code> 中的按需引入配置。</p>
<p><strong>按照错误提示</strong>，将项目根路径下 <code>babel.config.js</code> （三版本脚手架 <code>@vue/cli</code> 的 <code>babel</code> 配置文件）中内容修改如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    <span class="string">'@vue/cli-plugin-babel/preset'</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'component'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"libraryName"</span>: <span class="string">"mint-ui"</span>,</span><br><span class="line">        <span class="string">"style"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置后重新运行即可。  </p>
<p>完！</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>bug</tag>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title>git clone后本地只有master分支的问题</title>
    <url>/2020/05/07/gitclone%E5%90%8E%E6%9C%AC%E5%9C%B0%E5%8F%AA%E6%9C%89master%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<p><strong>举个例子：</strong></p>
<p>在公司上班时是在 <em>dev</em> 分支进行开发并提交到 <em>dev</em> 分支，回家后想要接着进行开发。</p>
<p> <code>git clone</code> 后进行 <code>git branch</code> 查看本地分支，只有 <em>master</em> 分支；而 <code>git branch -a</code> 查看远程分支，所有分支都在。如下：</p>
<a id="more"></a>

<p><a href="https://i.loli.net/2020/05/07/JQb4LKsCPVUkIHx.png" target="_blank"><img src="https://i.loli.net/2020/05/07/JQb4LKsCPVUkIHx.png" ></a></p>
<p><strong>两个命令，都可以追溯远程分支：</strong></p>
<ul>
<li>命令一：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b mybranch origin&#x2F;abranch</span><br></pre></td></tr></table></figure>

<p>此命令可以追溯远程分支的同时自定义本地分支名称，其余与下方命令无区别</p>
<ul>
<li>命令二：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout --track origin&#x2F;branch</span><br></pre></td></tr></table></figure>



<p>完！</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>vee-validate3.3.0的使用</title>
    <url>/2020/05/06/vee-validate%203.3.0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在 <em>vue</em> 项目中用到 <em>vee-validate</em> 进行表单验证时，用之前版本的语法一直报错，发现 <em>vee-validate</em> 已经升级到 3.3.0 版本。只有英文文档，而且个人感觉写的也不是很好。总结一下，以免再次踩坑。</p>
<p>新版本本人也是边学边用，如有纰漏，欢迎指正。</p>
<a id="more"></a>

<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>安装</li>
<li>编写 <em>validate.js</em> 并引入</li>
<li>在模板中使用验证规则</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用 <code>npm</code> 或者 <code>yarn</code> 安装（包名 <em>vee-validate</em>），也可 <code>CDN</code> 引入，不再赘述，详见官网 <a href="https://logaretm.github.io/vee-validate/overview.html#installation" target="_blank" rel="noopener">Installation</a>。</p>
<h2 id="validate-js"><a href="#validate-js" class="headerlink" title="validate.js"></a><em>validate.js</em></h2><p>在项目中创建 <em>validate.js</em> 文件。内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123;extend, ValidationProvider, ValidationObserver, localize&#125; <span class="keyword">from</span> <span class="string">'vee-validate'</span></span><br><span class="line"><span class="keyword">import</span> zh_CN <span class="keyword">from</span> <span class="string">'vee-validate/dist/locale/zh_CN.json'</span></span><br><span class="line"><span class="keyword">import</span> &#123;required&#125; <span class="keyword">from</span> <span class="string">'vee-validate/dist/rules'</span></span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'ValidationProvider'</span>, ValidationProvider)</span><br><span class="line">Vue.component(<span class="string">'ValidationObserver'</span>, ValidationObserver)</span><br><span class="line"></span><br><span class="line">localize(<span class="string">'zh_CN'</span>, zh_CN)</span><br><span class="line"></span><br><span class="line">extend(<span class="string">'required'</span>, &#123;</span><br><span class="line">  ...required</span><br><span class="line">&#125;)</span><br><span class="line">extend(<span class="string">'phoneNumber'</span>, &#123;</span><br><span class="line">  validate: <span class="function"><span class="params">value</span> =&gt;</span> <span class="regexp">/^(0|86|17951)?(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]&#123;8&#125;$/</span>.test(value),</span><br><span class="line">  message: <span class="function"><span class="params">filed</span> =&gt;</span> <span class="string">'请输入正确的'</span> + filed</span><br><span class="line">&#125;)</span><br><span class="line">extend(<span class="string">'SMSVerficationCode'</span>, &#123;</span><br><span class="line">  validate: <span class="function"><span class="params">value</span> =&gt;</span> <span class="regexp">/^\d&#123;6&#125;$/</span>.test(value),</span><br><span class="line">  message: <span class="function"><span class="params">filed</span> =&gt;</span> <span class="string">'请输入正确的'</span> + filed</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>需在入口文件 <em>main.js</em> 中引入。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./common/utils/validator'</span></span><br></pre></td></tr></table></figure>

<h3 id="拆解"><a href="#拆解" class="headerlink" title="拆解"></a>拆解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;extend, ValidationProvider, ValidationObserver, localize&#125; <span class="keyword">from</span> <span class="string">'vee-validate'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>extend</code> ：扩展验证规则的函数。</li>
<li><code>ValidationProvider</code> ：<em>vee-validate</em> 最核心组件对象，用来包裹需要规则验证的 <code>input</code> 进行实时验证。 </li>
<li><code>ValidationObserver</code> ：使用它可以在提交时进行表单的统一验证。</li>
<li><code>localize</code> ：进行错误提示本地化的函数。</li>
</ul>
<p><em>vee-validate</em> 向外暴露的不止这四个对象，还有 <code>normalizeRules</code>、<code>configure</code> 等，我这里没有用到，暂不讨论。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zh_CN <span class="keyword">from</span> <span class="string">'vee-validate/dist/locale/zh_CN.json'</span></span><br></pre></td></tr></table></figure>

<p>引入中文语言包。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;required&#125; <span class="keyword">from</span> <span class="string">'vee-validate/dist/rules'</span></span><br></pre></td></tr></table></figure>

<p> 引入内置验证规则 <code>required</code>。</p>
<p><em>vee-validate</em> 提供了一些通用的验证规则供使用，详见<a href="https://logaretm.github.io/vee-validate/guide/rules.html#rules" target="_blank" rel="noopener">Rules</a>。可以引入你所需要的，也可以全部引入，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> rules <span class="keyword">from</span> <span class="string">'vee-validate/dist/rules'</span></span><br></pre></td></tr></table></figure>

<p>声明使用内置的验证规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(rules).forEach(<span class="function"><span class="params">rule</span> =&gt;</span> &#123;</span><br><span class="line">	extend(rule, rules[rule])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'ValidationProvider'</span>, ValidationProvider)</span><br><span class="line">Vue.component(<span class="string">'ValidationObserver'</span>, ValidationObserver)</span><br></pre></td></tr></table></figure>

<p>全局注册 <code>ValidationProvider</code> 组件与 <code>ValidationObserver</code> 组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">localize(<span class="string">'zh_CN'</span>, zh_CN)</span><br></pre></td></tr></table></figure>

<p>使用中文提示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">extend(<span class="string">'ruleName'</span>, &#123;</span><br><span class="line">	<span class="comment">// options</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>为了保持包的小巧，<em>vee-validate</em> 默认没有安装任何验证规则。可以使用 <code>extend</code> 函数来自定义验证规则。</p>
<p>函数的第一个参数为验证规则名，第二个参数为验证规则的配置。这里只是 <code>extend</code> 函数的语法之一，其他语法请见<a href="https://logaretm.github.io/vee-validate/guide/basics.html#adding-rules" target="_blank" rel="noopener">Adding Rules</a>。</p>
<h2 id="在模板中使用验证规则"><a href="#在模板中使用验证规则" class="headerlink" title="在模板中使用验证规则"></a>在模板中使用验证规则</h2><h3 id="实时验证（单独验证）"><a href="#实时验证（单独验证）" class="headerlink" title="实时验证（单独验证）"></a>实时验证（单独验证）</h3><p>相较于 2.x 版本的 <em>vee-validate</em>，3.x 版本的最大变动就是通过使用 <code>ValidationProvider</code> 组件包裹 input，替代直接添加在 input 上的 <code>v-validate</code> 指令。</p>
<p> <code>ValidationProvider</code> 利用 <code>v-slot</code> （插槽）为模板提供错误信息。</p>
<p>2.x版本语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"myemail"</span> <span class="attr">v-validate</span>=<span class="string">"'required|email'"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">calss</span>=<span class="string">"error"</span> <span class="attr">v-show</span>=<span class="string">"errors.has('myemail')"</span>&gt;</span>&#123;&#123;errors.first('myemail')&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>3.x版本语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ValidationProvider</span> <span class="attr">name</span>=<span class="string">"手机号码"</span> <span class="attr">rules</span>=<span class="string">"required|phoneNumber"</span> <span class="attr">v-slot</span>=<span class="string">"&#123;errors&#125;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span> <span class="attr">maxlength</span>=<span class="string">"11"</span> <span class="attr">placeholder</span>=<span class="string">"手机号"</span> <span class="attr">v-model</span>=<span class="string">"phoneNumber"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span>&#123;&#123;errors[0]&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ValidationProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>参数 <code>rules</code> 的值为 <em>validate.js</em> 中定义的验证规则名的字符串。</p>
<p>如有多个验证规则，用 <code>|</code> 隔开。或者可以采用 规则的对象语法（<a href="https://logaretm.github.io/vee-validate/advanced/rules-object-expression.html#rules-object-expression" target="_blank" rel="noopener">Rules Object Expression</a>），就像这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ValidationProvider</span> <span class="attr">name</span>=<span class="string">"手机号码"</span> <span class="attr">:rules</span>=<span class="string">"&#123;required: true, phoneNumber: true&#125;"</span> <span class="attr">v-slot</span>=<span class="string">"&#123;errors&#125;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span> <span class="attr">maxlength</span>=<span class="string">"11"</span> <span class="attr">placeholder</span>=<span class="string">"手机号"</span> <span class="attr">v-model</span>=<span class="string">"phoneNumber"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span>&#123;&#123;errors[0]&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ValidationProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="统一验证"><a href="#统一验证" class="headerlink" title="统一验证"></a>统一验证</h3><p>3.x 版本提交表单时的<strong>统一验证</strong>证相比之前也有了很大的变动。</p>
<p>举个例子。</p>
<p>这是 2.x 版本的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">v-validate</span>=<span class="string">"'required|username'"</span> <span class="attr">placeholder</span>=<span class="string">"用户名"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">calss</span>=<span class="string">"error"</span> <span class="attr">v-show</span>=<span class="string">"errors.has('username')"</span>&gt;</span>&#123;&#123;errors.first('username')&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">v-validate</span>=<span class="string">"'required|password'"</span> <span class="attr">placeholder</span>=<span class="string">"密码"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">calss</span>=<span class="string">"error"</span> <span class="attr">v-show</span>=<span class="string">"errors.has('password')"</span>&gt;</span>&#123;&#123;errors.first('password')&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.prevent</span>=<span class="string">"validateBeforeSubmit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    validateBeforeSubmit() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$validator.validate().then(<span class="function"><span class="params">success</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// Do something!</span></span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.x 版本需要这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ValidationObserver</span> <span class="attr">v-slot</span>=<span class="string">"&#123; handleSubmit &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ValidationProvider</span> <span class="attr">v-slot</span>=<span class="string">"&#123;errors&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">rules</span>=<span class="string">"required|username"</span> <span class="attr">placeholder</span>=<span class="string">"用户名"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">calss</span>=<span class="string">"error"</span>&gt;</span>&#123;&#123;errors[0]&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ValidationProvider</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">ValidationProvider</span> <span class="attr">v-slot</span>=<span class="string">"&#123;errors&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">rules</span>=<span class="string">"required|password"</span> <span class="attr">placeholder</span>=<span class="string">"密码"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">calss</span>=<span class="string">"error"</span>&gt;</span>&#123;&#123;errors[0]&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ValidationProvider</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.prevent</span>=<span class="string">"handleSubmit(submit)"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ValidationObserver</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    submit() &#123;</span><br><span class="line"><span class="actionscript">      <span class="comment">// Only executes when validation passes!</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>ValidationObserver</code> 通过 <code>v-slot</code> 提供了一个函数 <code>handleSubmit</code> 用来进行表单的统一验证，<code>handleSubmit</code>接收一个函数参数，这个函数只有当提交的表单合法时，才会调用。</p>
<p>上方代码中，当点击 <kbd>Submit</kbd>进行表单提交时，只有当输入的 <em>username</em> 与 <em>password</em> 都符合验证规则时，才会执行函数 <code>submit</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://logaretm.github.io/vee-validate/" target="_blank" rel="noopener">VeeValidate</a> </li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>函数声明与函数表达式</title>
    <url>/2020/05/02/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>函数声明与函数表达式是 <code>JavaScript</code> 中创建函数最常见的两种方式。此文记录本人对其二者的理解。</p>
<a id="more"></a>

<hr>
<h2 id="函数声明（Function-Declaration）"><a href="#函数声明（Function-Declaration）" class="headerlink" title="函数声明（Function Declaration）"></a>函数声明（Function Declaration）</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">[param,[, param,[..., param]]]</span>) </span>&#123;</span><br><span class="line">   [statements]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用函数声明的函数定义为一条完整的语句。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>有提升，可以在函数声明之前被调用（原因：<code>js</code> 引擎会在代码执行之前创建执行上下文环境，将函数声明保存到执行上下文对象中）。</li>
</ul>
<p>就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn1(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>开发中应尽量避免使用函数提升。</strong></p>
<hr>
<h2 id="函数表达式（Function-Expression）"><a href="#函数表达式（Function-Expression）" class="headerlink" title="函数表达式（Function Expression）"></a>函数表达式（Function Expression）</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">let function_expression = function [name]([param1[, param2[, ..., paramN]]]) &#123;</span><br><span class="line">   [statements]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数表达式其与函数声明十分相似，二者最主要区别是函数名称。函数表达式中的函数名称可以省略，从而创建匿名函数。</p>
<p>使用没有函数名函数表达式的函数定义，本身不是一个完整的语句，不能单独存在，只能与其他语句配合成为一条完整的语句。</p>
<h3 id="匿名函数表达式使用的多种方式"><a href="#匿名函数表达式使用的多种方式" class="headerlink" title="匿名函数表达式使用的多种方式"></a>匿名函数表达式使用的多种方式</h3><h4 id="赋值-保存给一个变量"><a href="#赋值-保存给一个变量" class="headerlink" title="赋值/保存给一个变量"></a>赋值/保存给一个变量</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a * b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn2(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="作为另一个函数的实参（配合高阶函数）"><a href="#作为另一个函数的实参（配合高阶函数）" class="headerlink" title="作为另一个函数的实参（配合高阶函数）"></a>作为另一个函数的实参（配合高阶函数）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'延迟执行的函数表达式'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>该方式本质上也是将函数表达式保存为一个变量，内部会将定义的匿名函数赋值给内部定义的实参。</p>
<h4 id="作为另一个函数的返回值（配合高阶函数）"><a href="#作为另一个函数的返回值（配合高阶函数）" class="headerlink" title="作为另一个函数的返回值（配合高阶函数）"></a>作为另一个函数的返回值（配合高阶函数）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn3(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>同样，该方式本质上也是将函数表达式保存为一个变量。</p>
<h4 id="立即执行（IIFE实现模块化）"><a href="#立即执行（IIFE实现模块化）" class="headerlink" title="立即执行（IIFE实现模块化）"></a>立即执行（IIFE实现模块化）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="命名函数表达式"><a href="#命名函数表达式" class="headerlink" title="命名函数表达式"></a>命名函数表达式</h3><p><strong>当函数表达式不省略函数名时，可以在该函数内部（并且只能在该函数内部）使用该函数名访问该函数，该函数名作为的变量保存的值只读不可修改。</strong></p>
<p>可以借助<strong>命名函数表达式</strong>代替 <code>ECMAScript</code> 不推荐使用的 <code>arguments.callee</code>，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn4 = <span class="function"><span class="keyword">function</span> <span class="title">fn5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fn5)</span><br><span class="line">  <span class="built_in">console</span>.log(fn5 === fn4)</span><br><span class="line">  fn5 = <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(fn5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn4()</span><br></pre></td></tr></table></figure>

<p>执行输出如下：</p>
<p><a href="https://i.loli.net/2020/05/02/ToVPEl1ZYM5xgdF.png" target="_blank"><img src="https://i.loli.net/2020/05/02/ToVPEl1ZYM5xgdF.png"  style="zoom: 60%;" /></a></p>
<center>图：命名函数表达式执行</center>  
### 命名函数表达式的应用

<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>需求：<strong>使用演示定时器模拟实现循环定时器</strong>。</p>
<p>实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'action'</span>)</span><br><span class="line">  setTimeout(callback, <span class="number">1000</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>此时，可以实现控制台中每隔一秒输出一次 <code>action</code>。</p>
<p>这里只是举个例子，不推荐实际开发中这样使用，毕竟浏览器栈空间有限，这样很可能会造成栈溢出报错。</p>
<h3 id="函数表达式的提升"><a href="#函数表达式的提升" class="headerlink" title="函数表达式的提升"></a>函数表达式的提升</h3><p>不同于函数声明语句，函数表达式没有提升，无法在使用函数表达式的函数定义之前调用，如果调用会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn6(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Uncaught ReferenceError: fn6 is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn6 = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a - b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数声明与函数表达式其实都没什么难点，只是要注意匿名函数表达式的延申。</p>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function" target="_blank" rel="noopener">MDN - 函数声明</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function" target="_blank" rel="noopener">MDN - 函数表达式</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Function</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo报错TypeError [ERR_INVALID_URL]&quot;:&quot; Invalid URL&quot;:&quot;</title>
    <url>/2020/04/25/hexo%E6%8A%A5%E9%94%99TypeError%20%5BERR_INVALID_URL%5D%20Invalid%20URL/</url>
    <content><![CDATA[<p>在写完上一篇，进行 <code>hexo g</code> 时报错：</p>
<p><code>TypeError [ERR_INVALID_URL]: Invalid URL: http://localhost:8080&amp;#39;</code></p>
<p>具体如下图：</p>
<a id="more"></a>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a href="https://i.loli.net/2020/04/25/DEaKcokQ5wJAHs1.png" target="_blank"><img src="https://i.loli.net/2020/04/25/DEaKcokQ5wJAHs1.png" style="zoom: 80%;"></a></p>
<center>图：hexo报错TypeError [ERR_INVALID_URL]: Invalid URL:</center>  



<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>更改文章中此格式的链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;http:&#x2F;&#x2F;localhost:8080&#39;</span><br></pre></td></tr></table></figure>

<p>更改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\&#39;&lt;http:&#x2F;&#x2F;localhost:8080&gt;\&#39;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用反斜杠对单引号进行转义。</li>
<li>使用尖括号包裹链接（markdown 语法）。  </li>
</ol>
<p>个人猜测应该是 hexo 某插件对文章内链接的解析存在问题，这里就不深究！</p>
<p><strong>完！</strong></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>vue脚手架中使用开发环境代理</title>
    <url>/2020/04/25/vue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>在 <code>vue-cli</code> 和 <code>@vue/cli</code> 中使用开发环境代理解决跨域（ cross-origin ）问题。</p>
<p>Access to XMLHttpRequest at &#39;<a href="http://localhost:2000/index_category" target="_blank" rel="noopener">http://localhost:2000/index_category</a>&#39; from origin &#39;<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>&#39; has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</p>
<a id="more"></a>

<h2 id="vue-cli-中（二版本脚手架）"><a href="#vue-cli-中（二版本脚手架）" class="headerlink" title="vue-cli 中（二版本脚手架）"></a>vue-cli 中（二版本脚手架）</h2><p>配置项目根目录下 <code>config</code> 文件夹中文件 <code>index.js</code> 的 <code>dev.proxyTable</code> 选项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  dev: &#123;</span><br><span class="line">    ...</span><br><span class="line">    proxyTable: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http://www.example.org'</span>, <span class="comment">// target host</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>, <span class="comment">// needed for virtual hosted sites</span></span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api/old-path'</span>: <span class="string">'/api/new-path'</span>, <span class="comment">// rewrite path</span></span><br><span class="line">          <span class="string">'^/api/remove/path'</span>: <span class="string">'/path'</span>, <span class="comment">// remove base path</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 其他代理路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在需要使用代理转发的接口请求函数中将指定的名称（上方示例中是 <code>&#39;/api&#39;</code>）拼串到对应的 URL 前，重启项目即可。</p>
<h2 id="vue-cli-中（三版本脚手架）"><a href="#vue-cli-中（三版本脚手架）" class="headerlink" title="@vue-cli 中（三版本脚手架）"></a>@vue-cli 中（三版本脚手架）</h2><p>配置项目根目录下  <code>vue.config.js</code> 中的 <code>devServer.proxy</code> 选项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 配置开发代理服务器</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: <span class="string">'http://www.example.org'</span>, <span class="comment">// target host</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种对策适用于只有一个后台时，当不同请求需要通过代理转发到不同的服务器时，可以采用下方的配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 配置开发代理服务器</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http://www.example.org'</span>, <span class="comment">// target host</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>, <span class="comment">// needed for virtual hosted sites</span></span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api/old-path'</span>: <span class="string">'/api/new-path'</span>, <span class="comment">// rewrite path</span></span><br><span class="line">          <span class="string">'^/api/remove/path'</span>: <span class="string">'/path'</span>, <span class="comment">// remove base path</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'/foo'</span>: &#123;</span><br><span class="line">        target: <span class="string">'&lt;other_url&gt;'</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api/old-path'</span>: <span class="string">'/api/new-path'</span>, <span class="comment">// rewrite path</span></span><br><span class="line">          <span class="string">'^/api/remove/path'</span>: <span class="string">'/path'</span>, <span class="comment">// remove base path</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>vue-cli</code> 中的用法大同小异。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://cli.vuejs.org/zh/config/#devserver-proxy" target="_blank" rel="noopener">devServer.proxy</a></li>
<li><a href="https://github.com/chimurai/http-proxy-middleware#proxycontext-config" target="_blank" rel="noopener">http-proxy-middleware</a></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟JS中的new运算符</title>
    <url>/2020/04/11/%E6%A8%A1%E6%8B%9FJS%E4%B8%AD%E7%9A%84new%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>模拟 JavaScript 中使用 new 关键字配合构造函数创建实例对象。其基本思想如下：</p>
<ol>
<li>创建一个新的空对象（{}）。</li>
<li>给新创建的对象添加 __proto__ 属性，属性值为构造函数的 prototype 属性值。</li>
<li>将构造函数的作用域赋值给新创建的对象（此时 this 就指向了新创建的对象）。</li>
<li>执行构造函数中的代码（为新创建的对象添加属性）</li>
<li>判断构造函数的返回值类型，返回新的对象。</li>
</ol>
<a id="more"></a>

<h2 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h2><p>创建一个名为 <code>newInstance</code> 的函数，接收的第一个参数为构造函数，剩余参数为构造函数指定的实参。</p>
<p>其返回值为其第一个构造函数参数的实例对象。</p>
<blockquote>
<p><strong>newInstance(constructor[, argument1, argument2, argument3, ……])</strong></p>
</blockquote>
<p>具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newInstance</span>(<span class="params">constructor, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个新的空对象</span></span><br><span class="line">  <span class="keyword">const</span> instance = &#123;&#125;</span><br><span class="line">  <span class="comment">// 给新创建的对象添加 __proto__ 属性，属性值为构造函数的 prototype 属性值</span></span><br><span class="line">  instance.__proto__ = <span class="keyword">constructor</span>.prototype</span><br><span class="line">  </span><br><span class="line">  // 将构造函数中的 this 指向新创建的对象，并执行构造函数</span><br><span class="line">  const result = <span class="keyword">constructor</span>.apply(instance, args)</span><br><span class="line"></span><br><span class="line">  // 如果构造函数的返回值为对象类型，函数的返回值就是构造函数的返回值</span><br><span class="line">  // 如果构造函数的返回值为其他基本类型，函数的返回值为构造函数内部新创建的对象</span><br><span class="line">  return result instanceof Object ? result : instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《JavaScript 高级程序设计（第3版）》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">MDN - new 运算符</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>vue.esm.js与vue.runtime.esm.js的差异</title>
    <url>/2020/04/09/vue.esm.js%E4%B8%8Evue.runtime.esm.js%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
    <content><![CDATA[<p>在使用@vue/cli编译项目时，控制台报出如下错误：</p>
<p>[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.</p>
<a id="more"></a>

<p>翻译过来就是说：你正在使用的vue，是<strong>只包含运行时</strong>（<em>runtime-only</em>） 的构建版本，而不包含<strong>编译器</strong>（<em>compiler</em>）。要么将模板预编译进渲染（render）函数，要么使用包含编译器的构建版本。</p>
<p>此时入口文件 main.js 的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App /&gt;'</span></span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="vue的版本"><a href="#vue的版本" class="headerlink" title="vue的版本"></a>vue的版本</h2><p>要想知道问题出现的原因，得先了解 vue 的各个版本：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"><strong>UMD</strong></th>
<th><strong>CommonJS</strong></th>
<th align="left"><strong>ES Module (基于构建工具使用)</strong></th>
<th><strong>ES Module (直接用于浏览器)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>完整版（Full）</strong></td>
<td align="left">vue.js</td>
<td>vue.common.js</td>
<td align="left">vue.esm.js</td>
<td>vue.esm.browser.js</td>
</tr>
<tr>
<td align="left"><strong>只包含运行时版（Runtime-only）</strong></td>
<td align="left">vue.runtime.js</td>
<td>vue.runtime.common.js</td>
<td align="left">vue.runtime.esm.js</td>
<td>-</td>
</tr>
<tr>
<td align="left"><strong>完整版 (生产环境)</strong></td>
<td align="left">vue.min.js</td>
<td>-</td>
<td align="left">-</td>
<td>vue.esm.browser.min.js</td>
</tr>
<tr>
<td align="left"><strong>只包含运行时版 (生产环境)</strong></td>
<td align="left">vue.runtime.min.js</td>
<td>-</td>
<td align="left">-</td>
<td>-</td>
</tr>
</tbody></table>
<center>表：vue各版本</center>  
### 各版本解释

<ul>
<li><p><strong>完整版</strong>：同时包含编译器和运行时的版本。</p>
</li>
<li><p><strong>编译器</strong>：用来将模板编译成为 JavaScript 渲染函数的代码。</p>
</li>
<li><p><strong>运行时</strong>：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。  </p>
</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>当需要在客户端进行编译模板 (比如传入一个字符串给 <code>template</code> 选项，或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板)时，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  component: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App /&gt;'</span></span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>此时就需要使用完整版的 vue。</p>
<p>当使用 <code>vue-loader</code> 或 <code>vueify</code> 的时候，<code>*.vue</code> 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。就像这样： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>render 函数接收一个函数作为参数，用来创建<strong>虚拟DOM</strong>（VNode）。</p>
<p>因为运行时版本相比完整版体积要小大约 30%，所以应该尽可能使用运行时版本。 </p>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>@vue/cli 默认使用的是不带编译器的 runtime-only 版（即 vue.runtime.esm.js），无法对模板进行预编译。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案一：使用带编译器的-vue"><a href="#方案一：使用带编译器的-vue" class="headerlink" title="方案一：使用带编译器的 vue"></a>方案一：使用带编译器的 vue</h3><p>三版本的脚手架 <strong>@vue/cli</strong> 相较于二版本的脚手架 <strong>vue-cli</strong> ，最大的变化就是将配置文件隐藏，我们无法直接修改配置。</p>
<p>当需要修改配置时，可以在 @vue/cli 创建的项目根目录下，新建一个名为 <code>vue.config.js</code> 的配置文件。</p>
<p>1）、我们的目的是修改 webpack 的配置，将引入的 vue 变更为 <strong>vue.esm.js</strong>。参照 @vue/cli 的<a href="https://cli.vuejs.org/zh/config/#configurewebpack" target="_blank" rel="noopener">配置参考</a>和 webpack的<a href="https://webpack.docschina.org/configuration/resolve/#resolve-alias" target="_blank" rel="noopener">配置</a>，在 <code>vue.config.js</code> 中新增一个名为 <code>configureWebpack</code> 的配置选项，具体如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 选项...</span></span><br><span class="line">  configureWebpack: &#123; <span class="comment">// webpack的配置</span></span><br><span class="line">    resolve: &#123;</span><br><span class="line">      alias: &#123; <span class="comment">// 模块路径别名</span></span><br><span class="line">        <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span>  <span class="comment">// $代表精确匹配</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>或者：</strong></p>
<p>在 <code>vue.config.js</code> 中新增一个名为 <code>runtimeCompiler</code> 的配置选项，具体如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 选项...</span></span><br><span class="line">  runtimeCompiler: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runtimeCompiler 的值决定是否使用包含运行时编译器的 vue 构建版本。</p>
<p>其默认值为 <code>false</code>，也就是 @vue/cli 默认使用的是不带编译器的 vue；</p>
<p> 设置为 <code>true</code> 后，则使用带编译器的完整版 vue，就可以在 vue 组件中使用 <code>template</code> 选项了。</p>
<p><strong>再者：</strong></p>
<p>直接引入带编译器的完整版 vue：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue/dist/vue.esm.js'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App /&gt;'</span></span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>不推荐使用这种方式。</p>
<p><strong>三种方式本质一样，都是将 vue 的构架版本修改为带编译器的完整版（vue.esm.js）</strong></p>
<p><strong>前两种方式修改配置后，需重新运行项目。</strong></p>
<h3 id="方案二：使用渲染函数"><a href="#方案二：使用渲染函数" class="headerlink" title="方案二：使用渲染函数"></a>方案二：使用渲染函数</h3><p>直接上代码，将 main.js 的代码修改如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>使用渲染函数，会在项目构建时进行预编译。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="[https://cn.vuejs.org/v2/guide/installation.html#%E5%AF%B9%E4%B8%8D%E5%90%8C%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E9%87%8A](https://cn.vuejs.org/v2/guide/installation.html#对不同构建版本的解释)">vue官方文档 - 对不同构建版本的解释</a></li>
<li><a href="[https://cli.vuejs.org/zh/config/#%E9%85%8D%E7%BD%AE%E5%8F%82%E8%80%83](https://cli.vuejs.org/zh/config/#配置参考)">@vue/cli - 配置参考</a></li>
<li><a href="https://webpack.docschina.org/configuration/resolve/#resolve-alias" target="_blank" rel="noopener">webpack - 配置</a></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>bug</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>new Date().getTime()与Date.now()效率对比</title>
    <url>/2020/04/05/new%20Date.getTime()%E4%B8%8EDate.now()%E6%95%88%E7%8E%87%E5%B0%8F%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>看到好多人的文章里获取时间戳时，会用 <code>new Date().getTime()</code> 获取，而不是使用 <code>Date.now()</code>，难道是前者性能更好？于是做了一个简单的小测试对比一下。</p>
<a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">times1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行new Date().getTime()1次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">1</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行new Date().getTime()1次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行Date.now()1次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">1</span>; index++) &#123;</span><br><span class="line">    <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行Date.now()1次，耗时'</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'------------------------------------------'</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">times10</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行new Date().getTime()10次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行new Date().getTime()10次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行Date.now()10次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">    <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行Date.now()10次，耗时'</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'------------------------------------------'</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">times100</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行new Date().getTime()100次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">100</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行new Date().getTime()100次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行Date.now()100次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">100</span>; index++) &#123;</span><br><span class="line">    <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行Date.now()100次，耗时'</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'------------------------------------------'</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">times1000</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行new Date().getTime()1000次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">1000</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行new Date().getTime()1000次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行Date.now()1000次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">1000</span>; index++) &#123;</span><br><span class="line">    <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行Date.now()1000次，耗时'</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'------------------------------------------'</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">times10000</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行new Date().getTime()10000次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">10000</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行new Date().getTime()10000次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行Date.now()10000次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">10000</span>; index++) &#123;</span><br><span class="line">    <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行Date.now()10000次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'------------------------------------------'</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">times100000</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行new Date().getTime()100000次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">100000</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行new Date().getTime()100000次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行Date.now()100000次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">100000</span>; index++) &#123;</span><br><span class="line">    <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行Date.now()100000次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'------------------------------------------'</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">times1000000</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行new Date().getTime()1000000次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">1000000</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行new Date().getTime()1000000次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行Date.now()1000000次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">1000000</span>; index++) &#123;</span><br><span class="line">    <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行Date.now()1000000次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'------------------------------------------'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><a href="https://i.loli.net/2020/04/05/hQnTXxrSB1uCZde.png" target="_blank"><img src="https://i.loli.net/2020/04/05/hQnTXxrSB1uCZde.png" style="zoom:50%;" /></a></p>
<center>new Date().getTime()与Date.now()效率多次对比</center>

<p><strong><code>Date.now()</code> 的性能明显比 <code>new Date().getTime()</code> 要高</strong>嘛，而且无论是单次调用还是多次调用，都是 <code>Date.now()</code> 较快。</p>
<p>奇怪，那为什么你们都用 <code>new Date().getTime()</code> 哇？（陷入全世界只有我一个人不知道的恐慌）。</p>
<p>此处存疑，欢迎指正！</p>
]]></content>
      <tags>
        <tag>性能优化</tag>
        <tag>小测试</tag>
      </tags>
  </entry>
  <entry>
    <title>你知道requestAnimationFrame()吗？</title>
    <url>/2020/04/05/%E4%BD%A0%E7%9F%A5%E9%81%93requestAnimationFrame()%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<p>Web 应用中，实现动画效果的手段有很多。可以使用 CSS3 的 <em>transition</em> 和 <em>animation</em> 实现；可以使用 HTML5 中的 canvas 实现；也可以可以使用 Javascript 中的定时器进行实现。</p>
<p>除此之外，HTML5 为 Javascript 增加了一个新的 API，即 <code>Window.requestAnimationFrame()</code>，翻译成中文。这个方法会告诉浏览器：你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。</p>
<a id="more"></a>

<h2 id="为什么要使用-requestAnimationFrame"><a href="#为什么要使用-requestAnimationFrame" class="headerlink" title="为什么要使用 requestAnimationFrame()"></a>为什么要使用 requestAnimationFrame()</h2><h3 id="定时器实现动画的弊端"><a href="#定时器实现动画的弊端" class="headerlink" title="定时器实现动画的弊端"></a>定时器实现动画的弊端</h3><p>很长时间以来，<code>setTimeout()</code> 和 <code>setInterval()</code> 都是 JavaScript 实现动画的最核心技术。就像下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">updateAnimations</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    doAnimation1()</span><br><span class="line">    doAnimation2()</span><br><span class="line">    <span class="comment">// 其他动画...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  setInterval(updateAnimations, <span class="number">100</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>函数 <code>updateAnimations</code> 会每隔 100ms 调用一次，根据其内部代码对相应元素进行修改，进行页面的重绘（repaint）。</p>
<h4 id="循环间隔的衡量"><a href="#循环间隔的衡量" class="headerlink" title="循环间隔的衡量"></a>循环间隔的衡量</h4><p>使用这种方式实现动画循环，需要对间隔时间需要从两个方面进行考虑。第一，循环的间隔不能太长，这样才能保证动画效果显得平滑流畅；第二，循环的时间也不能太短，以确保浏览器能够完整的渲染动画。</p>
<p>现如今大多数电脑的刷新率都是 60HZ，也就是说，页面每秒最多只能进行60次重绘。大多数浏览器都会对重绘的操作进行限制，不超过显示器刷新的最大频率。因为即使超过，用户体验也不会有提升，反而可能会使动画抖动，也就是我们日常所说的“掉帧”。</p>
<p>因此，动画的最佳循环间隔是 1000ms/60，约等于 17ms。以这个循环间隔绘制的动画是最平滑流畅的，因为它接近浏览器的极限绘制速度。</p>
<p>在声明式编程时代，这样需要由开发者计算，而最佳方案却只有一个，无疑是不友好的。</p>
<h4 id="定时器的精准问题"><a href="#定时器的精准问题" class="headerlink" title="定时器的精准问题"></a>定时器的精准问题</h4><p>由于 JavaScript 是单线程运行的，所以定时器的回调函数需要等待前面的任务全部执行完毕后，才能执行。因此，当前面任务的执行时间超过定时器所设置的时间间隔，就会导致定时器变得“并不准时”。如下代码所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> end = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="built_in">console</span>.log(end - start)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">30000</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'主线程上的代码正在执行'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 chrome 中运行，如所示：</p>
<p><a href="https://i.loli.net/2020/04/05/uoaQCtTG2jN65fp.png" target="_blank"><img src="https://i.loli.net/2020/04/05/uoaQCtTG2jN65fp.png" style="zoom:50%;" /></a></p>
 <center>定时器“不准时”</center>
可以看到，定时器执行所用的时间并不与所设定的间隔时间吻合。

<p>CSS 动画的优势在于浏览器知道动画什么时候开始，因此其可以明确每次执行动画重绘页面的间隔时间，其动画会更显顺滑。而受限于 JavaScript 的单线程特性，定时器实现的动画，无法保证每次动画执行的间隔时间完全相同。因此定时器实现的动画，可能会出现抖动、卡顿的现象。</p>
<h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame()"></a>requestAnimationFrame()</h3><p>JavaScript 动画受限于定时器的弊端，因此，<code>requestAnimationFrame</code> 应运而生。与定时器相比，其最大的优势在于其顺应浏览器的最大重绘频率（也就是显示器的刷新率）。它保证屏幕的每一次刷新间隔中，操作动画的函数只会执行一次。因此不会出现“丢帧”的情况。</p>
<p>此外，在大多数浏览器里，当 <code>requestAnimationFrame()</code> 运行在后台标签页或者隐藏的<em>&lt;iframe&gt;</em>里时，<code>requestAnimationFrame()</code> 会被暂停调用以提升性能和电池寿命。 </p>
<hr>
<h2 id="requestAnimationFrame-的使用"><a href="#requestAnimationFrame-的使用" class="headerlink" title="requestAnimationFrame()的使用"></a>requestAnimationFrame()的使用</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p> 该方法需要传入一个回调函数作为参数，该回调函数会在浏览器的重绘之前执行。</p>
<blockquote>
<p><strong>window.requestAnimationFrame(callback)</strong></p>
</blockquote>
<p>被传入的回调函数会接收一个参数 DOMHighResTimeStamp， 该参数与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/now" target="_blank" rel="noopener"><code>performance.now()</code></a> 的返回值相同，用于标识 <code>requestAnimationFrame()</code> 开始去执行回调函数的时刻。</p>
<p><code>requestAnimationFrame()</code> 的返回值为一个长整型的数值。 是回调列表中唯一的<strong>标识</strong>，与定时器的返回值类似。是个非零值，没别的意义。可以将之传给 <code>window.cancelAnimationFrame()</code> 以取消回调函数。 </p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'SomeElementYouWantToAnimate'</span>)</span><br><span class="line"><span class="keyword">let</span> moveLength = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeatMove</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  moveLength++</span><br><span class="line">  element.style.transform = <span class="string">`translateX(<span class="subst">$&#123;moveLength&#125;</span>px)`</span></span><br><span class="line">  requestAnimationFrame(repeatMove)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repeatMove()</span><br></pre></td></tr></table></figure>

<p>在动画函数内部调用 <code>requestAnimationFrame</code>，同时传入该动画函数。在执行动画函数时，页面重新绘制，此时 <code>requestAnimationFrame</code> 会调用传入的函数。有点像递归的感觉。</p>
<h2 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级"></a>优雅降级</h2><p><code>requestAnimationFrame</code> 的兼容性，可以参考 <a href="https://caniuse.com/#search=requestAnimationFrame" target="_blank" rel="noopener">CanIUse</a>。</p>
<p><code>requestAnimationFrame</code> 在大多数主流浏览器中都可以使用，但少数低版本浏览器无法使用，因此需要向下兼容，在不兼容的浏览器中使用定时器模拟 <code>requestAnimationFrame</code> 。</p>
<p>以下代码摘自<a href="https://www.zhangxinxu.com/" target="_blank" rel="noopener">张鑫旭的个人博客</a><sup>参考</sup></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> vendors = [<span class="string">'webkit'</span>, <span class="string">'moz'</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; vendors.length &amp;&amp; !<span class="built_in">window</span>.requestAnimationFrame; ++x) &#123;</span><br><span class="line">      <span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vendors[x] + <span class="string">'RequestAnimationFrame'</span>];</span><br><span class="line">      <span class="built_in">window</span>.cancelAnimationFrame = <span class="built_in">window</span>[vendors[x] + <span class="string">'CancelAnimationFrame'</span>] ||    <span class="comment">// Webkit中此取消方法的名字变了</span></span><br><span class="line">                                    <span class="built_in">window</span>[vendors[x] + <span class="string">'CancelRequestAnimationFrame'</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">window</span>.requestAnimationFrame) &#123;</span><br><span class="line">      <span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">callback, element</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> currTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">          <span class="keyword">var</span> timeToCall = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">16.7</span> - (currTime - lastTime));</span><br><span class="line">          <span class="keyword">var</span> id = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">              callback(currTime + timeToCall);</span><br><span class="line">          &#125;, timeToCall);</span><br><span class="line">          lastTime = currTime + timeToCall;</span><br><span class="line">          <span class="keyword">return</span> id;</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">window</span>.cancelAnimationFrame) &#123;</span><br><span class="line">      <span class="built_in">window</span>.cancelAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">          clearTimeout(id);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>使用之后，就可以向下兼容到 IE6。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>JavaScript 高级程序设计（第3版）</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">MDN - window.requestAnimationFrame</a></li>
<li><a href="https://javascript.ruanyifeng.com/" target="_blank" rel="noopener">JavaScrip标准参考教程（alpha），by 阮一峰</a></li>
<li><a href="[https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/?_t_t_t=0.3547051663712042](https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-动画算法/?_t_t_t=0.3547051663712042)">张鑫旭的个人博客 - CSS3动画那么强，requestAnimationFrame还有毛线用？</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>函数节流与函数防抖</title>
    <url>/2020/04/04/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96/</url>
    <content><![CDATA[<p>函数节流与函数防抖，实际上就是为了解决事件频繁被触发，而造成不必要的性能浪费的性能优化手段。例如，浏览器的 <code>onresize</code> 事件，鼠标的 <code>mousemove</code> 事件，如果其频繁触发，很可能会造成浏览器的卡顿；或者，如果向后台频繁发送请求，也会增大服务器的压力。这时，我们就可以使用函数节流或函数防抖进行优化。</p>
<a id="more"></a>

<h2 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h2><blockquote>
<p><strong>概念：在设定的执行周期内，函数只会执行一次</strong></p>
</blockquote>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span> <span class="comment">// start = 0 ，保证第一次current - start 一定大于间隔值 delay，从而保证第一次调用一定会执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">if</span> (current - start &gt; delay) &#123;</span><br><span class="line">      callback.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) <span class="comment">// 1).使this与原事件处理函数中的this相同 2).传入原事件处理函数的参数</span></span><br><span class="line">      start = current</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>函数节流适合多次事件按时间做平均分配触发。</p>
<p>例如：</p>
<ul>
<li>浏览器窗口调整（resize）</li>
<li>页面滚动（scroll）</li>
<li>DOM 元素的拖拽（mousemove）</li>
<li>购物网站抢购（mousedown）</li>
</ul>
<hr>
<h2 id="函数防抖（debounce）"><a href="#函数防抖（debounce）" class="headerlink" title="函数防抖（debounce）"></a>函数防抖（debounce）</h2><blockquote>
<p><strong>概念： 在函数触发一段时间后再执行，如果在这段时间内再次触发，则重新计时。</strong></p>
</blockquote>
<h3 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeId</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存arguments</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">arguments</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除待执行的定时器任务</span></span><br><span class="line">    clearTimeout(timeId)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每隔delay的时间，启动一个新的延时定时器，去准备调用callback</span></span><br><span class="line">    timeId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      callback.apply(<span class="keyword">this</span>, args) <span class="comment">// 1).使this与原事件处理函数中的this相同 2).传入原事件处理函数的参数</span></span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>适合多次事件一次响应的情况</p>
<p>例如：</p>
<ul>
<li>实时搜索联想（keyup）</li>
<li>文本输入的验证（连续输入文字后发送 ajax 请求进行验证，验证一次就好）</li>
<li>判断scroll是否滑到底部（滚动事件+函数防抖）</li>
</ul>
<h2 id="函数节流与函数防抖的比较"><a href="#函数节流与函数防抖的比较" class="headerlink" title="函数节流与函数防抖的比较"></a>函数节流与函数防抖的比较</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul>
<li>都是为了对函数的频繁触发进行优化</li>
</ul>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul>
<li>节流是让函数在每个时间段内只执行一次；而防抖是，规定时间段内的连续触发，只会执行最后一次。</li>
</ul>
]]></content>
      <tags>
        <tag>性能优化</tag>
        <tag>Lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义实现数组的difference方法与merge方法</title>
    <url>/2020/03/25/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84difference%E6%96%B9%E6%B3%95%E4%B8%8Emerge%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="difference-arr"><a href="#difference-arr" class="headerlink" title="difference(arr)"></a>difference(arr)</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>得到一个当前数组中所有不与指定数组 <code>arr</code> 中元素相同的数组（改方法不会改变原数组）。</p>
<p>举个例子，假设数组有一个名为 <code>difference</code> 的方法，可以实现上述功能，那么：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"><span class="built_in">console</span>.log(array.difference([<span class="number">5</span>, <span class="number">7</span>])) <span class="comment">// (3) [1, 2, 5]</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.difference = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!arr || arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...this]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function"><span class="params">item</span> =&gt;</span> arr.indexOf(item) === <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 <code>filter()</code> 与 <code>indexOf()</code> 对当前数组进行过滤，得到结果数组。</p>
<hr>
<h2 id="merge-arr"><a href="#merge-arr" class="headerlink" title="merge(arr)"></a>merge(arr)</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>得到一个由当前数组与指定数组 <code>arr</code> 合并后组成的新的数组（改方法不会改变原数组）。</p>
<p>举个例子，假设数组有一个名为 <code>merge</code> 的方法，可以实现上述功能，那么：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(array.merge([<span class="number">2</span>, <span class="number">6</span>])) <span class="comment">// (5) [1, 2, 3, 6]</span></span><br></pre></td></tr></table></figure>

<p>该方法与数组原生方法 <code>concat</code> 的不同之处在于，如果指定数组 <code>arr</code> 中的元素，在当前数组中已经存在，<code>merge</code> 方法则不会将该重复元素合并到当前数组中。而 <code>concat</code> 会进行合并。</p>
<h2 id="自定义实现-1"><a href="#自定义实现-1" class="headerlink" title="自定义实现"></a>自定义实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.merge = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resultArr = [...this]</span><br><span class="line">  <span class="keyword">if</span> (!arr || arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> resultArr</span><br><span class="line">  &#125;</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (resultArr.indexOf(item) === <span class="number">-1</span>) &#123;</span><br><span class="line">      resultArr.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> resultArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对指定的数组进行遍历，逐个判断是否需要塞入当前数组，从而得到结果数组。</p>
]]></content>
      <tags>
        <tag>Lodash</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义实现Lodash中数组的chunk方法与compact方法</title>
    <url>/2020/03/22/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0Lodash%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84chunk%E6%96%B9%E6%B3%95%E4%B8%8Ecompact%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="chunk-size"><a href="#chunk-size" class="headerlink" title="chunk(size)"></a>chunk(size)</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>将数组（array）拆分成多个 <code>size</code> 长度的区块，并将这些区块组成一个新数组。 如果 <code>array</code>  无法被分割成全部等长的区块，那么最后剩余的元素将组成一个区块。  </p>
<p>举个例子，假设数组有一个名为 <code>chunk</code> 的方法，可以实现上述功能，那么：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.chunk(<span class="number">2</span>)) <span class="comment">// [[1, 2], [3, 4], [5, 6], [7]]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.chunk(<span class="number">3</span>)) <span class="comment">// [[1, 2, 3], [4, 5, 6], [7]]</span></span><br></pre></td></tr></table></figure>

<p>参数 <code>size</code> 的默认值为 1。</p>
<a id="more"></a>

<h3 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.chunk = <span class="function"><span class="keyword">function</span> (<span class="params">size</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// size的默认值为1</span></span><br><span class="line">  size = size || <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> length = <span class="keyword">this</span>.length</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> []</span><br><span class="line">  <span class="keyword">if</span> (size &gt; length) size = length</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> resultArrayLength = <span class="built_in">Math</span>.ceil(length / size)</span><br><span class="line">  <span class="comment">// 结果数组</span></span><br><span class="line">  <span class="keyword">const</span> resultArray = <span class="keyword">new</span> <span class="built_in">Array</span>(resultArrayLength)</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (index &lt; resultArrayLength) &#123;</span><br><span class="line">    resultArray[index++] = <span class="keyword">this</span>.slice(start, start += size)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> resultArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 <code>while</code> 循环与数组的 <code>slice</code> 方法对原数组进行反复的抽取，得到目标数组。</p>
<hr>
<h2 id="compact"><a href="#compact" class="headerlink" title="compact()"></a>compact()</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p> 创建一个新数组，包含原数组中所有的非假值元素。例如 <code>false</code>, <code>null</code>, <code>0</code>, <code>&quot;&quot;</code>, <code>undefined</code>, 和 <code>NaN</code> 都是被认为是“假值”。 </p>
<p>举个例子，假设数组有一个名为 <code>compact</code> 的方法，可以实现上述功能，那么：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">null</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.compact()) <span class="comment">// [1, 'a', 'b', true]</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义实现-1"><a href="#自定义实现-1" class="headerlink" title="自定义实现"></a>自定义实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.compact = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function"><span class="params">value</span> =&gt;</span> value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用数组的 <code>filter</code> 方法对原数组进行过滤，得到目标数组。</p>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.lodashjs.com/docs/lodash.chunk" target="_blank" rel="noopener">Lodash - “Array” 方法</a></li>
</ul>
]]></content>
      <tags>
        <tag>Lodash</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>数组扁平化</title>
    <url>/2020/03/04/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/</url>
    <content><![CDATA[<h2 id="何为数组扁平化？"><a href="#何为数组扁平化？" class="headerlink" title="何为数组扁平化？"></a>何为数组扁平化？</h2><p><strong>数组扁平化是指将一个多维数组转化为一维数组</strong>。</p>
<p>举个例子，假设有个名为 <code>flatten</code> 的函数，接受一个数组作为参数，并将之扁平化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]]</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr)) <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<hr>
<h2 id="实现数组扁平化的方法"><a href="#实现数组扁平化的方法" class="headerlink" title="实现数组扁平化的方法"></a>实现数组扁平化的方法</h2><h3 id="flat"><a href="#flat" class="headerlink" title="flat()"></a>flat()</h3><p>ES2015（即ES6）中新增了数组的 <code>flat()</code> 方法，可以直接对<strong>多维数组</strong>进行“展平”，返回一个“展平”后的数组。</p>
<p><code>flat()</code> 方法和数组的其他方法一样，定义在原型对象 <code>Array.prototype</code> 上。</p>
<p><strong><code>flat()</code> 接收一个可选参数 <code>depth</code>， 用于指定要提取嵌套数组的结构深度，默认值为1。</strong></p>
<p>使用如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'a'</span>, [<span class="string">'b'</span>, [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]], <span class="string">'d'</span>]]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.flat()) <span class="comment">// ['a', 'b', [1, [2, 3]], 'd']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="number">2</span>)) <span class="comment">// ['a', 'b', 1, [2, 3], 'd']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="number">3</span>)) <span class="comment">// ['a', 'b', 1, 2, 3, 'd']</span></span><br></pre></td></tr></table></figure>

<p>可以使用 <strong><code>Infinity</code></strong>，展开任意深度的嵌套数组。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, [<span class="number">5</span>, [<span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]]]]]]</span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="literal">Infinity</span>)) <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<p>当参数 <code>depth</code> 为负数时，会返回一个由原数组<strong>浅拷贝</strong>后的数组。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="keyword">const</span> arr2 = arr.flat(<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// [1, 2, [3, 4]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改浅拷贝得到的数组，原数组也会发生改变</span></span><br><span class="line">arr2[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, [5, 4]]</span></span><br></pre></td></tr></table></figure>

<p><code>flat()</code> 方法会将数组中的空项移除：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.flat() <span class="comment">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="函数递归-reduce-concat"><a href="#函数递归-reduce-concat" class="headerlink" title="函数递归 + reduce() + concat()"></a>函数递归 + reduce() + concat()</h3><p>自定义一个数组的方法 <code>flatten</code>，用于扁平化指定数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDepth</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array.reduce(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">      acc = acc.concat(flattenDepth(item))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      acc = acc.concat(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简写后：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDepth</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> acc.concat(<span class="built_in">Array</span>.isArray(item) ? flattenDepth(item) : item), [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展运算符-some-concat"><a href="#扩展运算符-some-concat" class="headerlink" title="扩展运算符 + some() + concat()"></a>扩展运算符 + some() + concat()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDepth</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (array.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">    array = [].concat(...array)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 ES6 的扩展运算符语法（…）将目标数组中的所有元素遍历取出，进行 <code>concat ()</code> 合并。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>核心思想就是，遍历目标数组，若数组中的元素为非数组，则与返回的新数组进行 <code>concat()</code> 合并；若数组中的元素仍为数组，则进行递归遍历，并同时与返回的新数组进行 <code>concat()</code> 合并，直到目标数组中的所有元素都不是数组为止。</p>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat" target="_blank" rel="noopener">MDN - Array.prototype.flat()</a></li>
</ul>
]]></content>
      <tags>
        <tag>Lodash</tag>
        <tag>Array</tag>
        <tag>flatten</tag>
      </tags>
  </entry>
  <entry>
    <title>promise.then()的返回值</title>
    <url>/2020/02/23/promise.then()%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<p>Promise 实例具有 <code>then</code> 方法，也就是说，<code>then</code> 方法是定义在原型对象 <code>Promise.prototype</code> 上的。它的作用是为 Promise 实例添加状态改变时的回调函数。</p>
<p><code>Promise.prototype.then()</code> 方法返回的是一个<strong>新的 Promise 实例对象</strong>，因此可以采用<strong>链式写法</strong>。</p>
<p>本文主要记录 <code>promise.then()</code> 返回值的不同情况。</p>
<a id="more"></a>

<hr>
<h2 id="then-的基本用法"><a href="#then-的基本用法" class="headerlink" title="then() 的基本用法"></a>then() 的基本用法</h2><blockquote>
<p><strong><code>new Promise(executor).then(onFulfilled[, onRejected])</code></strong> </p>
</blockquote>
<ul>
<li><strong>onFulfilled</strong>： 当 Promise 变成 <strong><em>fulfilled</em></strong> 状态时调用的函数。</li>
<li><strong>onRejected</strong>： 当 Promise 变成 <strong><em>rejected</em></strong> 状态时调用的函数。</li>
</ul>
<hr>
<h2 id="then方法的返回值"><a href="#then方法的返回值" class="headerlink" title="then方法的返回值"></a>then方法的返回值</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong><code>then()</code> 返回的 promise 实例对象的结果由 <code>then()</code> 中指定的回调函数执行的结果决定</strong>。即由传入的 <strong>onFulfilled</strong> 或 <strong>onRejected</strong> 执行的结果决定。</p>
<ul>
<li>没有返回任何值（实际返回 undefined），那么 <code>then()</code> 返回的 promise 将会成为接受（resolved）状态。promise 携带的 value 为 undefined。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onFulfilled'</span>, value)) <span class="comment">// onFulfilled undefined</span></span><br></pre></td></tr></table></figure>



<ul>
<li>返回了一个一般的值，那么 <code>then()</code> 返回的 promise 将会成为接受（resolved）状态。promise 携带的 value 为返回的值。 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">1</span>, () =&gt; <span class="number">2</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onFulfilled'</span>, value)) <span class="comment">// onFulfilled 1</span></span><br></pre></td></tr></table></figure>



<ul>
<li>抛出一个错误（throw xxx），那么 <code>then()</code> 返回的 promise 将会成为拒绝（rejected）状态。promise 携带的 reason 为抛出的错误。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使 .then() 返回一个 rejected promise</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'3'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'不会调用'</span>),</span><br><span class="line">    (reason) =&gt; <span class="built_in">console</span>.log(<span class="string">'onRejected'</span>, reason) <span class="comment">// onRejected Error: 3</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>



<ul>
<li>返回一个接受（resolved）状态的 promise，那么 <code>then()</code> 返回的 promise 将会成为接受（resolved）状态。<code>then()</code> 返回的 promise 携带的 value 为回调函数返回的 promise 携带的 value。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="number">4</span>))</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onFulfilled'</span>, value)) <span class="comment">// onFulfilled 4</span></span><br></pre></td></tr></table></figure>



<ul>
<li>返回一个拒绝（rejected）状态的 promise，那么 <code>then()</code> 返回的 promise 将会成为拒绝（rejected）状态。<code>then()</code> 返回的 promise 携带的 reason 为回调函数返回的 promise 携带的 reason 。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.reject(<span class="number">5</span>))</span><br><span class="line">  .then(</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'不会调用'</span>),</span><br><span class="line">    (reason) =&gt; <span class="built_in">console</span>.log(<span class="string">'onRejected'</span>, reason) <span class="comment">// onRejected 5</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>



<ul>
<li>返回一个初始（pending）状态的 promise，那么 <code>then()</code> 返回的 promise 将会成为初始（pending）状态。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise) <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener">使用 Promise</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的错误Error与错误处理</title>
    <url>/2020/02/20/JS%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AFError%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="Error实例对象"><a href="#Error实例对象" class="headerlink" title="Error实例对象"></a>Error实例对象</h2><p><code>Error</code> 是 JavaScript 中的错误类，它同时也是一个构造函数，可以用来创建一个错误对象。<code>Error</code> 的实例会在运行发生错误时抛出，<code>Error</code> 对象像其它对象一样，也可以由用户自定义创建。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error message'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(err) <span class="comment">// Error: error message</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><blockquote>
<p><strong>new Error([message])</strong></p>
</blockquote>
<ul>
<li><strong>message</strong>：可选参数，表示出错时的提示信息 。</li>
</ul>
<p>JavaScript 语言标准只提到，<code>Error</code> 实例对象有 <code>message</code> 属性，没有提到其他属性 。</p>
<p>不同执行引擎对 <code>Error</code> 类的实现有所不同， 大多数 JavaScript 引擎，对 <code>Error</code> 实例还提供 <code>name</code> 和 <code>stack</code> 属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。 </p>
<ul>
<li><strong>name</strong>：错误名称（非标准属性）</li>
<li><strong>stack</strong>：错误的堆栈（非标准属性）</li>
</ul>
<p><strong>作为函数使用</strong></p>
<p>当像函数一样使用 <code>Error</code> 时 – 如果没有 <code>new</code>，它也会返回一个 <code>Error</code> 对象。也就是说，仅仅调用 <code>Error</code> 将产生与通过 <code>new</code> 关键字构造 <code>Error</code> 输出相同的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> err1 = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(err1) <span class="comment">// Error: 1</span></span><br><span class="line"><span class="keyword">let</span> err2 = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(err2) <span class="comment">// Error: 1</span></span><br></pre></td></tr></table></figure>

<h3 id="Error类的方法与属性"><a href="#Error类的方法与属性" class="headerlink" title="Error类的方法与属性"></a>Error类的方法与属性</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h4><p><code>Error</code> 类本身没有任何方法。但是，由于在 JavaScript 中所有类都是 Object 的子类，所以其会包含一些继承自 <code>Object</code> 类的方法。 </p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p> <code>Error</code> 类也没有自身定义的类属性，其所有属性据来自于其父类<code>Object</code>。 </p>
<ul>
<li><code>Error.prototype</code> － 添加到其实例中的属性</li>
</ul>
<h3 id="Error实例"><a href="#Error实例" class="headerlink" title="Error实例"></a>Error实例</h3><p>运行时错误实例会由执行引擎自动创建和抛出，我们也可以通过构造函数自定义 <code>Error</code> 实例，与其它类一样我们也可以通过 <code>Error.prototype</code> 向实例中添加属性和方法。</p>
<p><code>Error</code> 实例包含以下属性或方法：</p>
<ul>
<li><code>Error.prototype.constructor</code> － 指定对象的构造函数</li>
<li><code>Error.prototype.message</code> － 错误信息</li>
<li><code>Error.prototype.name</code> － 错误名</li>
<li><code>Error.prototype.stack</code> － 错误堆栈信息。该属性是一个非标准属性，但被大多数执行引擎所支持。</li>
<li><code>Error.prototype.toString()</code> － 表示错误对象的描述信息。继承并重写<code>Object.prototype.toString()</code></li>
</ul>
<hr>
<h2 id="Error类型"><a href="#Error类型" class="headerlink" title="Error类型"></a>Error类型</h2><p>除标准错误对象 <code>Error</code> 外，JavaScript 中还内置了一些类型错误对象。它们会在特殊时刻，或由特定的对象触发。 </p>
<p>常用的有：</p>
<h3 id="ReferenceError-引用错误"><a href="#ReferenceError-引用错误" class="headerlink" title="ReferenceError - 引用错误"></a>ReferenceError - 引用错误</h3><p> <code>ReferenceError</code> 错误对象会在<strong>无效引用</strong>时触发。也可以通过构造函数创建该对象的实例：</p>
<blockquote>
<p><strong>new ReferenceError([message])</strong></p>
</blockquote>
<p>引用未定义的变量时，会抛出该错误： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<p> 另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者 <code>this</code> 赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等号左侧不是变量</span></span><br><span class="line"><span class="built_in">console</span>.log() = <span class="number">1</span></span><br><span class="line"><span class="comment">// Uncaught ReferenceError: Invalid left-hand side in assignment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this 对象不能手动赋值</span></span><br><span class="line"><span class="keyword">this</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>

<h3 id="TypeError-类型错误"><a href="#TypeError-类型错误" class="headerlink" title="TypeError - 类型错误"></a>TypeError - 类型错误</h3><p> <code>TypeError</code> 错误会在<strong>变量或参数不属于有效类型</strong>时触发。也可以通过构造函数创建该对象的实例：</p>
<blockquote>
<p><strong>new TypeError([message])</strong></p>
</blockquote>
<p>比如，对字符串、布尔值、数值等原始类型的值使用 <code>new</code> 命令，就会抛出这种错误，因为 <code>new</code> 命令的参数应该是一个构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="number">123</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: 123 is not a constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: true is not a constructor</span></span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>或是当调用对象不存在的方法，也会抛出 <code>TypeError</code> 错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj.unknownMethod()</span><br><span class="line"><span class="comment">// Uncaught TypeError: obj.unknownMethod is not a function</span></span><br></pre></td></tr></table></figure>

<h3 id="SyntaxError-语法错误"><a href="#SyntaxError-语法错误" class="headerlink" title="SyntaxError - 语法错误"></a>SyntaxError - 语法错误</h3><p><code>SyntaxError</code> 错误对象会在解析代码的过程中发生的语法错误时触发。也可以通过构造函数创建该对象的实例：</p>
<blockquote>
<p><strong>new SyntaxError([message])</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量名错误</span></span><br><span class="line"><span class="keyword">let</span> <span class="number">1</span>a</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺少括号</span></span><br><span class="line"><span class="built_in">console</span>.log <span class="string">'hello'</span>)</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected string</span></span><br></pre></td></tr></table></figure>

<p>上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出<code>SyntaxError</code>。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。 </p>
<h3 id="RangeError-范围错误"><a href="#RangeError-范围错误" class="headerlink" title="RangeError - 范围错误"></a>RangeError - 范围错误</h3><p><code>RangeError</code>错误对象会在数值变量或参数超出其有效范围时触发。也可以通过构造函数创建该对象的实例：</p>
<blockquote>
<p><strong>new RangeError([message])</strong></p>
</blockquote>
<p> 触发<code>RangeError</code>错误的情况有：对 <code>Array</code> 构造函数使用错误的长度值； 对 <code>Number</code> 对象的方法参数超出范围； 以及函数堆栈超过最大值等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 Array 构造函数使用错误的长度值</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// Uncaught RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 Number 对象的方法参数超出范围</span></span><br><span class="line"><span class="keyword">let</span> numObj = <span class="number">77.1234</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj.toExponential(<span class="number">101</span>))</span><br><span class="line"><span class="comment">// Uncaught RangeError: toExponential() argument must be between 0 and 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数堆栈超过最大值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fn()</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="comment">// RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>



<p>除了这几种常见的的错误类型之外，还有：</p>
<h3 id="URIError"><a href="#URIError" class="headerlink" title="URIError"></a>URIError</h3><p><code>URIError</code>错误会错误使用全局URI函数如 <code>encodeURI()</code>、<code>decodeURI()</code> 等时触发。也可以通过构造函数创建该对象的实例。</p>
<p>该错误类型在目前的 ECMAScript 规范中仍处于草案（Draft）阶段，<a href="https://www.ecma-international.org/ecma-262/6.0/#sec-native-error-types-used-in-this-standard-evalerror" target="_blank" rel="noopener">详情点击</a>。</p>
<h3 id="InternalError"><a href="#InternalError" class="headerlink" title="InternalError"></a>InternalError</h3><p> <code>InternalError</code> 对象表示出现在 JavaScript 引擎内部的错误。 例如： “InternalError: too much recursion”（内部错误：递归过深）。</p>
<p>该错误类型目前尚未成为规范的一部分。</p>
<h3 id="EvalError"><a href="#EvalError" class="headerlink" title="EvalError"></a>EvalError</h3><p><code>EvalError</code>对象表示全局函数<code>eval()</code>中发生的错误。</p>
<p> 该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留，<a href="https://www.ecma-international.org/ecma-262/6.0/#sec-native-error-types-used-in-this-standard-evalerror" target="_blank" rel="noopener">详情点击</a>。</p>
<hr>
<h2 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h2><p>当 JavaScript 内置错误类型不能满足需要时，还可以自定义错误。自定义错误就是继承 <code>Error</code> 对象，并对其进行一定的扩展：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.message = message || <span class="string">'Default Message'</span></span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'MyError'</span></span><br><span class="line">&#125;</span><br><span class="line">MyError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">MyError.prototype.constructor = MyError</span><br></pre></td></tr></table></figure>

<p>接着，我们就可以生成这种自定义类型的错误了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> MyError(<span class="string">'this is my customizable error'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="错误的处理"><a href="#错误的处理" class="headerlink" title="错误的处理"></a>错误的处理</h2><h3 id="抛出错误-throw-语句"><a href="#抛出错误-throw-语句" class="headerlink" title="抛出错误 - throw 语句"></a>抛出错误 - throw 语句</h3><p> 通常，可以在创建 <code>Error</code> 实例后，通过 <code>throw</code> 关键字抛出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'go wrong!'</span>)</span><br><span class="line"><span class="comment">// Error: go wrong!</span></span><br></pre></td></tr></table></figure>

<p> 实际上，<strong><code>throw</code> 可以抛出任何类型的值</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抛出一个字符串</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">'Error！'</span></span><br><span class="line"><span class="comment">// Uncaught Error！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个数值</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">42</span></span><br><span class="line"><span class="comment">// Uncaught 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个布尔值</span></span><br><span class="line"><span class="keyword">throw</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">// Uncaught true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个对象</span></span><br><span class="line"><span class="keyword">throw</span> &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Error!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught &#123;toString: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<p>对于 JavaScript 引擎来说，遇到 <code>throw</code> 语句，程序就中止了。引擎会接收到 <code>throw</code> 抛出的信息，可能是一个错误实例，也可能是其他类型的值。 </p>
<h3 id="捕获错误-try-…-catch结构"><a href="#捕获错误-try-…-catch结构" class="headerlink" title="捕获错误 - try … catch结构"></a>捕获错误 - try … catch结构</h3><p> 一旦发生错误，程序就中止执行了。 JavaScript提供了 <code>try...catch</code> 结构来捕获和处理错误， 选择是否往下执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'go wrong!'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error.message = '</span> + error.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上方代码，try 代码块中抛出错误，该错误将立即被 catch 捕获，将该错误作为参数传递给 catch，并执行 catch 中的代码。</p>
<p>也就是说，<strong>如果不确定某些代码是否会报错，就可以把它们放在 <code>try...catch</code> 代码块之中，便于进一步对错误进行处理</strong>。 <code>catch</code> 代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。 </p>
<p><code>try...catch</code> 可以嵌套使用。</p>
<h3 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h3><p>可以在 <code>try...catch</code> 结构最后添加一个 <strong><code>finally</code> 代码块，表示不管是否出现错误，都必需在最后运行的语句</strong>。</p>
<p>如下代码，就是一个使用 <code>try...catch...finally</code> 的经典场景。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openFile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		writeFile(data) <span class="comment">// 将可能出错的写入文件放入try代码块中</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">		handleError(err) <span class="comment">// 如果在写入文件过程中出现错误，将在此处理</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">		closeFile() <span class="comment">// 总是会关闭文件</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>即使在 <code>try</code> 和 <code>catch</code> 的代码块中存在 <code>return</code> 语句，<code>finally</code> 中的代码依然会执行。</strong></p>
<p>如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">still</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'result'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'FINALLY'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(still(<span class="string">'test'</span>))</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// FINALLY</span></span><br><span class="line"><span class="comment">// result</span></span><br></pre></td></tr></table></figure>

<p>从阮一峰老师的博客中可以看到： <strong>在 <code>try</code> 或 <code>catch</code> 中，<code>return</code> 语句的执行是排在 <code>finally</code> 代码之前的，只是等 <code>finally</code> 代码执行完毕后才返回</strong>。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(countUp())</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(count)</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中可以看到，<code>countUp()</code> 的返回值 <code>count</code> 先被确定为 0，但是此时并没有直接返回，而是先执行 <code>finally</code> 代码块中的内容。</p>
<p><strong><code>finall</code> 代码块中的 <code>return</code> 语句会覆盖掉在 <code>try</code> 或 <code>catch</code> 中的 <code>return</code></strong>。也就是说， <strong>如果 <code>finall</code> 代码块中存在 <code>return</code>，那么该条 <code>return</code>语句中的值将作为 <code>try...catch...finally</code> 的返回值。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'from_try'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'from_finally'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error" target="_blank" rel="noopener">MDN —— Error</a></li>
<li><a href="https://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">Standard ECMA-262 6th Edition / June 2015 ECMAScript® 2015 Language Specification</a></li>
<li><a href="https://wangdoc.com/javascript/features/error.html" target="_blank" rel="noopener">阮一峰的网络日志 —— 错误处理机制</a></li>
<li><a href="https://itbilu.com/javascript/js/V1oOv4Vv-.html" target="_blank" rel="noopener">IT笔录 —— JavaScript Error对象及错误类型</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>详解state与setState</title>
    <url>/2020/02/15/%E8%AF%A6%E8%A7%A3state%E4%B8%8EsetState/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>本文参考了一些资料，逐一通过例子对 state 和 setState() 进行梳理、总结，并在此记录。</p>
</blockquote>
<blockquote>
<p>使用过 <strong><a href="https://reactjs.org/" target="_blank" rel="noopener">react</a></strong> 的小伙伴都知道， React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。</p>
<p>而 <strong>setState()</strong> 是 react 中的一个非常重要的方法。当我们调用 setState() 的时候，react 会更新组件的状态 <strong>state</strong>，并且自动重新调用 <strong>render</strong> 方法，然后再把 render 方法所渲染的最新的内容显示到页面上。</p>
</blockquote>
<a id="more"></a>

<hr>
<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p> 一个组件的显示形态是可以由它数据状态和配置参数决定的。一个组件可以拥有自己的<strong>状态</strong>， react 的 <strong><a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">state</a></strong> 就是用来存储这种可变化的状态的。</p>
<p>以下方这个 Counter 计数器为例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击按钮 'A 测试1', count数量加1</span></span><br><span class="line">  test1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="number">3</span> &#125;)  <span class="comment">// 调用对象形式的setState()更新状态</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击按钮 'A 测试2', count数量加1</span></span><br><span class="line">  test2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;  <span class="comment">// 调用函数形式的setState()更新状态</span></span><br><span class="line">      count: state.count + <span class="number">1</span></span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()2之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击按钮 'A 测试3', 调用带回调函数的setState()</span></span><br><span class="line">  test3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(</span><br><span class="line">      state =&gt; (&#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;),</span><br><span class="line">      () =&gt; &#123;<span class="comment">// 状态数据更新且界面更新后立即执行</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'在callback中'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击按钮 'A 测试4', 调用两次参数为对象形式的setState()</span></span><br><span class="line">  test4 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()4之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击按钮 'A 测试5', 调用两次参数为函数形式的setState()</span></span><br><span class="line">  test5 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;))</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()5之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'A render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;A组件: &#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.test1&#125;&gt;A 测试1&lt;/</span>button&gt; &amp;nbsp;&amp;nbsp;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.test2&#125;&gt;A 测试<span class="number">2</span>&lt;<span class="regexp">/button&gt; &amp;nbsp;&amp;nbsp;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.test3&#125;&gt;A 测试3&lt;/</span>button&gt; &amp;nbsp;&amp;nbsp;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.test4&#125;&gt;A 测试<span class="number">4</span>&lt;<span class="regexp">/button&gt; &amp;nbsp;&amp;nbsp;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.test5&#125;&gt;A 测试5&lt;/</span>button&gt; &amp;nbsp;&amp;nbsp;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure>

<p>  上面代码是一个 <code>Counter</code> 组件，<code>count</code> 存放在的实例的 <code>state</code> 对象当中，这个对象在构造函数里面初始化。这个组件的 <code>render</code> 函数内，会根据组件的 <code>state</code> 的中的 <code>count</code> 值的变化而对应显示。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p> 当我们要改变组件的状态的时候，不能直接用 <del><code>this.state = xxx</code></del> 这种方式来修改，如果这样做 React 就没办法知道你修改了组件的状态，它也就没有办法更新页面。所以，一定要使用 React 提供的 <code>setState</code> 方法，<strong>它接受一个函数或者对象作为参数</strong>。 </p>
<p> 例如，此代码不会重新渲染组件： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.state.count = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p> 而是应该使用 <code>setState()</code>: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="setState-的基本用法"><a href="#setState-的基本用法" class="headerlink" title="setState()的基本用法"></a>setState()的基本用法</h2><p><code>setState()</code> 更新状态的两种用法</p>
<h3 id="setState-stateChange-callback-——-接收的第一个参数为对象"><a href="#setState-stateChange-callback-——-接收的第一个参数为对象" class="headerlink" title="setState(stateChange[, callback]) —— 接收的第一个参数为对象"></a>setState(stateChange[, callback]) —— 接收的第一个参数为对象</h3><ul>
<li><strong>stateChange</strong> 为一个<strong>对象</strong>， 这个对象表示该组件的新状态。但你只需要传入需要更新的部分，而不需要传入整个对象 。 <code>stateChange</code> 会将传入的对象<strong>浅层合并</strong>到新的 state 中 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line"></span><br><span class="line">test1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setState()2之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>以上方这个组件 Counter 为例，点击按钮 <kbd>A 测试1</kbd>，调用函数 test1，控制台输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; setState()之后 0</span><br><span class="line">&gt; A render() 1</span><br></pre></td></tr></table></figure>

<p>我们可以看出，这种形式的setState()是异步的。</p>
<h3 id="setState-updater-callback-——-接收的第一个参数为函数"><a href="#setState-updater-callback-——-接收的第一个参数为函数" class="headerlink" title="setState(updater[, callback]) —— 接收的第一个参数为函数"></a>setState(updater[, callback]) —— 接收的第一个参数为函数</h3><ul>
<li><strong>updater</strong> 为返回值为 <strong>stateChange对象</strong>的<strong>函数</strong>：<code>(state, props) =&gt; stateChange</code>。React 会把上一个 <code>setState</code> 的结果传入这个函数作为第一个参数， 将此次更新被应用时的 <a href="https://zh-hans.reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">props</a> 做为第二个参数 。即：<strong>updater 函数中 接收的参数 state 和 props 的值永远被保证为最新的</strong>。并且，updater 的返回值会与 state 进行<strong>浅合并</strong>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line"></span><br><span class="line">test2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      count: state.count + <span class="number">1</span></span><br><span class="line">  &#125;))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>以组件 Counter 为例，点击按钮 <kbd>A 测试2</kbd>，调用函数 test2，控制台输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; setState()2之后 0</span><br><span class="line">&gt; A render() 1</span><br></pre></td></tr></table></figure>

<p>这种形式的setState()也是异步的。</p>
<h3 id="setState-param-callback-——-带回调函数的setState"><a href="#setState-param-callback-——-带回调函数的setState" class="headerlink" title="setState(param, callback) —— 带回调函数的setState()"></a>setState(param, callback) —— 带回调函数的setState()</h3><ul>
<li><strong>callback</strong> 是可选的回调函数,  它将在 <code>setState</code> 完成合并并重新渲染组件后执行 。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line"></span><br><span class="line">test3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(</span><br><span class="line">    state =&gt; (&#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;),</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'在callback中'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>以组件 Counter 为例，点击按钮 <kbd>A 测试3</kbd>，调用函数 test3，控制台输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; A render() 1</span><br><span class="line">&gt; 在callback中 1</span><br></pre></td></tr></table></figure>

<p>此时可以获取到 <code>setState()</code> 后最新的状态数据。</p>
<p><strong>注意：</strong></p>
<p>关于 setState() 的第二个参数为可选的回调函数，React官方文档中是这样描述的： <strong>通常，我们建议使用 <code>componentDidUpdate()</code> 来代替此方式</strong>。  </p>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><blockquote>
<blockquote>
<p><strong>如果后续状态不依赖于当前状态 ===&gt; 使用对象方式</strong></p>
</blockquote>
<blockquote>
<p><strong>如果后续状态依赖于当前状态 ===&gt; 使用函数方式</strong></p>
</blockquote>
</blockquote>
<hr>
<h2 id="setState-真的是异步的吗？"><a href="#setState-真的是异步的吗？" class="headerlink" title="setState()真的是异步的吗？"></a>setState()真的是异步的吗？</h2><p>在上面的代码中，我们可以看到，在此时的场景中，对象参数形式 和 函数参数形式 的 <code>setState()</code>都是异步的。那么， <code>setState()</code> 真的是异步的吗？</p>
<h3 id="先给出结论："><a href="#先给出结论：" class="headerlink" title="先给出结论："></a>先给出结论：</h3><ul>
<li><strong>由 React 控制的事件处理过程中的 <code>setState</code> 都是异步的，如：生命周期函数、合成事件</strong>  </li>
<li><strong>由非 React 控制的事件处理过程中的 <code>setState</code> 都是同步的，如：定时器回调中、原生事件监听回调中、promise成功/失败的回调中 ……</strong></li>
</ul>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>接下来我们用几个例子验证一下：</p>
<h4 id="生命周期函数中的-setState"><a href="#生命周期函数中的-setState" class="headerlink" title="生命周期函数中的 setState()"></a>生命周期函数中的 <code>setState()</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之前'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>输出顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; render() 0</span><br><span class="line">&gt; setState()之前 0</span><br><span class="line">&gt; setState()之后 0</span><br><span class="line">&gt; render() 1</span><br></pre></td></tr></table></figure>

<p>结果显而易见，<code>setState()</code> 此时是异步执行的。</p>
<h4 id="合成事件中的-setState"><a href="#合成事件中的-setState" class="headerlink" title="合成事件中的 setState()"></a>合成事件中的 <code>setState()</code></h4><p> 首先得了解一下什么是合成事件，react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在 <code>jsx</code> 中常见的 <code>onClick</code> 、<code>onChange</code> 这些都是合成事件。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">	increment = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之前'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.increment&#125;&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>点击调用，输出顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; render() 0</span><br><span class="line">&gt; setState()之前 0</span><br><span class="line">&gt; setState()之后 0</span><br><span class="line">&gt; render() 1</span><br></pre></td></tr></table></figure>

<p><code>setState()</code> 此时也是异步执行的。</p>
<h4 id="定时器中的-setState"><a href="#定时器中的-setState" class="headerlink" title="定时器中的 setState()"></a>定时器中的 <code>setState()</code></h4><p>首先得了解一下什么是合成事件，react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在 <code>jsx</code> 中常见的 <code>onClick</code> 、<code>onChange</code> 这些都是合成事件。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">	componentDidMount() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setState()之前'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>输出顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; render() 0</span><br><span class="line">&gt; setState()之前 0</span><br><span class="line">&gt; render() 1</span><br><span class="line">&gt; setState()之后 1</span><br></pre></td></tr></table></figure>

<p>此时，<code>setState()</code> 此时是同步执行的。</p>
<p>在定时器中去 <code>setState()</code> 并不算是一个单独的场景，它是随着你外层去决定的。你可以在合成事件中使用定时器，可以在钩子函数中使用定时器 ，也可以在原生事件使用定时器，但是不管是哪个场景下，基于事件轮询机制（event loop）下， 定时器中的 <code>setState()</code> 永远是同步执行的。</p>
<h4 id="原生事件监听回调中的-setState"><a href="#原生事件监听回调中的-setState" class="headerlink" title="原生事件监听回调中的 setState()"></a>原生事件监听回调中的 <code>setState()</code></h4><p> 原生事件是指非 react 合成事件，原生自带的事件监听 <code>addEventListener</code> ，或者也可以用原生js、jq直接 <code>document.querySelector().onclick</code> 这种绑定事件的形式都属于原生事件。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  changeValue = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之前'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.changeValue)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>点击调用，输出顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; render() 0</span><br><span class="line">&gt; setState()之前 0</span><br><span class="line">&gt; render() 1</span><br><span class="line">&gt; setState()之后 1</span><br></pre></td></tr></table></figure>

<p>此时的<code>setState()</code> 此时也是同步执行的。</p>
<h4 id="promise回调中的-setState"><a href="#promise回调中的-setState" class="headerlink" title="promise回调中的 setState()"></a>promise回调中的 <code>setState()</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setState()之前'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>输出顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; render() 0</span><br><span class="line">&gt; setState()之前 0</span><br><span class="line">&gt; render() 1</span><br><span class="line">&gt; setState()之后 1</span><br></pre></td></tr></table></figure>

<p>此时的<code>setState()</code> 此时也是同步执行的。</p>
<p>这里， promise 回调中的 <code>setState()</code>，和之前所说的一样，不管是哪个场景下，promise 回调中的 <code>setState()</code> 永远是同步执行的。</p>
<h3 id="同步-异步-是由什么决定的呢？"><a href="#同步-异步-是由什么决定的呢？" class="headerlink" title="同步/异步 是由什么决定的呢？"></a>同步/异步 是由什么决定的呢？</h3><p>深入源码你会发现：<sup>引自参考文章 6</sup></p>
<blockquote>
<p>在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是<strong>由 React 控制的事件处理过程 setState 不会同步更新 this.state</strong>。  </p>
</blockquote>
<hr>
<h2 id="关于异步的setState-的批量处理"><a href="#关于异步的setState-的批量处理" class="headerlink" title="关于异步的setState()的批量处理"></a>关于异步的setState()的批量处理</h2><h3 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line"></span><br><span class="line">test4 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setState()4之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>以组件 Counter 为例，点击按钮 <kbd>A 测试4</kbd>，调用函数 test4，控制台输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; setState()4之后 0</span><br><span class="line">&gt; A render() 1</span><br></pre></td></tr></table></figure>

<p> 同一周期内会对多个 <code>setState</code> 进行批量处理。例如，如果在同一周期内多次设置 count 增加，则相当于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(</span><br><span class="line">	previousState,</span><br><span class="line">    &#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;,</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p> 后调用的 <code>setState()</code> 将覆盖同一周期内先调用 <code>setState</code> 的值，因此 count 得值仅增加一次， 如果后续状态取决于当前状态，建议使用 updater 函数的形式代替： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test5 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;))</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setState()5之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由于接收的参数 state 和 props 的值永远被保证为最新的</strong>，所以输出以下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; setState()5之后 0</span><br><span class="line">&gt; A render() 2</span><br></pre></td></tr></table></figure>



<h3 id="多次调用-如何处理"><a href="#多次调用-如何处理" class="headerlink" title="多次调用, 如何处理?"></a>多次调用, 如何处理?</h3><ul>
<li>setState({}): 合并更新一次状态, 只调用一次 <code>render()</code> 更新界面 ===&gt; <strong>状态更新和界面更新都合并了</strong>。</li>
<li>setState(fn): 更新多次状态, 但只调用一次 <code>render()</code> 更新界面 ===&gt; <strong>状态更新没有合并, 但界面更新合并了</strong>。</li>
</ul>
<h3 id="结论：-1"><a href="#结论：-1" class="headerlink" title="结论："></a>结论：</h3><p><strong>由于 React 会对同一周期内的 <code>setState()</code> 进行合并，所以， 在使用 React 的时候，并不需要担心多次进行 <code>setState</code> 会带来性能问题</strong>  </p>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>掌握 <code>setState()</code> 的基本用法，分清 <code>setState()</code> 在不同应用场景下的执行流程，注意  <code>setState()</code> 的合并处理。开发中基本不会再跳这个方法的坑了。</p>
<p> 如果哪里有说的不对的地方，欢迎指正。</p>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#setstate" target="_blank" rel="noopener">React官方文档 —— setState()</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="noopener">阮一峰的网络日志 —— React 入门实例教程</a></li>
<li><a href="http://huziketang.mangojuice.top/books/react/lesson10" target="_blank" rel="noopener">React.js 小书 —— 组件的 state 和 setState</a></li>
<li><a href="https://www.runoob.com/react/react-state.html" target="_blank" rel="noopener">菜鸟教程 —— React State(状态)</a></li>
<li><a href="https://juejin.im/post/5b45c57c51882519790c7441#heading-0" target="_blank" rel="noopener">你真的理解setState吗？</a></li>
<li><a href="https://www.zhihu.com/question/66749082/answer/246217812" target="_blank" rel="noopener">问一个react更新State的问题？ - Lucas HC的回答 - 知乎 </a></li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>Component和PureComponent</title>
    <url>/2020/02/14/Component%E5%92%8CPureComponent/</url>
    <content><![CDATA[<blockquote>
<p><code>React.PureComponent</code> 与 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent" target="_blank" rel="noopener"><code>React.Component</code></a> 很相似。两者的区别在于 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent" target="_blank" rel="noopener"><code>React.Component</code></a> 并未实现 <a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate" target="_blank" rel="noopener"><code>shouldComponentUpdate()</code></a>，而 <code>React.PureComponent</code> 中以浅层对比 prop 和 state 的方式来实现了该函数。</p>
</blockquote>
<a id="more"></a>

<h2 id="使用Component存在的问题"><a href="#使用Component存在的问题" class="headerlink" title="使用Component存在的问题"></a>使用Component存在的问题</h2><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>我们先来看看下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">class A extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m1: &#123;</span><br><span class="line">      count: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  testA &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;A render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;A组件: m1.count&#x3D;&#123;this.state.m1.count&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.testA&#125;&gt;test A&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;B m1&#x3D;&#123;this.state.m1&#125;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">class B extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m2: &#123;</span><br><span class="line">      count: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;B render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;B组件: &lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;div&gt;m2.count&#x3D;&#123;this.state.m2.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div&gt;m1.count&#x3D;&#123;this.props.m1.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;A&#x2F;&gt;, document.getElementById(&#39;example&#39;))</span><br></pre></td></tr></table></figure>

<p>上面的代码中，组件A是组件B的父组件。同时，组件A将维护的状态 <code>m1</code> 作为B组件的属性传递给他。</p>
<p>点击 <kbd>test A</kbd>，输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; A render()</span><br><span class="line">&gt; B render()</span><br></pre></td></tr></table></figure>

<p>我们会发现，此时，即使 A组件 的 <code>state</code> 没有发生变化，A组件也会重新渲染。即使 B组件 的 <code>state</code> 和 <code>props</code> 都没有发生改变，但只要 A组件 重新渲染，B组件 也会重新渲染。</p>
<p>也就是说，当前使用的继承类 <code>Component</code> 存在这两个问题：</p>
<ul>
<li><strong>当前组件 <code>setState()</code>，会重新执行 <code>render()</code>，即使 state 没有任何变化。</strong></li>
<li><strong>父组件重新 <code>render()</code>, 当前组件也会重新执行 <code>render()</code>, 即使 state 和 <code>porps</code> 没有任何变化。</strong></li>
</ul>
<p>这样，就导致了本不必要的性能浪费。  </p>
<h3 id="为什么会存在这些问题？"><a href="#为什么会存在这些问题？" class="headerlink" title="为什么会存在这些问题？"></a>为什么会存在这些问题？</h3><p>首先我们来看一下 React 的生命周期：</p>
<p><a href="https://i.loli.net/2020/04/05/9KNUBvCmtXxwQA4.jpg" target="_blank"><img src="https://i.loli.net/2020/04/05/9KNUBvCmtXxwQA4.jpg" style="zoom:60%;"  ></a></p>
<center>图源来自网络</center>

<p>从这张图中可以很轻松的看到，组件运行时，无论是父组件重新 <code>render()</code>，还是子组件的 state 发生改变，都会调用 <strong><code>shouldComponentUpdate()</code></strong> 这个方法。 它<strong>接收两个参数：nextProps和nextState</strong>，分别表示新的 props 和新的 state 的值。并且，当函数返回 ture 时，组件会重新调用 <code>render()</code> 进行 update ；当函数返回 false 时，组件不会重新渲染。</p>
<p>然而，<strong>Component 类的 <code>shouldComponentUpdate()</code> 默认返回 true, 即使数据没有变化 <code>render()</code> 也会重新执行</strong>，这就导致了我们上方的问题。</p>
<hr>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="重写shouldComponentUpdate"><a href="#重写shouldComponentUpdate" class="headerlink" title="重写shouldComponentUpdate()"></a>重写shouldComponentUpdate()</h3><p>上面我们说，<code>shouldComponentUpdate()</code> 默认返回 true，所以导致了不必要的重新渲染。于是我们可以在<code>shouldComponentUpdate()</code>中加入条件判断，从而优化性能。</p>
<p>在上面的例子中，我们在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">class A extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m1: &#123;</span><br><span class="line">      count: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  testA &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  shouldComponentUpdate(nextProps, nextState)&#123;</span><br><span class="line">    return nextState.m1 &#x3D;&#x3D;&#x3D; this.state.m1 ? false : true</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;A render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;A组件: m1.count&#x3D;&#123;this.state.m1.count&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.testA&#125;&gt;test A&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;B m1&#x3D;&#123;this.state.m1&#125;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">class B extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m2: &#123;</span><br><span class="line">      count: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState)&#123;</span><br><span class="line">    return nextProps.m1 &#x3D;&#x3D;&#x3D; this.props.m1 &amp;&amp; nextState.m2 &#x3D;&#x3D;&#x3D; this.state.m2 ? false : true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;B render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;B组件: &lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;div&gt;m2.count&#x3D;&#123;this.state.m2.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div&gt;m1.count&#x3D;&#123;this.props.m1.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;A&#x2F;&gt;, document.getElementById(&#39;example&#39;))</span><br></pre></td></tr></table></figure>

<p>可是这样，又有了一个新的问题。当组件的 state 或 props 很多时，这样无疑会非常麻烦。</p>
<p>所以，我们可以使用 PureComponent 很轻松的解决。</p>
<h3 id="使用PureComponent"><a href="#使用PureComponent" class="headerlink" title="使用PureComponent"></a>使用PureComponent</h3><p> React中提供了一个 <code>PureComponent</code> 的类，当我们的组件继承于它时，组件更新时就会默认先比较新旧属性和状态，从而决定组件是否更新。</p>
<p> 不过值得注意的是，<strong><code>PureComponent</code>进行的是浅比较，所以组件状态或属性改变时，都需要返回一个新的对象或数组</strong>。</p>
<p>就像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">class A extends React.PureComponent &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m1: &#123;</span><br><span class="line">      count: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  testA &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(state &#x3D;&gt; (&#123;</span><br><span class="line">      m1: &#123;...state.m1, count: 2&#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  shouldComponentUpdate(nextProps, nextState)&#123;</span><br><span class="line">    return nextState.m1 &#x3D;&#x3D;&#x3D; this.state.m1 ? false : true</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;A render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;A组件: m1.count&#x3D;&#123;this.state.m1.count&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.testA&#125;&gt;test A&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;B m1&#x3D;&#123;this.state.m1&#125;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">class B extends React.PureComponent &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m2: &#123;</span><br><span class="line">      count: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState)&#123;</span><br><span class="line">    return nextProps.m1 &#x3D;&#x3D;&#x3D; this.props.m1 &amp;&amp; nextState.m2 &#x3D;&#x3D;&#x3D; this.state.m2 ? false : true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;B render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;B组件: &lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;div&gt;m2.count&#x3D;&#123;this.state.m2.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div&gt;m1.count&#x3D;&#123;this.props.m1.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;A&#x2F;&gt;, document.getElementById(&#39;example&#39;))</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent" target="_blank" rel="noopener">React官方文档 —— React.PureComponent</a></li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>同步回调与异步回调</title>
    <url>/2020/02/06/%E5%90%8C%E6%AD%A5%E5%9B%9E%E8%B0%83%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>对js回调函数进行归纳总结</p>
</blockquote>
<blockquote>
<p>涉及的名词：单线程、回调函数  </p>
</blockquote>
<a id="more"></a>

<hr>
<h2 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h2><h3 id="js是单线程的"><a href="#js是单线程的" class="headerlink" title="js是单线程的"></a>js是单线程的</h3><h4 id="什么是单线程？"><a href="#什么是单线程？" class="headerlink" title="什么是单线程？"></a>什么是单线程？</h4><p>所谓“单线程”，就是同一时间只能处理一个任务，如果有多个任务，就必须依次执行。只有当前一个任务执行完了，后一个任务才会执行。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">'1'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>执行上面的代码，执行顺序：</p>
<ol>
<li>页面弹窗显示<strong>1</strong>，此时控制台没有内容。</li>
<li>点击弹窗确定，控制台输出<strong>2。</strong>  </li>
</ol>
<p>即<code>console.log(&#39;2&#39;)</code>这条语句会在<code>alert(&#39;1&#39;)</code>执行结束后才开始执行</p>
<h4 id="为什么JavaScript是单线程？"><a href="#为什么JavaScript是单线程？" class="headerlink" title="为什么JavaScript是单线程？"></a>为什么JavaScript是单线程？</h4><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
<p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程。  </p>
<hr>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><h4 id="回调函数是什么？"><a href="#回调函数是什么？" class="headerlink" title="回调函数是什么？"></a>回调函数是什么？</h4><p>MDN对回调函数的定义： 被作为实参传入另一函数，并在该外部函数内被调用，用以来完成某些任务的函数，称为<strong>回调函数</strong> 。</p>
<p>想要弄清楚回调函数，首先要清楚js中的函数，JavaScript中的函数本质是一个对象，准确来说是通过<code>new Function()</code>创建的Function的实例对象。因此我们可以将函数像对象一样存保存在变量中，当然也就可以将保存在变量中的函数通过参数传递给另一个函数，这个作为参数传递的函数，就是<strong>回调函数</strong>。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">setTimeOut(fn(<span class="number">1</span>), <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>



<h4 id="为什么使用回调函数？"><a href="#为什么使用回调函数？" class="headerlink" title="为什么使用回调函数？"></a>为什么使用回调函数？</h4><p>js的单线程特性，使得所有任务需依次执行，如果前一个任务的执行需要很长时间，那么整个程序的执行时间就都会被拉长。</p>
<p> 为了解决这个问题，Javascript语言将任务的执行模式分成两种：<u>同步（Synchronous）</u>和<u>异步（Asynchronous）</u> 。</p>
<p><strong>同步任务</strong>指的是需要在主线程上排队依次执行的任务，前一个任务结束，才会执行后一个任务。 任务执行的顺序与代码排列的顺序是一致的、同步的，同步任务会导致阻塞；<strong>异步任务</strong>指的是不会阻塞主线程上的下一个同步任务，而是会进入的回调队列（callback queue）的任务。</p>
<p>而回调函数，正是实现异步编程的方法之一。  </p>
<hr>
<h2 id="同步回调与异步回调"><a href="#同步回调与异步回调" class="headerlink" title="同步回调与异步回调"></a>同步回调与异步回调</h2><p>回调函数不等于异步， 同步(阻塞)的场景下也经常用到回调</p>
<h3 id="同步回调"><a href="#同步回调" class="headerlink" title="同步回调"></a>同步回调</h3><p>立即执行，完全执行完了才会执行下一个任务，不会放入回调队列中</p>
<p>如：数组遍历相关的回调函数 / Promise的excutor函数</p>
<p><strong>例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'遍历的回调'</span>, item, index)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'forEach()之后'</span>)</span><br></pre></td></tr></table></figure>

<p>数组的forEach()方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历的回调, 1, 0</span></span><br><span class="line"><span class="comment">// 遍历的回调, 2, 1</span></span><br><span class="line"><span class="comment">// 遍历的回调, 3, 2</span></span><br><span class="line"><span class="comment">// forEach()之后</span></span><br></pre></td></tr></table></figure>

<p>执行结果  </p>
<h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><p>不会立即执行, 会放入回调队列中将来执行</p>
<p>如：定时器回调 / ajax回调 / 事件监听回调/ Promise的成功和失败的回调</p>
<p><strong>例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'回调函数'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'setTimeout()之后'</span>)</span><br></pre></td></tr></table></figure>

<p>定时器回调</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setTimeout()之后</span></span><br><span class="line"><span class="comment">// 回调函数</span></span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></li>
<li><a href="[http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html](http://www.ruanyifeng.com/blog/2012/12/asynchronous＿javascript.html)">Javascript异步编程的4种方法</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>回调函数</tag>
      </tags>
  </entry>
</search>
