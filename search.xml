<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>自定义实现Lodash中数组的chunk方法与compact方法</title>
    <url>/2020/03/22/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0Lodash%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84chunk%E6%96%B9%E6%B3%95%E4%B8%8Ecompact%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="chunk-size"><a href="#chunk-size" class="headerlink" title="chunk(size)"></a>chunk(size)</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>将数组（array）拆分成多个 <code>size</code> 长度的区块，并将这些区块组成一个新数组。 如果 <code>array</code>  无法被分割成全部等长的区块，那么最后剩余的元素将组成一个区块。  </p>
<p>举个例子，假设数组有一个名为 <code>chunk</code> 的方法，可以实现上述功能，那么：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.chunk(<span class="number">2</span>)) <span class="comment">// [[1, 2], [3, 4], [5, 6], [7]]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.chunk(<span class="number">3</span>)) <span class="comment">// [[1, 2, 3], [4, 5, 6], [7]]</span></span><br></pre></td></tr></table></figure>

<p>参数 <code>size</code> 的默认值为 1。</p>
<h3 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.chunk = <span class="function"><span class="keyword">function</span> (<span class="params">size</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// size的默认值为1</span></span><br><span class="line">  size = size || <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> length = <span class="keyword">this</span>.length</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> []</span><br><span class="line">  <span class="keyword">if</span> (size &gt; length) size = length</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> resultArrayLength = <span class="built_in">Math</span>.ceil(length / size)</span><br><span class="line">  <span class="comment">// 结果数组</span></span><br><span class="line">  <span class="keyword">const</span> resultArray = <span class="keyword">new</span> <span class="built_in">Array</span>(resultArrayLength)</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (index &lt; resultArrayLength) &#123;</span><br><span class="line">    resultArray[index++] = <span class="keyword">this</span>.slice(start, start += size)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> resultArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 <code>while</code> 循环与数组的 <code>slice</code> 方法对原数组进行反复的抽取，得到目标数组。</p>
<h2 id="compact"><a href="#compact" class="headerlink" title="compact()"></a>compact()</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p> 创建一个新数组，包含原数组中所有的非假值元素。例如 <code>false</code>, <code>null</code>, <code>0</code>, <code>&quot;&quot;</code>, <code>undefined</code>, 和 <code>NaN</code> 都是被认为是“假值”。 </p>
<p>举个例子，假设数组有一个名为 <code>compact</code> 的方法，可以实现上述功能，那么：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">null</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.compact()) <span class="comment">// [1, 'a', 'b', true]</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义实现-1"><a href="#自定义实现-1" class="headerlink" title="自定义实现"></a>自定义实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.compact = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function"><span class="params">value</span> =&gt;</span> value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用数组的 <code>filter</code> 方法对原数组进行过滤，得到目标数组。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.lodashjs.com/docs/lodash.chunk" target="_blank" rel="noopener">Lodash - <code>“Array” 方法</code></a></li>
</ul>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>Lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>数组扁平化</title>
    <url>/2020/03/04/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/</url>
    <content><![CDATA[<h2 id="何为数组扁平化？"><a href="#何为数组扁平化？" class="headerlink" title="何为数组扁平化？"></a>何为数组扁平化？</h2><p><strong>数组扁平化是指将一个多维数组转化为一维数组</strong>。</p>
<p>举个例子，假设有个名为 <code>flatten</code> 的函数，接受一个数组作为参数，并将之扁平化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]]</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr)) <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<hr>
<h2 id="实现数组扁平化的方法"><a href="#实现数组扁平化的方法" class="headerlink" title="实现数组扁平化的方法"></a>实现数组扁平化的方法</h2><h3 id="flat"><a href="#flat" class="headerlink" title="flat()"></a>flat()</h3><p>ES2015（即ES6）中新增了数组的 <code>flat()</code> 方法，可以直接对<strong>多维数组</strong>进行“展平”，返回一个“展平”后的数组。</p>
<p><code>flat()</code> 方法和数组的其他方法一样，定义在原型对象 <code>Array.prototype</code> 上。</p>
<p><strong><code>flat()</code> 接收一个可选参数 <code>depth</code>， 用于指定要提取嵌套数组的结构深度，默认值为1。</strong></p>
<p>使用如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'a'</span>, [<span class="string">'b'</span>, [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]], <span class="string">'d'</span>]]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.flat()) <span class="comment">// ['a', 'b', [1, [2, 3]], 'd']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="number">2</span>)) <span class="comment">// ['a', 'b', 1, [2, 3], 'd']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="number">3</span>)) <span class="comment">// ['a', 'b', 1, 2, 3, 'd']</span></span><br></pre></td></tr></table></figure>

<p>可以使用 <strong><code>Infinity</code></strong>，展开任意深度的嵌套数组。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, [<span class="number">5</span>, [<span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]]]]]]</span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="literal">Infinity</span>)) <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<p>当参数 <code>depth</code> 为负数时，会返回一个由原数组<strong>浅拷贝</strong>后的数组。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="keyword">const</span> arr2 = arr.flat(<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// [1, 2, [3, 4]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改浅拷贝得到的数组，原数组也会发生改变</span></span><br><span class="line">arr2[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, [5, 4]]</span></span><br></pre></td></tr></table></figure>

<p><code>flat()</code> 方法会将数组中的空项移除：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.flat() <span class="comment">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="函数递归-reduce-concat"><a href="#函数递归-reduce-concat" class="headerlink" title="函数递归 + reduce() + concat()"></a>函数递归 + reduce() + concat()</h3><p>自定义一个数组的方法 <code>flatten</code>，用于扁平化指定数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDepth</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array.reduce(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">      acc = acc.concat(flattenDepth(item))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      acc = acc.concat(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简写后：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDepth</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> acc.concat(<span class="built_in">Array</span>.isArray(item) ? flattenDepth(item) : item), [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展运算符-some-concat"><a href="#扩展运算符-some-concat" class="headerlink" title="扩展运算符 + some() + concat()"></a>扩展运算符 + some() + concat()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDepth</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (array.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">    array = [].concat(...array)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 ES6 的扩展运算符语法（…）将目标数组中的所有元素遍历取出，进行 <code>concat ()</code> 合并。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>核心思想就是，遍历目标数组，若数组中的元素为非数组，则与返回的新数组进行 <code>concat()</code> 合并；若数组中的元素仍为数组，则进行递归遍历，并同时与返回的新数组进行 <code>concat()</code> 合并，直到目标数组中的所有元素都不是数组为止。</p>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat" target="_blank" rel="noopener">MDN - Array.prototype.flat()</a></li>
</ul>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>flatten</tag>
        <tag>Lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>promise.then()的返回值</title>
    <url>/2020/02/23/promise.then()%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<p>Promise 实例具有 <code>then</code> 方法，也就是说，<code>then</code> 方法是定义在原型对象 <code>Promise.prototype</code> 上的。它的作用是为 Promise 实例添加状态改变时的回调函数。</p>
<p><code>Promise.prototype.then()</code> 方法返回的是一个<strong>新的 Promise 实例对象</strong>，因此可以采用<strong>链式写法</strong>。</p>
<p>本文主要记录 <code>promise.then()</code> 返回值的不同情况。</p>
<a id="more"></a>

<hr>
<h2 id="then-的基本用法"><a href="#then-的基本用法" class="headerlink" title="then() 的基本用法"></a>then() 的基本用法</h2><blockquote>
<p><strong><code>new Promise(executor).then(onFulfilled[, onRejected])</code></strong> </p>
</blockquote>
<ul>
<li><strong>onFulfilled</strong>： 当 Promise 变成 <strong><em>fulfilled</em></strong> 状态时调用的函数。</li>
<li><strong>onRejected</strong>： 当 Promise 变成 <strong><em>rejected</em></strong> 状态时调用的函数。</li>
</ul>
<hr>
<h2 id="then方法的返回值"><a href="#then方法的返回值" class="headerlink" title="then方法的返回值"></a>then方法的返回值</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong><code>then()</code> 返回的 promise 实例对象的结果由 <code>then()</code> 中指定的回调函数执行的结果决定</strong>。即由传入的 <strong>onFulfilled</strong> 或 <strong>onRejected</strong> 执行的结果决定。</p>
<ul>
<li>没有返回任何值（实际返回 undefined），那么 <code>then()</code> 返回的 promise 将会成为接受（resolved）状态。promise 携带的 value 为 undefined。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onFulfilled'</span>, value)) <span class="comment">// onFulfilled undefined</span></span><br></pre></td></tr></table></figure>



<ul>
<li>返回了一个一般的值，那么 <code>then()</code> 返回的 promise 将会成为接受（resolved）状态。promise 携带的 value 为返回的值。 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">1</span>, () =&gt; <span class="number">2</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onFulfilled'</span>, value)) <span class="comment">// onFulfilled 1</span></span><br></pre></td></tr></table></figure>



<ul>
<li>抛出一个错误（throw xxx），那么 <code>then()</code> 返回的 promise 将会成为拒绝（rejected）状态。promise 携带的 reason 为抛出的错误。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使 .then() 返回一个 rejected promise</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'3'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'不会调用'</span>),</span><br><span class="line">    (reason) =&gt; <span class="built_in">console</span>.log(<span class="string">'onRejected'</span>, reason) <span class="comment">// onRejected Error: 3</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>



<ul>
<li>返回一个接受（resolved）状态的 promise，那么 <code>then()</code> 返回的 promise 将会成为接受（resolved）状态。<code>then()</code> 返回的 promise 携带的 value 为回调函数返回的 promise 携带的 value。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="number">4</span>))</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onFulfilled'</span>, value)) <span class="comment">// onFulfilled 4</span></span><br></pre></td></tr></table></figure>



<ul>
<li>返回一个拒绝（rejected）状态的 promise，那么 <code>then()</code> 返回的 promise 将会成为拒绝（rejected）状态。<code>then()</code> 返回的 promise 携带的 reason 为回调函数返回的 promise 携带的 reason 。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.reject(<span class="number">5</span>))</span><br><span class="line">  .then(</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'不会调用'</span>),</span><br><span class="line">    (reason) =&gt; <span class="built_in">console</span>.log(<span class="string">'onRejected'</span>, reason) <span class="comment">// onRejected 5</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>



<ul>
<li>返回一个初始（pending）状态的 promise，那么 <code>then()</code> 返回的 promise 将会成为初始（pending）状态。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise) <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener">使用 Promise</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的错误Error与错误处理</title>
    <url>/2020/02/20/JS%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AFError%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="Error实例对象"><a href="#Error实例对象" class="headerlink" title="Error实例对象"></a>Error实例对象</h2><p><code>Error</code> 是 JavaScript 中的错误类，它同时也是一个构造函数，可以用来创建一个错误对象。<code>Error</code> 的实例会在运行发生错误时抛出，<code>Error</code> 对象像其它对象一样，也可以由用户自定义创建。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error message'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(err) <span class="comment">// Error: error message</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><blockquote>
<p><strong>new Error([message])</strong></p>
</blockquote>
<ul>
<li><strong>message</strong>：可选参数，表示出错时的提示信息 。</li>
</ul>
<p>JavaScript 语言标准只提到，<code>Error</code> 实例对象有 <code>message</code> 属性，没有提到其他属性 。</p>
<p>不同执行引擎对 <code>Error</code> 类的实现有所不同， 大多数 JavaScript 引擎，对 <code>Error</code> 实例还提供 <code>name</code> 和 <code>stack</code> 属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。 </p>
<ul>
<li><strong>name</strong>：错误名称（非标准属性）</li>
<li><strong>stack</strong>：错误的堆栈（非标准属性）</li>
</ul>
<p><strong>作为函数使用</strong></p>
<p>当像函数一样使用 <code>Error</code> 时 – 如果没有 <code>new</code>，它也会返回一个 <code>Error</code> 对象。也就是说，仅仅调用 <code>Error</code> 将产生与通过 <code>new</code> 关键字构造 <code>Error</code> 输出相同的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> err1 = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(err1) <span class="comment">// Error: 1</span></span><br><span class="line"><span class="keyword">let</span> err2 = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(err2) <span class="comment">// Error: 1</span></span><br></pre></td></tr></table></figure>

<h3 id="Error类的方法与属性"><a href="#Error类的方法与属性" class="headerlink" title="Error类的方法与属性"></a>Error类的方法与属性</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h4><p><code>Error</code> 类本身没有任何方法。但是，由于在 JavaScript 中所有类都是 Object 的子类，所以其会包含一些继承自 <code>Object</code> 类的方法。 </p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p> <code>Error</code> 类也没有自身定义的类属性，其所有属性据来自于其父类<code>Object</code>。 </p>
<ul>
<li><code>Error.prototype</code> － 添加到其实例中的属性</li>
</ul>
<h3 id="Error实例"><a href="#Error实例" class="headerlink" title="Error实例"></a>Error实例</h3><p>运行时错误实例会由执行引擎自动创建和抛出，我们也可以通过构造函数自定义 <code>Error</code> 实例，与其它类一样我们也可以通过 <code>Error.prototype</code> 向实例中添加属性和方法。</p>
<p><code>Error</code> 实例包含以下属性或方法：</p>
<ul>
<li><code>Error.prototype.constructor</code> － 指定对象的构造函数</li>
<li><code>Error.prototype.message</code> － 错误信息</li>
<li><code>Error.prototype.name</code> － 错误名</li>
<li><code>Error.prototype.stack</code> － 错误堆栈信息。该属性是一个非标准属性，但被大多数执行引擎所支持。</li>
<li><code>Error.prototype.toString()</code> － 表示错误对象的描述信息。继承并重写<code>Object.prototype.toString()</code></li>
</ul>
<hr>
<h2 id="Error类型"><a href="#Error类型" class="headerlink" title="Error类型"></a>Error类型</h2><p>除标准错误对象 <code>Error</code> 外，JavaScript 中还内置了一些类型错误对象。它们会在特殊时刻，或由特定的对象触发。 </p>
<p>常用的有：</p>
<h3 id="ReferenceError-引用错误"><a href="#ReferenceError-引用错误" class="headerlink" title="ReferenceError - 引用错误"></a>ReferenceError - 引用错误</h3><p> <code>ReferenceError</code> 错误对象会在<strong>无效引用</strong>时触发。也可以通过构造函数创建该对象的实例：</p>
<blockquote>
<p><strong>new ReferenceError([message])</strong></p>
</blockquote>
<p>引用未定义的变量时，会抛出该错误： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<p> 另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者 <code>this</code> 赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等号左侧不是变量</span></span><br><span class="line"><span class="built_in">console</span>.log() = <span class="number">1</span></span><br><span class="line"><span class="comment">// Uncaught ReferenceError: Invalid left-hand side in assignment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this 对象不能手动赋值</span></span><br><span class="line"><span class="keyword">this</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>

<h3 id="TypeError-类型错误"><a href="#TypeError-类型错误" class="headerlink" title="TypeError - 类型错误"></a>TypeError - 类型错误</h3><p> <code>TypeError</code> 错误会在<strong>变量或参数不属于有效类型</strong>时触发。也可以通过构造函数创建该对象的实例：</p>
<blockquote>
<p><strong>new TypeError([message])</strong></p>
</blockquote>
<p>比如，对字符串、布尔值、数值等原始类型的值使用 <code>new</code> 命令，就会抛出这种错误，因为 <code>new</code> 命令的参数应该是一个构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="number">123</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: 123 is not a constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: true is not a constructor</span></span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>或是当调用对象不存在的方法，也会抛出 <code>TypeError</code> 错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj.unknownMethod()</span><br><span class="line"><span class="comment">// Uncaught TypeError: obj.unknownMethod is not a function</span></span><br></pre></td></tr></table></figure>

<h3 id="SyntaxError-语法错误"><a href="#SyntaxError-语法错误" class="headerlink" title="SyntaxError - 语法错误"></a>SyntaxError - 语法错误</h3><p><code>SyntaxError</code> 错误对象会在解析代码的过程中发生的语法错误时触发。也可以通过构造函数创建该对象的实例：</p>
<blockquote>
<p><strong>new SyntaxError([message])</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量名错误</span></span><br><span class="line"><span class="keyword">let</span> <span class="number">1</span>a</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺少括号</span></span><br><span class="line"><span class="built_in">console</span>.log <span class="string">'hello'</span>)</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected string</span></span><br></pre></td></tr></table></figure>

<p>上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出<code>SyntaxError</code>。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。 </p>
<h3 id="RangeError-范围错误"><a href="#RangeError-范围错误" class="headerlink" title="RangeError - 范围错误"></a>RangeError - 范围错误</h3><p><code>RangeError</code>错误对象会在数值变量或参数超出其有效范围时触发。也可以通过构造函数创建该对象的实例：</p>
<blockquote>
<p><strong>new RangeError([message])</strong></p>
</blockquote>
<p> 触发<code>RangeError</code>错误的情况有：对 <code>Array</code> 构造函数使用错误的长度值； 对 <code>Number</code> 对象的方法参数超出范围； 以及函数堆栈超过最大值等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 Array 构造函数使用错误的长度值</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// Uncaught RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 Number 对象的方法参数超出范围</span></span><br><span class="line"><span class="keyword">let</span> numObj = <span class="number">77.1234</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj.toExponential(<span class="number">101</span>))</span><br><span class="line"><span class="comment">// Uncaught RangeError: toExponential() argument must be between 0 and 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数堆栈超过最大值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fn()</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="comment">// RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>



<p>除了这几种常见的的错误类型之外，还有：</p>
<h3 id="URIError"><a href="#URIError" class="headerlink" title="URIError"></a>URIError</h3><p><code>URIError</code>错误会错误使用全局URI函数如 <code>encodeURI()</code>、<code>decodeURI()</code> 等时触发。也可以通过构造函数创建该对象的实例。</p>
<p>该错误类型在目前的 ECMAScript 规范中仍处于草案（Draft）阶段，<a href="https://www.ecma-international.org/ecma-262/6.0/#sec-native-error-types-used-in-this-standard-evalerror" target="_blank" rel="noopener">详情点击</a>。</p>
<h3 id="InternalError"><a href="#InternalError" class="headerlink" title="InternalError"></a>InternalError</h3><p> <code>InternalError</code> 对象表示出现在 JavaScript 引擎内部的错误。 例如： “InternalError: too much recursion”（内部错误：递归过深）。</p>
<p>该错误类型目前尚未成为规范的一部分。</p>
<h3 id="EvalError"><a href="#EvalError" class="headerlink" title="EvalError"></a>EvalError</h3><p><code>EvalError</code>对象表示全局函数<code>eval()</code>中发生的错误。</p>
<p> 该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留，<a href="https://www.ecma-international.org/ecma-262/6.0/#sec-native-error-types-used-in-this-standard-evalerror" target="_blank" rel="noopener">详情点击</a>。</p>
<hr>
<h2 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h2><p>当 JavaScript 内置错误类型不能满足需要时，还可以自定义错误。自定义错误就是继承 <code>Error</code> 对象，并对其进行一定的扩展：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.message = message || <span class="string">'Default Message'</span></span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'MyError'</span></span><br><span class="line">&#125;</span><br><span class="line">MyError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">MyError.prototype.constructor = MyError</span><br></pre></td></tr></table></figure>

<p>接着，我们就可以生成这种自定义类型的错误了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> MyError(<span class="string">'this is my customizable error'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="错误的处理"><a href="#错误的处理" class="headerlink" title="错误的处理"></a>错误的处理</h2><h3 id="抛出错误-throw-语句"><a href="#抛出错误-throw-语句" class="headerlink" title="抛出错误 - throw 语句"></a>抛出错误 - throw 语句</h3><p> 通常，可以在创建 <code>Error</code> 实例后，通过 <code>throw</code> 关键字抛出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'go wrong!'</span>)</span><br><span class="line"><span class="comment">// Error: go wrong!</span></span><br></pre></td></tr></table></figure>

<p> 实际上，<strong><code>throw</code> 可以抛出任何类型的值</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抛出一个字符串</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">'Error！'</span></span><br><span class="line"><span class="comment">// Uncaught Error！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个数值</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">42</span></span><br><span class="line"><span class="comment">// Uncaught 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个布尔值</span></span><br><span class="line"><span class="keyword">throw</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">// Uncaught true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个对象</span></span><br><span class="line"><span class="keyword">throw</span> &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Error!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught &#123;toString: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<p>对于 JavaScript 引擎来说，遇到 <code>throw</code> 语句，程序就中止了。引擎会接收到 <code>throw</code> 抛出的信息，可能是一个错误实例，也可能是其他类型的值。 </p>
<h3 id="捕获错误-try-…-catch结构"><a href="#捕获错误-try-…-catch结构" class="headerlink" title="捕获错误 - try … catch结构"></a>捕获错误 - try … catch结构</h3><p> 一旦发生错误，程序就中止执行了。 JavaScript提供了 <code>try...catch</code> 结构来捕获和处理错误， 选择是否往下执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'go wrong!'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error.message = '</span> + error.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上方代码，try 代码块中抛出错误，该错误将立即被 catch 捕获，将该错误作为参数传递给 catch，并执行 catch 中的代码。</p>
<p>也就是说，<strong>如果不确定某些代码是否会报错，就可以把它们放在 <code>try...catch</code> 代码块之中，便于进一步对错误进行处理</strong>。 <code>catch</code> 代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。 </p>
<p><code>try...catch</code> 可以嵌套使用。</p>
<h3 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h3><p>可以在 <code>try...catch</code> 结构最后添加一个 <strong><code>finally</code> 代码块，表示不管是否出现错误，都必需在最后运行的语句</strong>。</p>
<p>如下代码，就是一个使用 <code>try...catch...finally</code> 的经典场景。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openFile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		writeFile(data) <span class="comment">// 将可能出错的写入文件放入try代码块中</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">		handleError(err) <span class="comment">// 如果在写入文件过程中出现错误，将在此处理</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">		closeFile() <span class="comment">// 总是会关闭文件</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>即使在 <code>try</code> 和 <code>catch</code> 的代码块中存在 <code>return</code> 语句，<code>finally</code> 中的代码依然会执行。</strong></p>
<p>如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">still</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'result'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'FINALLY'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(still(<span class="string">'test'</span>))</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// FINALLY</span></span><br><span class="line"><span class="comment">// result</span></span><br></pre></td></tr></table></figure>

<p>从阮一峰老师的博客中可以看到： <strong>在 <code>try</code> 或 <code>catch</code> 中，<code>return</code> 语句的执行是排在 <code>finally</code> 代码之前的，只是等 <code>finally</code> 代码执行完毕后才返回</strong>。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(countUp())</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(count)</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中可以看到，<code>countUp()</code> 的返回值 <code>count</code> 先被确定为 0，但是此时并没有直接返回，而是先执行 <code>finally</code> 代码块中的内容。</p>
<p><strong><code>finall</code> 代码块中的 <code>return</code> 语句会覆盖掉在 <code>try</code> 或 <code>catch</code> 中的 <code>return</code></strong>。也就是说， <strong>如果 <code>finall</code> 代码块中存在 <code>return</code>，那么该条 <code>return</code>语句中的值将作为 <code>try...catch...finally</code> 的返回值。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'from_try'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'from_finally'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error" target="_blank" rel="noopener">MDN —— Error</a></li>
<li><a href="https://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">Standard ECMA-262 6th Edition / June 2015 ECMAScript® 2015 Language Specification</a></li>
<li><a href="https://wangdoc.com/javascript/features/error.html" target="_blank" rel="noopener">阮一峰的网络日志 —— 错误处理机制</a></li>
<li><a href="https://itbilu.com/javascript/js/V1oOv4Vv-.html" target="_blank" rel="noopener">IT笔录 —— JavaScript Error对象及错误类型</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>详解state与setState</title>
    <url>/2020/02/15/%E8%AF%A6%E8%A7%A3state%E4%B8%8EsetState/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>本文参考了一些资料，逐一通过例子对 state 和 setState() 进行梳理、总结，并在此记录。</p>
</blockquote>
<blockquote>
<p>使用过 <strong><a href="https://reactjs.org/" target="_blank" rel="noopener">react</a></strong> 的小伙伴都知道， React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。</p>
<p>而 <strong>setState()</strong> 是 react 中的一个非常重要的方法。当我们调用 setState() 的时候，react 会更新组件的状态 <strong>state</strong>，并且自动重新调用 <strong>render</strong> 方法，然后再把 render 方法所渲染的最新的内容显示到页面上。</p>
</blockquote>
<a id="more"></a>

<hr>
<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p> 一个组件的显示形态是可以由它数据状态和配置参数决定的。一个组件可以拥有自己的<strong>状态</strong>， react 的 <strong><a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">state</a></strong> 就是用来存储这种可变化的状态的。</p>
<p>以下方这个 Counter 计数器为例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击按钮 'A 测试1', count数量加1</span></span><br><span class="line">  test1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="number">3</span> &#125;)  <span class="comment">// 调用对象形式的setState()更新状态</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击按钮 'A 测试2', count数量加1</span></span><br><span class="line">  test2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;  <span class="comment">// 调用函数形式的setState()更新状态</span></span><br><span class="line">      count: state.count + <span class="number">1</span></span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()2之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击按钮 'A 测试3', 调用带回调函数的setState()</span></span><br><span class="line">  test3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(</span><br><span class="line">      state =&gt; (&#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;),</span><br><span class="line">      () =&gt; &#123;<span class="comment">// 状态数据更新且界面更新后立即执行</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'在callback中'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击按钮 'A 测试4', 调用两次参数为对象形式的setState()</span></span><br><span class="line">  test4 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()4之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击按钮 'A 测试5', 调用两次参数为函数形式的setState()</span></span><br><span class="line">  test5 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;))</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()5之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'A render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;A组件: &#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.test1&#125;&gt;A 测试1&lt;/</span>button&gt; &amp;nbsp;&amp;nbsp;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.test2&#125;&gt;A 测试<span class="number">2</span>&lt;<span class="regexp">/button&gt; &amp;nbsp;&amp;nbsp;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.test3&#125;&gt;A 测试3&lt;/</span>button&gt; &amp;nbsp;&amp;nbsp;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.test4&#125;&gt;A 测试<span class="number">4</span>&lt;<span class="regexp">/button&gt; &amp;nbsp;&amp;nbsp;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.test5&#125;&gt;A 测试5&lt;/</span>button&gt; &amp;nbsp;&amp;nbsp;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure>

<p>  上面代码是一个 <code>Counter</code> 组件，<code>count</code> 存放在的实例的 <code>state</code> 对象当中，这个对象在构造函数里面初始化。这个组件的 <code>render</code> 函数内，会根据组件的 <code>state</code> 的中的 <code>count</code> 值的变化而对应显示。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p> 当我们要改变组件的状态的时候，不能直接用 <del><code>this.state = xxx</code></del> 这种方式来修改，如果这样做 React 就没办法知道你修改了组件的状态，它也就没有办法更新页面。所以，一定要使用 React 提供的 <code>setState</code> 方法，<strong>它接受一个函数或者对象作为参数</strong>。 </p>
<p> 例如，此代码不会重新渲染组件： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.state.count = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p> 而是应该使用 <code>setState()</code>: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="setState-的基本用法"><a href="#setState-的基本用法" class="headerlink" title="setState()的基本用法"></a>setState()的基本用法</h2><p><code>setState()</code> 更新状态的两种用法</p>
<h3 id="setState-stateChange-callback-——-接收的第一个参数为对象"><a href="#setState-stateChange-callback-——-接收的第一个参数为对象" class="headerlink" title="setState(stateChange[, callback]) —— 接收的第一个参数为对象"></a>setState(stateChange[, callback]) —— 接收的第一个参数为对象</h3><ul>
<li><strong>stateChange</strong> 为一个<strong>对象</strong>， 这个对象表示该组件的新状态。但你只需要传入需要更新的部分，而不需要传入整个对象 。 <code>stateChange</code> 会将传入的对象<strong>浅层合并</strong>到新的 state 中 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line"></span><br><span class="line">test1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setState()2之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>以上方这个组件 Counter 为例，点击按钮 <kbd>A 测试1</kbd>，调用函数 test1，控制台输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; setState()之后 0</span><br><span class="line">&gt; A render() 1</span><br></pre></td></tr></table></figure>

<p>我们可以看出，这种形式的setState()是异步的。</p>
<h3 id="setState-updater-callback-——-接收的第一个参数为函数"><a href="#setState-updater-callback-——-接收的第一个参数为函数" class="headerlink" title="setState(updater[, callback]) —— 接收的第一个参数为函数"></a>setState(updater[, callback]) —— 接收的第一个参数为函数</h3><ul>
<li><strong>updater</strong> 为返回值为 <strong>stateChange对象</strong>的<strong>函数</strong>：<code>(state, props) =&gt; stateChange</code>。React 会把上一个 <code>setState</code> 的结果传入这个函数作为第一个参数， 将此次更新被应用时的 <a href="https://zh-hans.reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">props</a> 做为第二个参数 。即：<strong>updater 函数中 接收的参数 state 和 props 的值永远被保证为最新的</strong>。并且，updater 的返回值会与 state 进行<strong>浅合并</strong>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line"></span><br><span class="line">test2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      count: state.count + <span class="number">1</span></span><br><span class="line">  &#125;))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>以组件 Counter 为例，点击按钮 <kbd>A 测试2</kbd>，调用函数 test2，控制台输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; setState()2之后 0</span><br><span class="line">&gt; A render() 1</span><br></pre></td></tr></table></figure>

<p>这种形式的setState()也是异步的。</p>
<h3 id="setState-param-callback-——-带回调函数的setState"><a href="#setState-param-callback-——-带回调函数的setState" class="headerlink" title="setState(param, callback) —— 带回调函数的setState()"></a>setState(param, callback) —— 带回调函数的setState()</h3><ul>
<li><strong>callback</strong> 是可选的回调函数,  它将在 <code>setState</code> 完成合并并重新渲染组件后执行 。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line"></span><br><span class="line">test3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(</span><br><span class="line">    state =&gt; (&#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;),</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'在callback中'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>以组件 Counter 为例，点击按钮 <kbd>A 测试3</kbd>，调用函数 test3，控制台输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; A render() 1</span><br><span class="line">&gt; 在callback中 1</span><br></pre></td></tr></table></figure>

<p>此时可以获取到 <code>setState()</code> 后最新的状态数据。</p>
<p><strong>注意：</strong></p>
<p>关于 setState() 的第二个参数为可选的回调函数，React官方文档中是这样描述的： <strong>通常，我们建议使用 <code>componentDidUpdate()</code> 来代替此方式</strong>。  </p>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><blockquote>
<blockquote>
<p><strong>如果后续状态不依赖于当前状态 ===&gt; 使用对象方式</strong></p>
</blockquote>
<blockquote>
<p><strong>如果后续状态依赖于当前状态 ===&gt; 使用函数方式</strong></p>
</blockquote>
</blockquote>
<hr>
<h2 id="setState-真的是异步的吗？"><a href="#setState-真的是异步的吗？" class="headerlink" title="setState()真的是异步的吗？"></a>setState()真的是异步的吗？</h2><p>在上面的代码中，我们可以看到，在此时的场景中，对象参数形式 和 函数参数形式 的 <code>setState()</code>都是异步的。那么， <code>setState()</code> 真的是异步的吗？</p>
<h3 id="先给出结论："><a href="#先给出结论：" class="headerlink" title="先给出结论："></a>先给出结论：</h3><ul>
<li><strong>由 React 控制的事件处理过程中的 <code>setState</code> 都是异步的，如：生命周期函数、合成事件</strong>  </li>
<li><strong>由非 React 控制的事件处理过程中的 <code>setState</code> 都是同步的，如：定时器回调中、原生事件监听回调中、promise成功/失败的回调中 ……</strong></li>
</ul>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>接下来我们用几个例子验证一下：</p>
<h4 id="生命周期函数中的-setState"><a href="#生命周期函数中的-setState" class="headerlink" title="生命周期函数中的 setState()"></a>生命周期函数中的 <code>setState()</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之前'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>输出顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; render() 0</span><br><span class="line">&gt; setState()之前 0</span><br><span class="line">&gt; setState()之后 0</span><br><span class="line">&gt; render() 1</span><br></pre></td></tr></table></figure>

<p>结果显而易见，<code>setState()</code> 此时是异步执行的。</p>
<h4 id="合成事件中的-setState"><a href="#合成事件中的-setState" class="headerlink" title="合成事件中的 setState()"></a>合成事件中的 <code>setState()</code></h4><p> 首先得了解一下什么是合成事件，react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在 <code>jsx</code> 中常见的 <code>onClick</code> 、<code>onChange</code> 这些都是合成事件。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">	increment = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之前'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.increment&#125;&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>点击调用，输出顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; render() 0</span><br><span class="line">&gt; setState()之前 0</span><br><span class="line">&gt; setState()之后 0</span><br><span class="line">&gt; render() 1</span><br></pre></td></tr></table></figure>

<p><code>setState()</code> 此时也是异步执行的。</p>
<h4 id="定时器中的-setState"><a href="#定时器中的-setState" class="headerlink" title="定时器中的 setState()"></a>定时器中的 <code>setState()</code></h4><p>首先得了解一下什么是合成事件，react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在 <code>jsx</code> 中常见的 <code>onClick</code> 、<code>onChange</code> 这些都是合成事件。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">	componentDidMount() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setState()之前'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>输出顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; render() 0</span><br><span class="line">&gt; setState()之前 0</span><br><span class="line">&gt; render() 1</span><br><span class="line">&gt; setState()之后 1</span><br></pre></td></tr></table></figure>

<p>此时，<code>setState()</code> 此时是同步执行的。</p>
<p>在定时器中去 <code>setState()</code> 并不算是一个单独的场景，它是随着你外层去决定的。你可以在合成事件中使用定时器，可以在钩子函数中使用定时器 ，也可以在原生事件使用定时器，但是不管是哪个场景下，基于事件轮询机制（event loop）下， 定时器中的 <code>setState()</code> 永远是同步执行的。</p>
<h4 id="原生事件监听回调中的-setState"><a href="#原生事件监听回调中的-setState" class="headerlink" title="原生事件监听回调中的 setState()"></a>原生事件监听回调中的 <code>setState()</code></h4><p> 原生事件是指非 react 合成事件，原生自带的事件监听 <code>addEventListener</code> ，或者也可以用原生js、jq直接 <code>document.querySelector().onclick</code> 这种绑定事件的形式都属于原生事件。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  changeValue = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之前'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.changeValue)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>点击调用，输出顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; render() 0</span><br><span class="line">&gt; setState()之前 0</span><br><span class="line">&gt; render() 1</span><br><span class="line">&gt; setState()之后 1</span><br></pre></td></tr></table></figure>

<p>此时的<code>setState()</code> 此时也是同步执行的。</p>
<h4 id="promise回调中的-setState"><a href="#promise回调中的-setState" class="headerlink" title="promise回调中的 setState()"></a>promise回调中的 <code>setState()</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setState()之前'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>输出顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; render() 0</span><br><span class="line">&gt; setState()之前 0</span><br><span class="line">&gt; render() 1</span><br><span class="line">&gt; setState()之后 1</span><br></pre></td></tr></table></figure>

<p>此时的<code>setState()</code> 此时也是同步执行的。</p>
<p>这里， promise 回调中的 <code>setState()</code>，和之前所说的一样，不管是哪个场景下，promise 回调中的 <code>setState()</code> 永远是同步执行的。</p>
<h3 id="同步-异步-是由什么决定的呢？"><a href="#同步-异步-是由什么决定的呢？" class="headerlink" title="同步/异步 是由什么决定的呢？"></a>同步/异步 是由什么决定的呢？</h3><p>深入源码你会发现：<sup>引自参考文章 6</sup></p>
<blockquote>
<p>在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是<strong>由 React 控制的事件处理过程 setState 不会同步更新 this.state</strong>。  </p>
</blockquote>
<hr>
<h2 id="关于异步的setState-的批量处理"><a href="#关于异步的setState-的批量处理" class="headerlink" title="关于异步的setState()的批量处理"></a>关于异步的setState()的批量处理</h2><h3 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line"></span><br><span class="line">test4 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setState()4之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>以组件 Counter 为例，点击按钮 <kbd>A 测试4</kbd>，调用函数 test4，控制台输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; setState()4之后 0</span><br><span class="line">&gt; A render() 1</span><br></pre></td></tr></table></figure>

<p> 同一周期内会对多个 <code>setState</code> 进行批量处理。例如，如果在同一周期内多次设置 count 增加，则相当于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(</span><br><span class="line">	previousState,</span><br><span class="line">    &#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;,</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p> 后调用的 <code>setState()</code> 将覆盖同一周期内先调用 <code>setState</code> 的值，因此 count 得值仅增加一次， 如果后续状态取决于当前状态，建议使用 updater 函数的形式代替： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test5 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;))</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setState()5之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由于接收的参数 state 和 props 的值永远被保证为最新的</strong>，所以输出以下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; setState()5之后 0</span><br><span class="line">&gt; A render() 2</span><br></pre></td></tr></table></figure>



<h3 id="多次调用-如何处理"><a href="#多次调用-如何处理" class="headerlink" title="多次调用, 如何处理?"></a>多次调用, 如何处理?</h3><ul>
<li>setState({}): 合并更新一次状态, 只调用一次 <code>render()</code> 更新界面 ===&gt; <strong>状态更新和界面更新都合并了</strong>。</li>
<li>setState(fn): 更新多次状态, 但只调用一次 <code>render()</code> 更新界面 ===&gt; <strong>状态更新没有合并, 但界面更新合并了</strong>。</li>
</ul>
<h3 id="结论：-1"><a href="#结论：-1" class="headerlink" title="结论："></a>结论：</h3><p><strong>由于 React 会对同一周期内的 <code>setState()</code> 进行合并，所以， 在使用 React 的时候，并不需要担心多次进行 <code>setState</code> 会带来性能问题</strong>  </p>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>掌握 <code>setState()</code> 的基本用法，分清 <code>setState()</code> 在不同应用场景下的执行流程，注意  <code>setState()</code> 的合并处理。开发中基本不会再跳这个方法的坑了。</p>
<p> 如果哪里有说的不对的地方，欢迎指正。</p>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#setstate" target="_blank" rel="noopener">React官方文档 —— setState()</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="noopener">阮一峰的网络日志 —— React 入门实例教程</a></li>
<li><a href="http://huziketang.mangojuice.top/books/react/lesson10" target="_blank" rel="noopener">React.js 小书 —— 组件的 state 和 setState</a></li>
<li><a href="https://www.runoob.com/react/react-state.html" target="_blank" rel="noopener">菜鸟教程 —— React State(状态)</a></li>
<li><a href="https://juejin.im/post/5b45c57c51882519790c7441#heading-0" target="_blank" rel="noopener">你真的理解setState吗？</a></li>
<li><a href="https://www.zhihu.com/question/66749082/answer/246217812" target="_blank" rel="noopener">问一个react更新State的问题？ - Lucas HC的回答 - 知乎 </a></li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>Component和PureComponent</title>
    <url>/2020/02/14/Component%E5%92%8CPureComponent/</url>
    <content><![CDATA[<blockquote>
<p><code>React.PureComponent</code> 与 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent" target="_blank" rel="noopener"><code>React.Component</code></a> 很相似。两者的区别在于 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent" target="_blank" rel="noopener"><code>React.Component</code></a> 并未实现 <a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate" target="_blank" rel="noopener"><code>shouldComponentUpdate()</code></a>，而 <code>React.PureComponent</code> 中以浅层对比 prop 和 state 的方式来实现了该函数。</p>
</blockquote>
<a id="more"></a>

<h2 id="使用Component存在的问题"><a href="#使用Component存在的问题" class="headerlink" title="使用Component存在的问题"></a>使用Component存在的问题</h2><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>我们先来看看下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">class A extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m1: &#123;</span><br><span class="line">      count: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  testA &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;A render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;A组件: m1.count&#x3D;&#123;this.state.m1.count&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.testA&#125;&gt;test A&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;B m1&#x3D;&#123;this.state.m1&#125;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">class B extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m2: &#123;</span><br><span class="line">      count: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;B render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;B组件: &lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;div&gt;m2.count&#x3D;&#123;this.state.m2.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div&gt;m1.count&#x3D;&#123;this.props.m1.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;A&#x2F;&gt;, document.getElementById(&#39;example&#39;))</span><br></pre></td></tr></table></figure>

<p>上面的代码中，组件A是组件B的父组件。同时，组件A将维护的状态 <code>m1</code> 作为B组件的属性传递给他。</p>
<p>点击 <kbd>test A</kbd>，输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; A render()</span><br><span class="line">&gt; B render()</span><br></pre></td></tr></table></figure>

<p>我们会发现，此时，即使 A组件 的 <code>state</code> 没有发生变化，A组件也会重新渲染。即使 B组件 的 <code>state</code> 和 <code>props</code> 都没有发生改变，但只要 A组件 重新渲染，B组件 也会重新渲染。</p>
<p>也就是说，当前使用的继承类 <code>Component</code> 存在这两个问题：</p>
<ul>
<li><strong>当前组件 <code>setState()</code>，会重新执行 <code>render()</code>，即使 state 没有任何变化。</strong></li>
<li><strong>父组件重新 <code>render()</code>, 当前组件也会重新执行 <code>render()</code>, 即使 state 和 <code>porps</code> 没有任何变化。</strong></li>
</ul>
<p>这样，就导致了本不必要的性能浪费。  </p>
<h3 id="为什么会存在这些问题？"><a href="#为什么会存在这些问题？" class="headerlink" title="为什么会存在这些问题？"></a>为什么会存在这些问题？</h3><p>首先我们来看一下 React 的生命周期：</p>
<img src="https://i.loli.net/2020/02/19/gW8yp3ltDoIaznA.jpg" alt="React的生命周期" style="zoom:60%;" />



<center>图源来自网络</center>



<p>从这张图中可以很轻松的看到，组件运行时，无论是父组件重新 <code>render()</code>，还是子组件的 state 发生改变，都会调用 <strong><code>shouldComponentUpdate()</code></strong> 这个方法。 它<strong>接收两个参数：nextProps和nextState</strong>，分别表示新的 props 和新的 state 的值。并且，当函数返回 ture 时，组件会重新调用 <code>render()</code> 进行 update ；当函数返回 false 时，组件不会重新渲染。</p>
<p>然而，<strong>Component 类的 <code>shouldComponentUpdate()</code> 默认返回 true, 即使数据没有变化 <code>render()</code> 也会重新执行</strong>，这就导致了我们上方的问题。</p>
<hr>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="重写shouldComponentUpdate"><a href="#重写shouldComponentUpdate" class="headerlink" title="重写shouldComponentUpdate()"></a>重写shouldComponentUpdate()</h3><p>上面我们说，<code>shouldComponentUpdate()</code> 默认返回 true，所以导致了不必要的重新渲染。于是我们可以在<code>shouldComponentUpdate()</code>中加入条件判断，从而优化性能。</p>
<p>在上面的例子中，我们在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">class A extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m1: &#123;</span><br><span class="line">      count: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  testA &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  shouldComponentUpdate(nextProps, nextState)&#123;</span><br><span class="line">    return nextState.m1 &#x3D;&#x3D;&#x3D; this.state.m1 ? false : true</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;A render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;A组件: m1.count&#x3D;&#123;this.state.m1.count&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.testA&#125;&gt;test A&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;B m1&#x3D;&#123;this.state.m1&#125;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">class B extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m2: &#123;</span><br><span class="line">      count: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState)&#123;</span><br><span class="line">    return nextProps.m1 &#x3D;&#x3D;&#x3D; this.props.m1 &amp;&amp; nextState.m2 &#x3D;&#x3D;&#x3D; this.state.m2 ? false : true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;B render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;B组件: &lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;div&gt;m2.count&#x3D;&#123;this.state.m2.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div&gt;m1.count&#x3D;&#123;this.props.m1.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;A&#x2F;&gt;, document.getElementById(&#39;example&#39;))</span><br></pre></td></tr></table></figure>

<p>可是这样，又有了一个新的问题。当组件的 state 或 props 很多时，这样无疑会非常麻烦。</p>
<p>所以，我们可以使用 PureComponent 很轻松的解决。</p>
<h3 id="使用PureComponent"><a href="#使用PureComponent" class="headerlink" title="使用PureComponent"></a>使用PureComponent</h3><p> React中提供了一个 <code>PureComponent</code> 的类，当我们的组件继承于它时，组件更新时就会默认先比较新旧属性和状态，从而决定组件是否更新。</p>
<p> 不过值得注意的是，<strong><code>PureComponent</code>进行的是浅比较，所以组件状态或属性改变时，都需要返回一个新的对象或数组</strong>。</p>
<p>就像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">class A extends React.PureComponent &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m1: &#123;</span><br><span class="line">      count: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  testA &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(state &#x3D;&gt; (&#123;</span><br><span class="line">      m1: &#123;...state.m1, count: 2&#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  shouldComponentUpdate(nextProps, nextState)&#123;</span><br><span class="line">    return nextState.m1 &#x3D;&#x3D;&#x3D; this.state.m1 ? false : true</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;A render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;A组件: m1.count&#x3D;&#123;this.state.m1.count&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.testA&#125;&gt;test A&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;B m1&#x3D;&#123;this.state.m1&#125;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">class B extends React.PureComponent &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m2: &#123;</span><br><span class="line">      count: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState)&#123;</span><br><span class="line">    return nextProps.m1 &#x3D;&#x3D;&#x3D; this.props.m1 &amp;&amp; nextState.m2 &#x3D;&#x3D;&#x3D; this.state.m2 ? false : true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;B render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;B组件: &lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;div&gt;m2.count&#x3D;&#123;this.state.m2.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div&gt;m1.count&#x3D;&#123;this.props.m1.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;A&#x2F;&gt;, document.getElementById(&#39;example&#39;))</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent" target="_blank" rel="noopener">React官方文档 —— React.PureComponent</a></li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>同步回调与异步回调</title>
    <url>/2020/02/06/%E5%90%8C%E6%AD%A5%E5%9B%9E%E8%B0%83%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>对js回调函数进行归纳总结</p>
</blockquote>
<blockquote>
<p>涉及的名词：单线程、回调函数  </p>
</blockquote>
<a id="more"></a>

<hr>
<h2 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h2><h3 id="js是单线程的"><a href="#js是单线程的" class="headerlink" title="js是单线程的"></a>js是单线程的</h3><h4 id="什么是单线程？"><a href="#什么是单线程？" class="headerlink" title="什么是单线程？"></a>什么是单线程？</h4><p>所谓“单线程”，就是同一时间只能处理一个任务，如果有多个任务，就必须依次执行。只有当前一个任务执行完了，后一个任务才会执行。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">'1'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>执行上面的代码，执行顺序：</p>
<ol>
<li>页面弹窗显示<strong>1</strong>，此时控制台没有内容。</li>
<li>点击弹窗确定，控制台输出<strong>2。</strong>  </li>
</ol>
<p>即<code>console.log(&#39;2&#39;)</code>这条语句会在<code>alert(&#39;1&#39;)</code>执行结束后才开始执行</p>
<h4 id="为什么JavaScript是单线程？"><a href="#为什么JavaScript是单线程？" class="headerlink" title="为什么JavaScript是单线程？"></a>为什么JavaScript是单线程？</h4><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
<p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程。  </p>
<hr>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><h4 id="回调函数是什么？"><a href="#回调函数是什么？" class="headerlink" title="回调函数是什么？"></a>回调函数是什么？</h4><p>MDN对回调函数的定义： 被作为实参传入另一函数，并在该外部函数内被调用，用以来完成某些任务的函数，称为<strong>回调函数</strong> 。</p>
<p>想要弄清楚回调函数，首先要清楚js中的函数，JavaScript中的函数本质是一个对象，准确来说是通过<code>new Function()</code>创建的Function的实例对象。因此我们可以将函数像对象一样存保存在变量中，当然也就可以将保存在变量中的函数通过参数传递给另一个函数，这个作为参数传递的函数，就是<strong>回调函数</strong>。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">setTimeOut(fn(<span class="number">1</span>), <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>



<h4 id="为什么使用回调函数？"><a href="#为什么使用回调函数？" class="headerlink" title="为什么使用回调函数？"></a>为什么使用回调函数？</h4><p>js的单线程特性，使得所有任务需依次执行，如果前一个任务的执行需要很长时间，那么整个程序的执行时间就都会被拉长。</p>
<p> 为了解决这个问题，Javascript语言将任务的执行模式分成两种：<u>同步（Synchronous）</u>和<u>异步（Asynchronous）</u> 。</p>
<p><strong>同步任务</strong>指的是需要在主线程上排队依次执行的任务，前一个任务结束，才会执行后一个任务。 任务执行的顺序与代码排列的顺序是一致的、同步的，同步任务会导致阻塞；<strong>异步任务</strong>指的是不会阻塞主线程上的下一个同步任务，而是会进入的回调队列（callback queue）的任务。</p>
<p>而回调函数，正是实现异步编程的方法之一。  </p>
<hr>
<h2 id="同步回调与异步回调"><a href="#同步回调与异步回调" class="headerlink" title="同步回调与异步回调"></a>同步回调与异步回调</h2><p>回调函数不等于异步， 同步(阻塞)的场景下也经常用到回调</p>
<h3 id="同步回调"><a href="#同步回调" class="headerlink" title="同步回调"></a>同步回调</h3><p>立即执行，完全执行完了才会执行下一个任务，不会放入回调队列中</p>
<p>如：数组遍历相关的回调函数 / Promise的excutor函数</p>
<p><strong>例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'遍历的回调'</span>, item, index)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'forEach()之后'</span>)</span><br></pre></td></tr></table></figure>

<p>数组的forEach()方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历的回调, 1, 0</span></span><br><span class="line"><span class="comment">// 遍历的回调, 2, 1</span></span><br><span class="line"><span class="comment">// 遍历的回调, 3, 2</span></span><br><span class="line"><span class="comment">// forEach()之后</span></span><br></pre></td></tr></table></figure>

<p>执行结果  </p>
<h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><p>不会立即执行, 会放入回调队列中将来执行</p>
<p>如：定时器回调 / ajax回调 / 事件监听回调/ Promise的成功和失败的回调</p>
<p><strong>例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'回调函数'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'setTimeout()之后'</span>)</span><br></pre></td></tr></table></figure>

<p>定时器回调</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setTimeout()之后</span></span><br><span class="line"><span class="comment">// 回调函数</span></span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></li>
<li><a href="[http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html](http://www.ruanyifeng.com/blog/2012/12/asynchronous＿javascript.html)">Javascript异步编程的4种方法</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>回调函数</tag>
      </tags>
  </entry>
</search>
