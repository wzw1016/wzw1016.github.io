<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>自定义实现vue-router</title>
    <url>/2020/12/26/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0vue-router/</url>
    <content><![CDATA[<p>本文主要记录内容如下：</p>
<ul>
<li>vue router 基础语法</li>
<li>Hash 模式和 History 模式</li>
<li>模拟实现 vue router</li>
</ul>
<a id="more"></a>

<h2 id="Vue-Router-基础"><a href="#Vue-Router-基础" class="headerlink" title="Vue Router 基础"></a>Vue Router 基础</h2><h3 id="使用-vue-router-的基本结构"><a href="#使用-vue-router-的基本结构" class="headerlink" title="使用 vue router 的基本结构"></a>使用 vue router 的基本结构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> VueRouter(&#123; routes  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123; router &#125;)</span><br><span class="line"></span><br><span class="line">router-link</span><br><span class="line"></span><br><span class="line">router-view</span><br></pre></td></tr></table></figure>



<p>创建 Vue 实例时配置的 router 选项，会向 Vue 实例注入 <strong>$route</strong> （路由规则，包含路由信息）和 <strong>$router</strong> （VueRouter 实例对象，包含路由相关的方法，如 push、back、go 等）两个属性。</p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  ...</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/detail/:id'</span>,</span><br><span class="line">    name: <span class="string">'Detail'</span>,</span><br><span class="line">    <span class="comment">// 开启 props，会把 URL 中的参数传递给组件，在组件中通过 props 来接收 URL 参数</span></span><br><span class="line">    props: <span class="literal">true</span>,</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'detail' */</span><span class="string">'../views/Detail.vue'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>通过占位匹配变化的位置</p>
<p>在 Detail.vue 中获取 id</p>
<ul>
<li><p>通过当前路由规则，获取数据 </p>
<p>不推荐，强依赖于路由</p>
</li>
<li><p>在定义 routes 路由规则时开启 props 获取 </p>
<p>相当于父子组件通过 props 传值，实现解耦。组件可以不依赖于路由，在任意位置使用</p>
</li>
</ul>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><img src="C:\Users\Vincent\OneDrive\course\img\VueJS\nested vue router.png" alt="nested vue router.drawio" style="zoom: 80%;" />

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/login'</span>,</span><br><span class="line">    component: Login,</span><br><span class="line">    name: Login,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    component: Layout,</span><br><span class="line">    name: Layout,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">''</span>,</span><br><span class="line">        component: Index,</span><br><span class="line">        name: Index,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'detail/:id'</span>,</span><br><span class="line">        name: <span class="string">'Detail'</span>,</span><br><span class="line">        props: <span class="literal">true</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'detail' */</span><span class="string">'../views/Detail.vue'</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>提取公共内容</p>
<h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><p>push / replace  / go / back</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$router.push(<span class="string">'/'</span>)</span><br><span class="line">$router.push(&#123; <span class="attr">name</span>: <span class="string">'Index'</span> &#125;)</span><br></pre></td></tr></table></figure>



<h2 id="Hash-模式和-History-模式"><a href="#Hash-模式和-History-模式" class="headerlink" title="Hash 模式和 History 模式"></a>Hash 模式和 History 模式</h2><p>客户端路由的实现方式（前端路由）</p>
<h3 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h3><p>例：<a href="http://music.163.com/#/playlist?id=3102961863" target="_blank" rel="noopener">http://music.163.com/#/playlist?id=3102961863</a></p>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>基于锚点，以及 onhashchange 事件（通过锚点的值作为路由地址，地址发生变化时，触发 onhashchange 事件，根据路径绝决定页面呈现内容）</p>
<h3 id="History-模式（-gt-IE10-）"><a href="#History-模式（-gt-IE10-）" class="headerlink" title="History 模式（ &gt;= IE10 ）"></a>History 模式（ &gt;= IE10 ）</h3><p>例：<a href="http://music.163.com/playlist/3102961863" target="_blank" rel="noopener">http://music.163.com/playlist/3102961863</a></p>
<h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h4><p>基于 HTML5 中的 history API</p>
<ul>
<li><p>history.pushState()    IE10 &gt;= 10</p>
</li>
<li><p>history.replaceState()</p>
<p>(调用 history.push，路径发生变化，会向服务器发送请求；而调用 history.pushState，不会向服务器发送请求，只会改变地址栏中地址)</p>
</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li>需要服务器支持</li>
<li>单页面应用中，只存在一个页面 index.html。假如当路径为 <a href="http://www.testurl.com/login" target="_blank" rel="noopener">http://www.testurl.com/login</a> 时，刷新浏览器，会向服务器发送请求，请求 login.html 页面，而服务端不存在这样的页面，会返回找不到该页面（404）</li>
<li>在服务端，除了静态资源外，应该都返回单页应用的 index.html</li>
</ul>
<p>（vue-cli 内置的开发服务器，默认实现了对 history 模式的支持，404 问题在上线后出现）</p>
<h4 id="在-node-服务器"><a href="#在-node-服务器" class="headerlink" title="在 node 服务器"></a>在 node 服务器</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> history = requie(<span class="string">'connect-history-api-fallback'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(history) <span class="comment">// 注册处理 history 模式的中间件</span></span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">'../web'</span>))) <span class="comment">// express 内置中间件，暴露静态资源</span></span><br><span class="line"></span><br><span class="line">app.listen(<span class="string">'3000'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'服务器已开启，端口：3000'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





<h4 id="在-nginx-服务器"><a href="#在-nginx-服务器" class="headerlink" title="在 nginx 服务器"></a>在 nginx 服务器</h4><ul>
<li><p>官网下载 nginx 压缩包</p>
</li>
<li><p>解压到 c 盘根目录，例：c:\nginx-1.18.0（路径不能有中文）</p>
</li>
<li><p>命令行切换到目录 c:\nginx-1.18.0，启动 nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动（默认 80 端口，为 http 默认端口）</span><br><span class="line">start nginx</span><br><span class="line"># 重启</span><br><span class="line">nginx -s reload</span><br><span class="line"># 停止</span><br><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure>
</li>
<li><p>将打包好的前端项目复制到 c:\nginx-1.18.0\html 文件夹下</p>
</li>
<li><p>修改 nginx 配置文件</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">      			<span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>http server location 下新增：<code>try_files $uri $uri/ /index.html;</code></p>
<h2 id="模拟实现-Vue-router"><a href="#模拟实现-Vue-router" class="headerlink" title="模拟实现 Vue router"></a>模拟实现 Vue router</h2><p><strong>前置知识</strong></p>
<ul>
<li>插件</li>
<li>混入</li>
<li>Vue.observable()</li>
<li>插槽</li>
<li>render 函数</li>
<li>运行时和完整版的 Vue</li>
</ul>
<h3 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul>
<li>URL 中 # 后面的内容作为路径地址</li>
<li>监听 hashchange 事件</li>
<li>根据当前路由地址找到对应组件重新渲染</li>
</ul>
<p>（可以直接通过 location.url 切换浏览器中的地址，如果只改变了 # 后面的内容，浏览器不会向服务器请求该地址，但会记录到浏览器的历史记录中。hash 改变时触发所监听的  hashchange 事件， 在 hashchange 事件中，根据当前路由地址找到对应组件重新渲染）</p>
<p>…</p>
<h3 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h3><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><ul>
<li>通过调用 history.pushState() 方法改变地址栏（只改变地址，记录到历史，不发送请求）</li>
<li>监听 popstate 事件</li>
<li>根据当前路由地址找到对应组件重新渲染</li>
</ul>
<p>（history.pushState 或 history.replaceState 并不会触发 popstate 事件；当调用 history.back 和 history.forwad，或点击浏览器前进或后退按钮时，才会触发 popstate 事件）</p>
<h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router/index.js</span></span><br><span class="line"><span class="comment">// 注册插件</span></span><br><span class="line">Vue.use(Vueouter)</span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'home'</span>, <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: HomeComponent &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.use(Vueouter)</span><br></pre></td></tr></table></figure>

<p>安装 Vue.js 插件</p>
<ul>
<li>如果插件是一个对象，必须提供 <code>install</code> 方法。</li>
<li>如果插件是一个函数，它会被作为 install 方法。</li>
</ul>
<p>install 方法调用时，会传入两个参数：Vue 构造函数、选项对象（可选）。</p>
<p>该方法需要在调用 <code>new Vue()</code> 之前被调用。</p>
<p>当 install 方法被同一个插件多次调用，插件将只会被安装一次。</p>
<p>VueRouter：有一个静态 install 方法的类</p>
<img src="C:\Users\Vincent\OneDrive\course\img\VueJS\VueRouter class.png" alt="VueRouter class" style="zoom: 67%;" />





<h4 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h4><ul>
<li><strong>install(Vue)</strong></li>
</ul>
<ol>
<li>判断当前插件是否已经被安装</li>
<li>将 Vue 构造函数记录到全局变量（供 VueRouter 的一些实例方法使用，如创建 router-link 和 router-view 组件时，需调用 Vue.component 创建）</li>
<li>将创建 Vue 实例时传入的 router 对象注入到所有 Vue 实例对象上</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _Vue = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> install(Vue, options) &#123;</span><br><span class="line">    <span class="comment">// 1. 判断当前插件是否已经被安装</span></span><br><span class="line">    <span class="keyword">if</span>(VueRouter.install.installed) <span class="keyword">return</span></span><br><span class="line">    VueRouter.install.installed = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 将 Vue 构造函数记录到全局变量</span></span><br><span class="line">    _Vue = Vue</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 将创建 Vue 实例时传入的 router 对象注入到所有 Vue 实例对象上</span></span><br><span class="line">    <span class="comment">// 使用 mixin，确保可以获取到 Vue 实例，得到创建 Vue 实例时传入的 router 对象(在beforeCreate 中可以获取到 Vue 实例)</span></span><br><span class="line">    _Vue.mixin(&#123;</span><br><span class="line">      beforeCreate() &#123;</span><br><span class="line">        <span class="comment">// Vue.mixin 会全局注册混入，影响注册之后所有创建的每个 Vue 实例</span></span><br><span class="line">        <span class="comment">// 需保证在组件中不会执行全局混入的 beforeCreate。只需要在 new Vue() 时执行一次 $router 的挂载</span></span><br><span class="line">        <span class="comment">// 靠组件中不会存在 router 选项判断</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.$options.router) &#123;</span><br><span class="line">          _Vue.prototype.$router = <span class="keyword">this</span>.$options.router</span><br><span class="line">          <span class="comment">// 初始化 VueRouter </span></span><br><span class="line">          <span class="keyword">this</span>.$router.init()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>constructor(options)</strong></li>
</ul>
<ol>
<li><p>options: 用于记录 VueRouter 构造函数传入的选项</p>
</li>
<li><p>routeMap: 存储解析 options.routes(路由规则) 后的信息。</p>
<p>key 为路由地址，value 为组件。</p>
<p>router-view 组件会根据路由地址，在 routeMap 中匹配对应的组件渲染</p>
</li>
<li><p>data 为响应式对象(使用 Vue.observable 创建响应式对象，*<em>创建的响应式对象可直接用在渲染函数 render *</em>或计算属性中，并且会在发生变更时触发相应的更新)。</p>
<p>包含一个记录当前路由地址的属性 current(默认为 ‘/‘)，</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">  <span class="keyword">this</span>.options = options</span><br><span class="line">  <span class="keyword">this</span>.routeMap = &#123;&#125; </span><br><span class="line">  <span class="keyword">this</span>.data = _Vue.observable(&#123;</span><br><span class="line">    current: <span class="string">'/'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>createRouteMap()</strong></p>
<p>遍历传入的 routes(路由规则)，转换成键值对的形式，存储到 routeMap 中</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">createRouteMap() &#123;</span><br><span class="line">  <span class="keyword">this</span>.options.routes.forEach(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.routeMap[route.path] = route.component</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>initComponents()</strong></p>
<ul>
<li><p><strong>创建 router-link</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尽管 _Vue 中保存着 Vue 对象，但还是在此传入 Vue 对象的目的：减少方法对外部的依赖</span></span><br><span class="line">initComponents(Vue) &#123;</span><br><span class="line">  Vue.component(<span class="string">'router-link'</span>, &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      to: <span class="built_in">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">'&lt;a :href="to"&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/a&gt;'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会报出错误：<code>[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.</code></p>
<p>是因为 vue-cli 默认使用的是不包含编译器的<strong>运行时版本</strong>。两种解决方法：</p>
<ul>
<li><p><strong>1. 使用完整版本</strong></p>
<p>可以在 vue.config.js 中修改 runtimeCompiler 进行配置，从而使用包含编译器的完整版，便可使用 template 选项，但大 10K 左右</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  runtimeCompiler: <span class="literal">true</span>, <span class="comment">// default: false</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>* **2. 使用 render() 函数**

  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">initComponents(Vue) &#123;</span><br><span class="line">  Vue.component(<span class="string">'router-link'</span>, &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      to: <span class="built_in">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="keyword">return</span> h(<span class="string">'a'</span>, &#123; <span class="comment">// 返回 h 创建的虚拟 dom</span></span><br><span class="line">        attrs: &#123; <span class="comment">// attrs 可以为创建的元素生成对应的属性</span></span><br><span class="line">          href: <span class="keyword">this</span>.to <span class="comment">// 设置 href 为 props.to(当前超链接跳转的地址)</span></span><br><span class="line">        &#125;,</span><br><span class="line">        on: &#123; <span class="comment">// on 可以为创建的元素生成对应的事件监听器</span></span><br><span class="line">          click: <span class="keyword">this</span>.clickHandler</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, [ <span class="keyword">this</span>.$slots.default ]) <span class="comment">// 获取默认插槽</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      clickHandler(e) &#123;</span><br><span class="line">        <span class="comment">// 将当前的路径，记录到 data.current 中。以用来加载对应的组件</span></span><br><span class="line">        <span class="comment">// 此处 this 为 router-link 组件对象(同时为 Vue 实例对象)，在 install 方法中已经为每个 Vue 实例对象挂在了 $router 属性</span></span><br><span class="line">        <span class="keyword">this</span>.$router.data.current = <span class="keyword">this</span>.to</span><br><span class="line">        <span class="comment">// 改变浏览器的地址栏</span></span><br><span class="line">        history.pushState(&#123;&#125;, <span class="string">''</span>, <span class="keyword">this</span>.to)</span><br><span class="line">        <span class="comment">// 阻止 a 标签的默认行为(默认会跳转，刷新浏览器)</span></span><br><span class="line">        e.preventDefault()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  render 函数会自动传入一个函数参数 createElement（此处定义为 h，该函数用来创建虚拟 dom）；

  h 函数接收三个参数：元素选择器（String）、创建元素的属性（Object）、创建元素的子元素（Array）



  history.pushState(data: any, title: string, url?: string) 接收三个参数：触发 popState 时向其传入的事件对象、网页标题、地址</code></pre><ul>
<li><p><strong>创建 router-view</strong></p>
<p>router-view 相当于一个占位符，需根据当前路由地址，获取到对应的路由组件，并渲染到 router-view 对应的位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">initComponents(Vue) &#123;</span><br><span class="line">  Vue.component(<span class="string">'router-link'</span>, ...)</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">  Vue.component(<span class="string">'router-view'</span>, &#123;</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="comment">// 获取到当前路由地址对应的路由组件</span></span><br><span class="line">      <span class="keyword">const</span> component = self.routeMap[self.data.current] </span><br><span class="line">      <span class="keyword">return</span> h(component)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>initEvent()</strong></p>
<p>注册 popState 事件（解决在点击浏览器前进或后退按钮时的bug：地址栏发生变化，但没有加载对应的组件）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">initEvent() &#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'popState'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.data.current = <span class="built_in">window</span>.location.pathname</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>init()</strong></p>
<p>包装初始化方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">init() &#123;</span><br><span class="line">  <span class="keyword">this</span>.createRouteMap()</span><br><span class="line">  <span class="keyword">this</span>.initComponents(_Vue)</span><br><span class="line">  <span class="keyword">this</span>.initEvent()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程化之四：模块化打包工具</title>
    <url>/2020/11/20/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B9%8B%E5%9B%9B%EF%BC%9A%E6%A8%A1%E5%9D%97%E5%8C%96%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="1-使用模块打包工具的原因"><a href="#1-使用模块打包工具的原因" class="headerlink" title="1. 使用模块打包工具的原因"></a>1. 使用模块打包工具的原因</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>ES Modules 存在环境兼容性问题</li>
<li>模块文件过多，网络请求频繁</li>
<li>所有的前端资源都需要模块化</li>
</ol>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ol>
<li><p>新特性编译，解决兼容性</p>
</li>
<li><p>将模块文件打包，以减少生产环境的请求次数</p>
<p>(HTTP 1.1 版本的缺陷，如：同域并行请求限制、请求延迟、请求的 Header 浪费带宽流量)</p>
</li>
<li><p>支持不同种类的前端资源类型（js、css、scss、hbs、png、ts、font）</p>
</li>
</ol>
<p>需求1与2可通过构建系统配合编译工具实现，而需求3难以实现</p>
<a id="more"></a>

<h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2. 概述"></a>2. 概述</h2><p>Webpack、Parcel、Rollup 等</p>
<p>主要功能：</p>
<ul>
<li>模块打包器（Module Bundler）</li>
<li>模块加载器（Loader）</li>
<li>代码拆分（Code Splitting）</li>
<li>资源模块（Asset Module）</li>
</ul>
<p><strong>打包工具解决的是前端整体的模块化，并不单指 Javascript 模块化</strong></p>
<h2 id="3-Webpack"><a href="#3-Webpack" class="headerlink" title="3. Webpack"></a>3. Webpack</h2><ul>
<li>Webpack 只是打包工具（默认只会处理 import 和 export）</li>
<li>可以使用加载器（loader）进行代码的编译转换</li>
</ul>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add webpack webpack-cli --dev</span><br></pre></td></tr></table></figure>



<h3 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h3><p><code>webpack.config.js</code> </p>
<p>运行在 node 环境，使用 CommonJS 规范</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>, <span class="comment">// 入口文件，相对路径不可省略 ./</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path：path.join(__dirname, <span class="string">'output'</span>), <span class="comment">// 必须为绝对路径, 默认在项目根目录下的 dist 文件夹</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-工作模式"><a href="#2-工作模式" class="headerlink" title="2. 工作模式"></a>2. 工作模式</h3><p>可通过 cli 命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack --mode development</span><br></pre></td></tr></table></figure>

<p>默认为 production，会启动一些插件进行代码优化</p>
<p>development，优化打包速度，添加调试辅助</p>
<p>none，默认打包，不做处理</p>
<p>或</p>
<p>webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-打包结果运行原理"><a href="#3-打包结果运行原理" class="headerlink" title="3. 打包结果运行原理"></a>3. 打包结果运行原理</h3><p>mode 设置为 none 后运行 webapck，打包后的文件可以清晰看到 webpack 的运行过程（webpackBootstrap函数）</p>
<h3 id="4-资源模块加载"><a href="#4-资源模块加载" class="headerlink" title="4. 资源模块加载"></a>4. 资源模块加载</h3><p>js files =&gt; bundle.js（by default loader）</p>
<p>other files =&gt; bundle.js（by other loader）</p>
<p> <strong>Loader 是 Webpack 实现前端模块化的核心，通过不同的 Loader 可以加载任何类型的资源文件</strong></p>
<p>使用示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>根据代码的需要动态引入资源</strong></p>
<p>需要资源的不是应用，而是代码</p>
<p>JavaScript 驱动整个前端应用，在 js 中引入资源文件：</p>
<ul>
<li>逻辑合理，JS 确实需要这些资源文件</li>
<li>保证上线资源不确实，都是必要的</li>
</ul>
<h3 id="5-常用-loader"><a href="#5-常用-loader" class="headerlink" title="5. 常用 loader"></a>5. 常用 loader</h3><ul>
<li>编译转换类（convert to JavaScript module（bundle.js））<ul>
<li>css-loader</li>
<li>babel-loader</li>
<li>…</li>
</ul>
</li>
<li>文件操作类（将加载到的资源拷贝到输出目录，在 bundle.js 中的模块中输出对应的访问路径）<ul>
<li>file-loader</li>
<li>…</li>
</ul>
</li>
<li>代码检查类（对代码语法、风格进行检查，保证生产质量）<ul>
<li>eslint-loader</li>
<li>…</li>
</ul>
</li>
</ul>
<h3 id="6-webpack-加载资源的方式（尽量较少混用）"><a href="#6-webpack-加载资源的方式（尽量较少混用）" class="headerlink" title="6. webpack 加载资源的方式（尽量较少混用）"></a>6. webpack 加载资源的方式（尽量较少混用）</h3><ol>
<li><p>遵循 ESM 标准的 import 声明</p>
</li>
<li><p>遵循 CMJ 标准的 require 函数</p>
<p>注意：当使用 require 函数导入 ESM 模块时，对于 ESM 的默认导出，需使用 require 函数返回值的 default 属性获取模块。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createHeader = <span class="built_in">require</span>(<span class="string">'./createHeader'</span>).default</span><br></pre></td></tr></table></figure>
</li>
<li><p>遵循 AMD 标准的 define 函数和 require 函数</p>
</li>
</ol>
<ol start="4">
<li><p>Loader 加载的非 JavaScript 也会触发资源加载</p>
<p>如：</p>
<ul>
<li>样式文件中的 @import 指令和 url 函数</li>
<li>HTML 文件中图片标签的 src 属性</li>
<li>…</li>
</ul>
</li>
</ol>
<h3 id="7-webpack-核心工作原理"><a href="#7-webpack-核心工作原理" class="headerlink" title="7. webpack 核心工作原理"></a>7. webpack 核心工作原理</h3><p>Webpack 会根据配置，从入口文件开始，找到 import 或 require 之类加载文件或资源的语句，解析对应的资源模块，并解析每一个资源模块对应的依赖。构建出项目中文件（模块）之间依赖关系的依赖树。</p>
<p>随后递归此依赖树，找到依赖树中每个节点所加载的的资源文件，根据配置文件中的 rules 属性，使用指定的的加载器（loader）加载该模块。</p>
<p>最后将 loader 加载后的结果放入打包后的结果（bundle.js）中，从而实现整个项目的打包。</p>
<h3 id="8-自定义-loader"><a href="#8-自定义-loader" class="headerlink" title="8. 自定义 loader"></a>8. 自定义 loader</h3><ul>
<li><strong>source</strong> 为接收文件内容</li>
<li>无论使用了几个 loader 处理资源，最终 loader 导出函数的返回值必须为 js 代码（因为 webpack 会在打包后的文件（bundle.js）中对其进行简单的字符串拼接）</li>
</ul>
<p><strong>例：markdown-loader</strong></p>
<p>方式一：</p>
<p>markdown-loader.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> marked = <span class="built_in">require</span>(<span class="string">'marked'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">source</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> html = marked(source)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`export default <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(html)&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.md$/</span>,</span><br><span class="line">        use: <span class="string">'./markdown-loader'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>方式二：</p>
<p>markdown-loader.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> marked = <span class="built_in">require</span>(<span class="string">'marked'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">source</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> html = marked(source)</span><br><span class="line">  <span class="keyword">return</span> html</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.md$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'html-loader'</span>,</span><br><span class="line">          <span class="string">'./markdown-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似处理的管道：file=====&gt; 由 markdown-loader 处理 ==&gt; 由 html-loader 处理  =====&gt; 最终输出到 bundle.js</p>
<h3 id="9-插件（plugin）"><a href="#9-插件（plugin）" class="headerlink" title="9. 插件（plugin）"></a>9. 插件（plugin）</h3><p>使用插件的目的：<strong>为了增强 webpack 的自动化能力</strong></p>
<p>如：</p>
<ul>
<li>清除 dist 目录</li>
<li>拷贝静态文件</li>
<li>压缩输出代码</li>
<li>…</li>
</ul>
<p>webpack + <strong>plugin</strong> 的确实现了大多数的前端工程化</p>
<h3 id="10-常用插件"><a href="#10-常用插件" class="headerlink" title="10. 常用插件"></a>10. 常用插件</h3><ul>
<li>clean-webpack-plugin（清除 dist ）</li>
<li>html-webpack-plugin（自动生成 bundle.js 的 HTML，通过 webpack 输出 HTML，自动引用 bundle.js )</li>
<li>copy-webpack-plugin（复制静态文件）</li>
<li>mini-css-extract-plugin（将 css 代码从打包结果中提取出来，从而可以实现 css 的按需加载）<ul>
<li>若 css 样式体积并不是很大，为了减少网络请求，则无需使用该插件提取为单独文件（150kb以下）</li>
</ul>
</li>
<li>optimize-css-assets-webpack-plugin（压缩样式文件）<ul>
<li>webpack 建议将压缩类的插件添加到 optimization 中的 minimizer 属性数组中（若配置在 plugins 数组中，则该插件任何情况下都会工作，而配置在 minimizer 数组中只会在 minimize 特性开启时才会工作。production 模式下 minimize 默认会自动开启）</li>
<li>webpack 生产模式下内置的压缩器只支持 js 文件的压缩</li>
</ul>
</li>
<li>terser-webpack-plugin (webpack 内置 js 压缩文件)<ul>
<li>在自定义 optimization.minimizer 时，webpack 内置的压缩器插件将会被自定义的optimization.minimizer 覆盖，所以需要在 optimization.minimizer 中手动重新添加该插件。</li>
</ul>
</li>
</ul>
<p>使用示例： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpakPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsWebpackPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> terserWebpackPlugin = reuqire(<span class="string">'terser-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="keyword">new</span> terserWebpackPlugin(),</span><br><span class="line">      <span class="keyword">new</span> OptimizeCssAssetsWebpackPlugin(),</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  pulgins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpakPlugin(&#123; <span class="comment">// 若HTML需大量定制，可以使用模板</span></span><br><span class="line">      title: <span class="string">'webpack plugin sample'</span> <span class="comment">// 生成HTML的titlt</span></span><br><span class="line">      meta: &#123; <span class="comment">// 生成HTML的meta</span></span><br><span class="line">        viewport: <span class="string">'width=device-width'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name].bundle.css'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绝大多数 plugin 模块导出的都是一个类型。</p>
<h3 id="11-自定义-plugin"><a href="#11-自定义-plugin" class="headerlink" title="11. 自定义 plugin"></a>11. 自定义 plugin</h3><p><strong>plugin 通过钩子（Hooks）机制实现</strong>（在 webpack 不同的生命周期钩子上挂载不同的任务）</p>
<ul>
<li>plugin 必须为一个函数或者是一个包含 apply 方法的对象</li>
</ul>
<p>示例：去除打包后的文件 bundle.js 中注释的插件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.hooks.emit.tap(<span class="string">'MyPlugin'</span>, compilation =&gt; &#123; <span class="comment">// emit 为 webpack 钩子</span></span><br><span class="line">      <span class="comment">// compilation 此次打包的上下文</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">const</span> name <span class="keyword">in</span> compilation.assets) &#123;</span><br><span class="line">        <span class="keyword">if</span>(name.endWidth(<span class="string">'.js'</span>)) &#123;</span><br><span class="line">          <span class="keyword">const</span> contents = compilation.assets[name].source()</span><br><span class="line">          <span class="keyword">const</span> withoutComments = contents.replace(<span class="regexp">/\/\*\*+\*\//g</span>, <span class="string">''</span>)</span><br><span class="line">          compilation.assets[name] = &#123;</span><br><span class="line">            source: <span class="function"><span class="params">()</span> =&gt;</span> withoutComments,</span><br><span class="line">            size: <span class="function"><span class="params">()</span> =&gt;</span> withoutComments.length</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   ...</span><br><span class="line">   plugins: [</span><br><span class="line">     <span class="keyword">new</span> MyPlugin()</span><br><span class="line">   ]</span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="12-增强开发体验"><a href="#12-增强开发体验" class="headerlink" title="12. 增强开发体验"></a>12. 增强开发体验</h3><p><strong>目标：</strong></p>
<ol>
<li>以 HTTP server 运行（更加接近生产环境，并且文件方式打开 ajax 请求不能发送 ）</li>
<li>自动编译、自动刷新</li>
<li>source Map</li>
</ol>
<p><strong>方案一</strong></p>
<p>实现自动编译</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">webpack --watch</span><br></pre></td></tr></table></figure>

<p>实现自动刷新</p>
<p>使用 browser-sync 模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add browser-sync</span><br><span class="line"></span><br><span class="line">browser-sync dist --file &quot;**&#x2F;*&quot;</span><br></pre></td></tr></table></figure>

<p>弊端：较为麻烦、频繁磁盘读写</p>
<h4 id="Webpack-dev-server"><a href="#Webpack-dev-server" class="headerlink" title="Webpack dev server"></a>Webpack dev server</h4><ul>
<li>提供 HTTP server </li>
<li>集成 自动编译、自动刷新 等功能</li>
</ul>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add webpack-dev-server --dev</span><br><span class="line"></span><br><span class="line">yarn webpack-dev-server</span><br><span class="line">yarn webpack-dev-server --open &#x2F;&#x2F; 自动打开浏览器</span><br></pre></td></tr></table></figure>

<p>将打包后的文件放在内存中，减少了磁盘读写，提高开发效率 </p>
<p>配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./public'</span>, <span class="comment">// 访问静态资源路径</span></span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123;</span><br><span class="line">        <span class="comment">// http://localhost:8080/api/users =&gt; https://api.github.com/api/users</span></span><br><span class="line">        target: <span class="string">'https://api.github.com'</span>,</span><br><span class="line">        <span class="comment">// http://localhost:8080/api/users =&gt; https://api.github.com/users</span></span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 不使用 localhost:8080 作为请求 Github 的主机名</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>webpack-cli 4版本后：webpack serve</p>
<h4 id="Source-Map"><a href="#Source-Map" class="headerlink" title="Source Map"></a>Source Map</h4><p>问题：经过编译后的运行代码，难以调试，故障排查苦难。</p>
<p><strong>映射源代码与转换之后代码之间的关系</strong></p>
<p>解决了源代码与运行代码不一致产生的问题</p>
<h4 id="Webpack-多任务"><a href="#Webpack-多任务" class="headerlink" title="Webpack 多任务"></a>Webpack 多任务</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  &#123;</span><br><span class="line">    entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">'a.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">'a.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>会分别执行 module.exports 导出数组中的每个任务。</p>
<h4 id="Webpack-Source-Map-配置"><a href="#Webpack-Source-Map-配置" class="headerlink" title="Webpack Source Map 配置"></a>Webpack Source Map 配置</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  devtool: <span class="string">'source-map'</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="devtool-模式"><a href="#devtool-模式" class="headerlink" title="devtool 模式"></a>devtool 模式</h4><p>devtool 的多种模式（<a href="https://webpack.js.org/configuration/devtool/#devtool）" target="_blank" rel="noopener">https://webpack.js.org/configuration/devtool/#devtool）</a></p>
<p><strong>各标识含义</strong></p>
<ul>
<li><strong>eval</strong>：是否使用 eval() 执行模块代码 </li>
<li><strong>cheap</strong>：source map 是否包含列信息（cheap 只包含行信息，不包含列）</li>
<li><strong>module</strong>：是否能够得到 loader 处理之前的源代码</li>
</ul>
<ol>
<li>eval：不生成 source map 文件，通过在 eval 函数的字符串参数最后添加 sourceUrl=./foo/bar.js 这种方式，标注模块文件的路径</li>
<li>eval-source-map：生成 source map 文件，可以定位到文件、行、列信息 </li>
<li>cheap-eval-source-map：与 eval-source-map 相比，无列信息，为 loader 处理后的代码</li>
<li>cheap-module-eval-source-map：与 cheap-eval-source-map 相比，可以得到未经 loader 处理的源代码</li>
<li>cheap-source-map：未使用 eval() 执行模块代码，得到 loader 处理后的代码</li>
<li>inline-source-map：将 source-map 在代码中以data url 方式嵌入（不推荐使用，增大代码体积）</li>
<li>hidden-source-map：生成，但不引入 source-map 文件（开发第三方包）</li>
<li>nosources-source-map：提供文件、行、列信息，但无源代码（生产环境保护源代码）</li>
</ol>
<h4 id="选择-webpack-的-source-map-模式"><a href="#选择-webpack-的-source-map-模式" class="headerlink" title="选择 webpack 的 source map 模式"></a>选择 webpack 的 source map 模式</h4><ul>
<li><p>开发环境：cheap-module-eval-source-map</p>
</li>
<li><p>生产环境：none / nosources-source-map</p>
</li>
</ul>
<p>具体以实际业务需求为准</p>
<h4 id="dev-server-自动刷新的问题"><a href="#dev-server-自动刷新的问题" class="headerlink" title="dev server 自动刷新的问题"></a>dev server 自动刷新的问题</h4><p>问题核心：<strong>自动刷新导致的页面状态丢失</strong></p>
<p>需求：页面不刷新的前提下，及时更新所修改的模块</p>
<p>解决办法：</p>
<ol>
<li>在编辑器中写死状态或内容</li>
<li>额外代码实现刷新前保存、刷新后读取（如存入 localStorage 中）</li>
<li><strong>HMR</strong></li>
</ol>
<h4 id="HMR（Hot-Module-Replacement-模块热替换）"><a href="#HMR（Hot-Module-Replacement-模块热替换）" class="headerlink" title="HMR（Hot Module Replacement 模块热替换）"></a>HMR（Hot Module Replacement 模块热替换）</h4><p>​    <strong>热插拔</strong>：在正在运行的设备上随时插拔设备（如电脑的 USB 端口）</p>
<p>定义：应用程序运行过程中，实时替换掉某个模块，应用运行状态不受影响</p>
<p>集成在 webpack-dev-server 中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-dev-server --hot</span><br></pre></td></tr></table></figure>

<p>或进行配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    hot: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line">  	<span class="keyword">new</span> webpack.HotModuleReplacement(),</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>样式文件就可以实现热模块替换了（因为 <code>style-loader</code> 已经内部实现了 <code>HMR</code>）</p>
<p>脚本文件<strong>需手动替换模块热替换逻辑</strong></p>
<p>还有 <code>js</code> 文件，假设有一个 <code>print.js</code> 模块，向外暴露函数对象 <code>print</code>。</p>
<p>若需要为其实现热模块替换，则需在入口文件中新增如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 判断HMR是否开启</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="comment">// 监听print.js文件的变化，一旦其发生变化，不会重新打包，而是执行后续的回调函数</span></span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">'./print.js'</span>, () =&gt; &#123;</span><br><span class="line">    print()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>因为 js 文件较为复杂，而样式文件只需替换即可</p>
<p>通过脚手架创建的项目内部都集成了 HMR 方案</p>
<h4 id="HMR-注意事项"><a href="#HMR-注意事项" class="headerlink" title="HMR 注意事项"></a>HMR 注意事项</h4><ol>
<li><p>处理 HMR 的代码报错会导致页面自动刷新</p>
<p>因为 hot 方式，当热替换失败出现错误时，将回退到刷新页面的方式，页面刷新后错误信息将不容易找到。</p>
<p>解决办法：使用 <strong>hotOnly</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">devServer: &#123;</span><br><span class="line">	hotOnly: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>将不会刷新页面</p>
</li>
</ol>
<ol start="2">
<li><p>没开启 HMR，HMR API 报错</p>
<p>解决办法：先进行判断</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 module.hot 对象是 webpack 的 HMR 插件提供的</p>
</li>
</ol>
<ol start="3">
<li><p>代码中多出了与业务功能无关的代码</p>
<p>处理热替换的代码将不会被打包（无需处理）</p>
</li>
</ol>
<h3 id="13-生产环境优化"><a href="#13-生产环境优化" class="headerlink" title="13. 生产环境优化"></a>13. 生产环境优化</h3><p>生产环境注重运行效率、开发环境注重开发效率</p>
<p>配置方式 <strong>mode</strong></p>
<p>可以为不同的环境创建不同的配置</p>
<p>webpack 4 中的 production 模式下默认会开启一些优化</p>
<p>如（DefinePlugin、tree shaking）</p>
<h4 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h4><ul>
<li><p>配置文件根据环境不同导出不同配置（适用于中小型项目）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// env 为通过 cli 运行提供的环境名参数，argv 为运行 cli 过程中提供的所有参数</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">env, argv</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> config = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span>(env = <span class="string">'production'</span>) &#123;</span><br><span class="line">    config.mode = <span class="string">'production'</span></span><br><span class="line">    config.devtool = <span class="literal">false</span></span><br><span class="line">    config.plugin = [</span><br><span class="line">      ...config.plugin,</span><br><span class="line">      <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">      <span class="keyword">new</span> CopyWebpackPlugin([ <span class="string">'plublic'</span> ]),</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack 可导出一个返回配置的函数</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack --env production</span><br></pre></td></tr></table></figure>

<p>webpack 默认以开发方式运行</p>
<p>或直接判断环境变量导出对应配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> config = &#123;&#125;</span><br><span class="line"></span><br><span class="line">process.env.NODE_ENV === <span class="string">'production'</span></span><br><span class="line">? config = &#123;...&#125;</span><br><span class="line">: config = &#123;...&#125;</span><br><span class="line">            </span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure>





<ul>
<li><p>不同环境对应不同配置文件</p>
<p>一般为三个配置：开发环境配置、生产环境配置、二者公共配置</p>
<ul>
<li>webpack.common.js</li>
<li>webpack.production.js</li>
<li>webpack.development.js</li>
</ul>
</li>
</ul>
<p> webpack.production.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">'./webpack.common'</span>)</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = requie(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>，</span><br><span class="line">  plugins: [</span><br><span class="line">  	<span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([ <span class="string">'plublic'</span> ]),</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用 webpack-merge 模块提供的 merge 函数代替 Object.assign() 方法，因为  Object.assign() 方法会默认替换掉同名属性，而 merge 方法自动处理合并逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack --config webpack.production.js</span><br></pre></td></tr></table></figure>

<p>运行 webpack 打包</p>
<p>或定义到 npm script 中</p>
<p>webpack.development.js 同理</p>
<h4 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h4><p>作用：<strong>为代码注入全局成员</strong></p>
<p>在 production 模式下默认会启，为 webpack 内置插件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	...</span><br><span class="line">	plugins: [</span><br><span class="line">		<span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">			API_BASE_URL: <span class="built_in">JSON</span>.stringify(<span class="string">'https://api.example.com'</span>), <span class="comment">// 值要求为 js 代码片段</span></span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在 main.js 中使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(API_BASE_URL)</span><br></pre></td></tr></table></figure>



<h4 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h4><p><strong>移除未引用代码</strong>（dead code）</p>
<p>在 production 模式下默认会启。</p>
<p>Tree Shaking 并非某一插件，而是一组功能搭配使用后的优化效果。</p>
<p>模拟使用 tree shaking</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    usedExports: <span class="literal">true</span>, <span class="comment">// 只导出外部使用的成员</span></span><br><span class="line">    minimize: <span class="literal">true</span>, <span class="comment">// 代码压缩（会自动去除未引用代码）</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>usedExports 负责标记“枯树叶”，minimize 负责“摇掉”它们</p>
<h4 id="Scope-Hoisting（作用域提升）"><a href="#Scope-Hoisting（作用域提升）" class="headerlink" title="Scope Hoisting（作用域提升）"></a>Scope Hoisting（作用域提升）</h4><p>目的：<strong>合并模块函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    usedExports: <span class="literal">true</span>,</span><br><span class="line">    concatenateModules: <span class="literal">true</span>, <span class="comment">// 尽可能的将所有的模块合并输出到同一个函数中</span></span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若模块过多，打包后的模块函数会比较多，</p>
<p>concatenateModules 可以<strong>尽可能的将所有的模块合并输出到同一个函数中</strong>，</p>
<p>以此<strong>提升运行效率，减少代码体积</strong></p>
<p>在 webpack 3 中添加</p>
<h4 id="Tree-shaking-amp-Babel"><a href="#Tree-shaking-amp-Babel" class="headerlink" title="Tree-shaking &amp; Babel"></a>Tree-shaking &amp; Babel</h4><p><strong>Tree-shaking 前提是 ES Module</strong></p>
<p>babel-loader 并非无法与 tree shaking 共存，而是当 babel-loader 将 ESM 代码转换为 CMJ 代码后，tree shaking 无法工作。</p>
<p>若关闭 @babel/preset-env 预设中转换 ESM 的插件，则 tree-shaking 则一定会正常工作</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">  	rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [</span><br><span class="line">              [<span class="string">'@babel/preset-env'</span>, &#123; <span class="attr">module</span>: <span class="literal">false</span> &#125;] <span class="comment">// 转换 ESM 的插件</span></span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    usedExports: <span class="literal">true</span>,</span><br><span class="line">    concatenateModules: <span class="literal">true</span>,</span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="sideEffects"><a href="#sideEffects" class="headerlink" title="sideEffects"></a>sideEffects</h4><p>webpack 4</p>
<p>允许通过配置的方式标识代码是否有副作用，从而<strong>为 tree shaking 提供更大的压缩空间</strong></p>
<p>此处的<strong>副作用</strong>：模块执行时除了导出成员之外所做的事情</p>
<p>sideEffects 一般用于标记 npm 包是否有副作用</p>
<p><strong>应用场景</strong>：</p>
<p>若 components 目录下有 button.js、heading.js、link.js 等模块，并在 index.js 中重导出（聚合）</p>
<p>index.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> Button &#125; <span class="keyword">from</span> <span class="string">'./button.js'</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> Heading &#125; <span class="keyword">from</span> <span class="string">'./heading.js'</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> Link &#125; <span class="keyword">from</span> <span class="string">'./link.js'</span></span><br></pre></td></tr></table></figure>

<p>而在 main.js  中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'./components'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(Button())</span><br></pre></td></tr></table></figure>

<p>只引入了 button 一个模块。</p>
<p>但此时，所有的组件模块都会被加载执行。</p>
<p><strong>使用 sideEffects</strong>：</p>
<p>webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    sideEffects: <span class="literal">true</span>,</span><br><span class="line">    usedExports: <span class="literal">true</span>,</span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>package.json</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"sideEffects"</span>: <span class="literal">false</span>, <span class="comment">// 表明所有模块都没有副作用</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>开启 sideEffects 后，打包时 webpack 会检查 package.json 中是否存在 sideEffects 标识，以此判断模块是否有副作用。</p>
<p>若模块没有副作用，则模块将不再会打包。</p>
<p><strong>注意事项：</strong></p>
<p>使用 sideEffects  的前提，就是确保代码真的没有副作用。</p>
<p>为了防止 webpack 在打包时漏掉代码中所需模块，需谨慎开启副作用；</p>
<p>或是在 package.json 中标识有副作用的模块，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"sideEffects"</span>: [</span><br><span class="line">    <span class="string">"src/extend.js"</span>,</span><br><span class="line">    <span class="string">"*.css"</span>,</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-代码分割（Code-Splitting）"><a href="#14-代码分割（Code-Splitting）" class="headerlink" title="14. 代码分割（Code Splitting）"></a>14. 代码分割（Code Splitting）</h3><p><strong>面临的问题</strong>：通过 webpack 打包过后的所有代码都会被打包到一起。如应用复杂，模块过多，打包出的 bundle.js 将会体积较大。然而应用开始工作时，并不是每个模块在启动时都是必要的，因此出现浪费流量和带宽的情况。</p>
<p><strong>解决办法</strong>：<strong>分包，按需加载</strong>。</p>
<p>具体实现途径有两种：</p>
<h4 id="1-多入口打包（Muti-Entry）"><a href="#1-多入口打包（Muti-Entry）" class="headerlink" title="1. 多入口打包（Muti Entry）"></a>1. 多入口打包（Muti Entry）</h4><p>一般适用于传统的 <strong>多页面应用</strong>，通常一个页面对应一个入口（entry），公共部分单独提取</p>
<p>webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    album: <span class="string">'./src/album.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  pulgins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpakPlugin(&#123;</span><br><span class="line">      title: <span class="string">'Muti Entry'</span>,</span><br><span class="line">      template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      <span class="comment">// 指定 HtmlWebpakPlugin 在生成 hmtl 页面是自动引入的 js 文件。如不指定，会默认加载所有 js 文件</span></span><br><span class="line">      chunks: [<span class="string">'index'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpakPlugin(&#123;</span><br><span class="line">      title: <span class="string">'Muti Entry'</span>,</span><br><span class="line">      template: <span class="string">'./src/album.html'</span>,</span><br><span class="line">      filename: <span class="string">'album.html'</span>,</span><br><span class="line">      chunks: [<span class="string">'album'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 entry 为一个对象（entry 为数组是将文件打包到一起）</p>
<p><strong>公共模块提取</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span>, <span class="comment">// 标识把所有的公共模块都提取到单独的打包文件中</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打包后将在输出目录下生成公共的模块打包文件</p>
<h4 id="2-动态导入（-import-）"><a href="#2-动态导入（-import-）" class="headerlink" title="2. 动态导入（ import() ）"></a>2. 动态导入（ import() ）</h4><p>动态导入的模块会被自动分包</p>
<p>使用 ES Module 模块化规范</p>
<p><strong>Magic Comments（魔法注释）</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'album' */</span><span class="string">'./src/album'</span>)</span><br><span class="line">	.then()</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>通过 import 函数的内联注释，为打包后生成的包名命名</p>
<h3 id="15-输出文件名-Hash"><a href="#15-输出文件名-Hash" class="headerlink" title="15. 输出文件名 Hash"></a>15. 输出文件名 Hash</h3><p>目的：更好的控制前端静态资源的缓存</p>
<p>方法：<strong>生产模式下，文件名使用 Hash</strong></p>
<p>三种方式的 hash 值： </p>
<ul>
<li><p><code>filename: &#39;[name]-[hash].bundle.js&#39;</code></p>
<p>项目级别的 hash 值。一旦项目任意一处发生改变，下一次打包的 hash 值都会变换</p>
</li>
<li><p><code>filename: &#39;[name]-[chunkHash].bundle.js&#39;</code></p>
<p>chunk 级别的 hash 值。打包过程中，同一路的 chunk（如动态 import 生成的 chunk、多打包入口生成的 chunk ），hash 值相同。同一 chunk 的文件发生修改，打包重新生成的同一 chunk 的文件的 hash 就会发生改变。</p>
</li>
<li><p><code>filename: &#39;[name]-[contentHash].bundle.js&#39;</code></p>
<p>文件级别的 hash 值。根据输出文件的内容生成 hash，文件内容发生变化，hash 值就会发生改变。</p>
</li>
</ul>
<p>指定 hash 的长度：<code>filename: &#39;[name]-[hash:8].bundle.js&#39;</code>。默认 20 位。</p>
<p>使用方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name]-[hash].bundle.css'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  pulgins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpakPlugin(),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name]-[hash].bundle.css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>综合考虑，若以控制缓存为目的，<strong>8 位 contentHash 较为优选</strong></p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程化之三：模块化开发</title>
    <url>/2020/10/12/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>模块化一直是前端工程化中的重大问题，在标准化的 ES Module 推出之前，前端开发人员为了进行模块化开发，创造多样的模块化规范，如 CommonJS、AMD 等社区模块化规范。本文从记录模块化演变过程为开始，以加深本人在对模块化的理解，并着重记录现代的模块化规范（ ES Module、CommonJS ）。</p>
<a id="more"></a>

<h2 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h2><ul>
<li>模块化演变过程</li>
<li>模块化规范</li>
<li>常用的模块化打包工具</li>
<li>基于模块化工具构建现代 Web 工具</li>
<li>打包工具的优化技巧</li>
</ul>
<h2 id="1-模块化概述"><a href="#1-模块化概述" class="headerlink" title="1. 模块化概述"></a>1. 模块化概述</h2><p><strong>模块化</strong>就是，通过将复杂代码按照功能的不同划分成不同的模块来单独维护的一种方式。以此提高开发效率，降低维护成本。</p>
<p>模块化仅仅是思想。</p>
<h2 id="3-模块化演变过程"><a href="#3-模块化演变过程" class="headerlink" title="3. 模块化演变过程"></a>3. 模块化演变过程</h2><p>stage1 - 3：早期在没有工具和规范的情况下，以原始的模块系统未基础，通过约定，对模块化的落地方式。</p>
<p>stage4：模块化规范</p>
<h3 id="stage-1：文件划分方式"><a href="#stage-1：文件划分方式" class="headerlink" title="stage-1：文件划分方式"></a>stage-1：文件划分方式</h3><p>划分 js 文件，通过 script 分别引入</p>
<ul>
<li>弊端<ul>
<li>污染全局作用域</li>
<li>命名冲突问题</li>
<li>无法管理模块依赖关系</li>
</ul>
</li>
</ul>
<h3 id="stage-2：命名空间方式"><a href="#stage-2：命名空间方式" class="headerlink" title="stage-2：命名空间方式"></a>stage-2：命名空间方式</h3><p>每个模块值暴露一个对象，所有模块成员都挂载到这个对象上</p>
<ul>
<li>弊端<ul>
<li>仍然没有私有空间，模块内部仍可能被修改</li>
<li>仍然无法管理模块依赖关系</li>
</ul>
</li>
</ul>
<h3 id="stage-3：IIFE"><a href="#stage-3：IIFE" class="headerlink" title="stage-3：IIFE"></a>stage-3：IIFE</h3><p>将模块成员在 IIFE 中挂在到 全局对象 window 上</p>
<ul>
<li><p>优点</p>
<ul>
<li><p>每个模块有了自己的私有空间，模块内部不被外部修改了</p>
</li>
<li><p>可以将 IIFE 的参数作为依赖声明来使用。相对于文件划分和命名空间方式，模块间的依赖方式便更加明显，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module a</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">method1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'body'</span>).animate(&#123; <span class="attr">margin</span>: <span class="string">'200px'</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.moduleA = &#123; method1 &#125;</span><br><span class="line">&#125;)(jQuery)</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h3 id="stage-4：模块化规范的出现"><a href="#stage-4：模块化规范的出现" class="headerlink" title="stage-4：模块化规范的出现"></a>stage-4：模块化规范的出现</h3><p>模块化规范 + 模块加载器</p>
<h4 id="CommonJS-规范（NodeJs标准）"><a href="#CommonJS-规范（NodeJs标准）" class="headerlink" title="CommonJS 规范（NodeJs标准）"></a>CommonJS 规范（NodeJs标准）</h4><ul>
<li>一个文件就是一个模块</li>
<li>每个模块都有单独的作用域</li>
<li>通过 module.exports 导出成员</li>
<li>通过 require 函数载入模块</li>
</ul>
<p><strong>以同步方式加载模块</strong>，启动时加载模块，在浏览器中效率较低（每一次页面加载，都会进行大量的同步请求）</p>
<h4 id="AMD（Asynchronous-Module-Definition）"><a href="#AMD（Asynchronous-Module-Definition）" class="headerlink" title="AMD（Asynchronous Module Definition）"></a>AMD（Asynchronous Module Definition）</h4><p><strong>Require.js</strong> 实现了 AMD 规范</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define() <span class="comment">// 定义</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>() <span class="comment">// 载入</span></span><br></pre></td></tr></table></figure>

<p><strong>当加载一个模块时，会自动创建 script 标签请求对应的 js 文件，并且去执行对应的模块代码</strong></p>
<p>目前绝大多数的额第三方库都支持 AMD 规范。</p>
<p>但 AMD 使用起来相对复杂；</p>
<p>而且，当项目中模块划分过于细致，会导致模块 JS 文件请求频繁。</p>
<h4 id="CMD（Common-Module-Definition）"><a href="#CMD（Common-Module-Definition）" class="headerlink" title="CMD（Common Module Definition）"></a>CMD（Common Module Definition）</h4><p>Sea.js</p>
<p>类似 CommonJS 规范</p>
<h4 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h4><h2 id="4-模块化标准规范"><a href="#4-模块化标准规范" class="headerlink" title="4. 模块化标准规范"></a>4. 模块化标准规范</h2><p><strong>CommonJS</strong> in Node.js（为内置模块系统，无兼容性问题）</p>
<p><strong>ES Modules</strong> in Browsers</p>
<p>ES Modules（ES2015中语言层面的模块化规范）</p>
<h2 id="5-ES-Modules"><a href="#5-ES-Modules" class="headerlink" title="5. ES Modules"></a>5. ES Modules</h2><p>两方面，一：特性、二：语法，三：兼容性</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line">  	</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol>
<li>自动采用严格模式，忽略 ‘use strict’</li>
<li>每个 ES Module 都是独立运行在私有的作用域中</li>
<li>ES Module 中，通过 CORS 的方式请求外部 JS 模块<ul>
<li>因此若不在同一源下，请求的服务端地址的响应头中必须提供有效的 CORS 标头。</li>
</ul>
</li>
<li>ES Module 中的 script 标签会自动延迟执行脚本（等同于 script 标签的 derfer 属性）<ul>
<li>网页的加载过程中，采取 script 立即执行的机制。页面的渲染会等待脚本执行完成，再继续完成渲染。使用 ES Module 后，脚本延迟执行，不会阻塞页面渲染</li>
</ul>
</li>
</ol>
<p>ES Module 不支持文件形式访问，因此需使用 http server 的方式访问页面</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><strong>注意：</strong></p>
<ul>
<li><p><code>export {...}</code>、<code>import {...}</code> 为固定语法，并非对象字面量和解构语法</p>
</li>
<li><p><code>export {...}</code> 导出的为内部成员的引用。如下例：</p>
<p>module1.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">'foo'</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  foo = <span class="string">'bar'</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; foo &#125;</span><br></pre></td></tr></table></figure>

<p>main.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'./module1.js'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// 'foo'</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo) <span class="comment">// 'bar'</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>import {...}</code> 导入的成员为只读的常量</p>
</li>
</ul>
<h4 id="export-导出"><a href="#export-导出" class="headerlink" title="export 导出"></a>export 导出</h4><p>module1.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello !'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; foo, hello &#125; <span class="keyword">from</span> <span class="string">'./module1.js'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>

<p>如果在 html 中使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; foo, hello &#125; <span class="keyword">from</span> <span class="string">'./module1.js'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(foo)</span></span><br><span class="line">  hello()</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>或者统一导出</p>
<p>module1.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">'foo'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello !'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; foo, hello &#125; <span class="comment">// 为固定语法，并非导出一个对象。应按下方形式引入</span></span><br></pre></td></tr></table></figure>

<p>main.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; foo, hello &#125; <span class="keyword">from</span> <span class="string">'./module1.js'</span></span><br></pre></td></tr></table></figure>

<p><code>export { foo, hello }</code>  并非对象字面量</p>
<p>导出时重命名</p>
<p>module1.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; </span><br><span class="line">	foo <span class="keyword">as</span> bar,</span><br><span class="line">	hello <span class="keyword">as</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bar, h &#125; <span class="keyword">from</span> <span class="string">'./module1.js'</span></span><br></pre></td></tr></table></figure>



<p> 重命名的特殊情况</p>
<p>module1.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; </span><br><span class="line">	foo <span class="keyword">as</span> <span class="keyword">default</span>, <span class="comment">// default</span></span><br><span class="line">	hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo, hello &#125; <span class="keyword">from</span> <span class="string">'./module1.js'</span></span><br></pre></td></tr></table></figure>

<p>default 为 JS 关键字，不可作为变量直接使用，引入时需重命名</p>
<p>默认导出</p>
<p>module1.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; foo, hello &#125; <span class="comment">// 此时导出为一个对象，即 &#123; foo: foo, hello: hello &#125;</span></span><br></pre></td></tr></table></figure>

<p>main.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可以直接解构，因为 import &#123; ... &#125; = '...' 为对单独导出所设定的特殊语法</span></span><br><span class="line"><span class="keyword">import</span> module1 <span class="keyword">from</span> <span class="string">'./module1.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; foo, hello &#125; = module1</span><br></pre></td></tr></table></figure>



<h4 id="import-导入"><a href="#import-导入" class="headerlink" title="import 导入"></a>import 导入</h4><p><strong>注意：</strong></p>
<ul>
<li>原生 ES Module 引入时，需完整填写文件路径。不可省略 .js 扩展名，不可省略目录下的 index.js</li>
<li>文件相对路径开头不可省略 <code>./</code>，省略 <code>./</code> 会被误判为加载第三方模块（绝对路径写法：<code>&#39;/src/components/commont/index.js&#39;</code>，从项目根目录开始）（或可以使用完整的 URL ，引用 CDN 资源）</li>
</ul>
<p>若只需要执行某个模块，而不需要引用该模块的成员，可以如下写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;&#125; <span class="keyword">from</span> <span class="string">'./module1.js'</span></span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./module1.js'</span></span><br></pre></td></tr></table></figure>



<p>将模块导出的成员全部提取：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> allMumber <span class="keyword">from</span> <span class="string">'./module1.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; foo, hello &#125; = allMumber</span><br></pre></td></tr></table></figure>



<p><strong>使用 import() 函数动态加载模块（该函数返回一个 promise）</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./module1.js'</span>).then(<span class="function"><span class="params">module1</span> =&gt;</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>同时存在 <code>export {...}</code> 和 <code>export ...</code> 时</p>
<p>module1.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">'foo'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello !'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; foo, hello &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">'default export'</span></span><br></pre></td></tr></table></figure>

<p>main.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; foo, hello, <span class="keyword">default</span> <span class="keyword">as</span> title &#125; <span class="keyword">from</span> <span class="string">'./module1.js'</span></span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> title, &#123; foo, hello &#125; <span class="keyword">from</span> <span class="string">'./module1.js'</span></span><br></pre></td></tr></table></figure>



<h4 id="导出导入成员"><a href="#导出导入成员" class="headerlink" title="导出导入成员"></a>导出导入成员</h4><p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'./component/button/index.js'</span></span><br><span class="line"><span class="keyword">export</span> &#123; Avatar &#125; <span class="keyword">from</span> <span class="string">'./component/avatar/index.js'</span></span><br></pre></td></tr></table></figure>

<p>若导入的模块中采取 <code>export default</code>, 则需：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> Button &#125; <span class="keyword">from</span> <span class="string">'./component/button/index.js'</span></span><br></pre></td></tr></table></figure>

<p>直接导出导入成员时，导入的成员在当前模块中不可访问</p>
<h3 id="ES-Module-in-Node-js"><a href="#ES-Module-in-Node-js" class="headerlink" title="ES Module in Node.js"></a>ES Module in Node.js</h3><h4 id="支持情况"><a href="#支持情况" class="headerlink" title="支持情况"></a>支持情况</h4><p>node 8.5 之后，开始实验性的支持 ES Module</p>
<p>使用准备：</p>
<ol>
<li><p>需将文件扩展名由 .js 文件改为 .mjs</p>
</li>
<li><p>执行时，需如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node --experimental-modules index.mjs</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; writeFileSync &#125; <span class="keyword">from</span> <span class="string">'fs'</span> <span class="comment">// 内置模块兼容了 ESM 提取成员的方式</span></span><br><span class="line"><span class="keyword">import</span> &#123; cameCase &#125; <span class="keyword">from</span> <span class="string">'lodash'</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>



<h4 id="与-CommonJS-交互"><a href="#与-CommonJS-交互" class="headerlink" title="与 CommonJS 交互"></a>与 CommonJS 交互</h4><ul>
<li>ESM 中可以导入 CommonJS 模块，且 CommonJS 模块始终只会导出一个默认成员，ESM 中只会导入默认成员，不能直接提取成员（即 import { … }）</li>
<li>不能在原生 CommonJS 模块中使用 require() 函数载入 ESM</li>
</ul>
<h4 id="与-CommonJS-的差异"><a href="#与-CommonJS-的差异" class="headerlink" title="与 CommonJS 的差异"></a>与 CommonJS 的差异</h4><p>ESM 中没有 CommonJS 中的一些模块全局成员，如下：</p>
<table>
<thead>
<tr>
<th align="center">ES Modules</th>
<th align="center">CommonJS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">import</td>
<td align="center">require</td>
</tr>
<tr>
<td align="center">export</td>
<td align="center">module</td>
</tr>
<tr>
<td align="center">如下</td>
<td align="center">__filename</td>
</tr>
<tr>
<td align="center">如下</td>
<td align="center">__dirname</td>
</tr>
</tbody></table>
<p>ES Modules 中 得到 __filename 的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">'url'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="keyword">import</span>.meta.url</span><br><span class="line"><span class="keyword">const</span> __filename = fileURLToPath(url)</span><br></pre></td></tr></table></figure>

<p>得到 <em>\</em>filename后，获取 __dirname：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; dirname &#125; <span class="keyword">from</span> <span class="string">'path'</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> __dirname = dirname(__filename)</span><br></pre></td></tr></table></figure>



<h4 id="Node-新版本对-ESM-的进一步支持"><a href="#Node-新版本对-ESM-的进一步支持" class="headerlink" title="Node 新版本对 ESM 的进一步支持"></a>Node 新版本对 ESM 的进一步支持</h4><p>只需在项目下新建 package.json 中新增 type 字段，</p>
<p>package.json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	"type": "module",</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就不需要再修改 js 文件的后缀名。</p>
<p>此时，若某个文件需要使用 CommonJS 语法，需将文件扩展名改为 <code>.cjs</code></p>
<h4 id="Babel-兼容方案"><a href="#Babel-兼容方案" class="headerlink" title="Babel 兼容方案"></a>Babel 兼容方案</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add @babel&#x2F;node @babel&#x2F;core @babel&#x2F;preset-env --dev</span><br></pre></td></tr></table></figure>

<p>@babel/core：babel 核心模块</p>
<p>@babel/preset-env：babel 预设集合（包含了最新的 JS 规范中的所有新特性）</p>
<p>module1.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">'world'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;</span><br></pre></td></tr></table></figure>

<p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'module.js'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo, bar)</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn babel-node index.js --presets&#x3D;@babel&#x2F;preset-env</span><br></pre></td></tr></table></figure>

<p>启用 node 执行 index.js </p>
<p>或项目根目录下新建 babel 配置文件  <code>.babelrc</code> ，简化命令，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"presets"</span>: [<span class="string">"@babel/preset-env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行只需：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn babel-node index.js</span><br></pre></td></tr></table></figure>



<p>或使用单独的插件（transforms ES2015 modules to CommonJS）进行转换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add @babel&#x2F;plugin-transform-modules-commonjs --dev</span><br></pre></td></tr></table></figure>

<p>使用该插件处理 ESM 的兼容问题</p>
<p>.babelrc</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"@babel/plugin-transform-modules-commonjs"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn babel-node index.js</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程化之二：自动化构建工具</title>
    <url>/2020/10/03/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B9%8B%E4%BA%8C%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>本文记录在前端的自动化构建中常用的方法和工具，如使用 npm scripts，或使用 grunt、gulp、fis 这类工具来简化开发流程，将项目开发中机械式的任务进行自动化。</p>
<a id="more"></a>

<h2 id="1-使用npm-scripts"><a href="#1-使用npm-scripts" class="headerlink" title="1. 使用npm scripts"></a>1. 使用npm scripts</h2><p>package.json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">"scripts": &#123;</span><br><span class="line">	"serve": "...",</span><br><span class="line">  "build": "...",</span><br><span class="line">  "start": "..."</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以解决一部分简单的构建任务</p>
<h2 id="2-常用的构建工具"><a href="#2-常用的构建工具" class="headerlink" title="2. 常用的构建工具"></a>2. 常用的构建工具</h2><ul>
<li>Grunt</li>
<li>Gulp</li>
<li>FIS</li>
</ul>
<h3 id="1-Grunt"><a href="#1-Grunt" class="headerlink" title="1. Grunt"></a>1. Grunt</h3><p>安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add grunt --dev</span><br></pre></td></tr></table></figure>



<p>项目根目录下创建 gruntfile.js 文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>该文件向外暴露一个函数，接收一个参数，该参数上定义了一些关于 grunt 任务的方法。</p>
<p>基本使用，创建任务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">  grunt.registerTask(<span class="string">'foo'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo task run'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在终端中运行 yarn grunt foo，执行定义的任务。</p>
<p>定义异步任务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">  grunt.registerTask(<span class="string">'async-task'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> done = <span class="keyword">this</span>.async()</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'async-task run()'</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对失败任务进行标记：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">  grunt.registerTask(<span class="string">'bad'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bad task run'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对异步失败任务进行标记：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">  grunt.registerTask(<span class="string">'bad-async-task'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> done = <span class="keyword">this</span>.async()</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'bad-async-task run()'</span>)</span><br><span class="line">      done(<span class="literal">false</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>定义组合任务列表：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">  grunt.registerTask(<span class="string">'compose'</span>, [<span class="string">'foo'</span>, <span class="string">'bad'</span>, <span class="string">'bar'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合任务列表中失败任务的后续任务不会执行</p>
<p>如需要让失败任务的后续任务执行，运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn grunt bad-tasks --force</span><br></pre></td></tr></table></figure>



<p>定义多目标任务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    build: &#123;</span><br><span class="line">      css: <span class="string">'test1'</span>,</span><br><span class="line">      js: <span class="string">'test2'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  grunt.registerMultiTask(<span class="string">'build'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.options())</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`target: <span class="subst">$&#123;<span class="keyword">this</span>.target&#125;</span>, data: <span class="subst">$&#123;<span class="keyword">this</span>.data&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 grunt <strong>插件</strong></p>
<p>安装对应插件依赖，如 grunt-sass：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add grunt-sass sass --dev</span><br></pre></td></tr></table></figure>



<p>在 gruntfile.js 中使用 grunt.loadNpmTasks() 方法加载插件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	grunt.loadNpmTasks(<span class="string">'grunt-sass'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或使用社区中提供的 ‘load-grunt-tasks’ 包自动加载NPM插件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loadGruntTasks = <span class="built_in">require</span>(<span class="string">'load-grunt-tasks'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	loadGruntTasks(grunt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为任务配置目标：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'sass'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">	grunt.initConfig(&#123;</span><br><span class="line">    sass: &#123;</span><br><span class="line">      options: &#123;</span><br><span class="line">        sourceMap: <span class="literal">true</span>,</span><br><span class="line">        implementation: sass,</span><br><span class="line">      &#125;,</span><br><span class="line">      main: &#123;</span><br><span class="line">        files: &#123;</span><br><span class="line">          <span class="string">'dist/css/main.css'</span>: <span class="string">'src/scss/main.scss'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行任务 yarn grunt sass</p>
<p>…</p>
<h3 id="2-Gulp"><a href="#2-Gulp" class="headerlink" title="2. Gulp"></a>2. Gulp</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><strong>输入（读取流） ==&gt; 加工（转换流） ==&gt; 输出（写入流）</strong></p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>注册任务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.task1 = <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'task1 run'</span>)</span><br><span class="line">  done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行：yarn gulp task1</p>
<p>default 未默认任务，yarn gulp 即可</p>
<h4 id="任务组合使用"><a href="#任务组合使用" class="headerlink" title="任务组合使用"></a>任务组合使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series, parallel &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task1 = ...</span><br><span class="line"><span class="keyword">const</span> task2 = ...</span><br><span class="line"><span class="keyword">const</span> task3 = ...</span><br><span class="line"></span><br><span class="line">exports.foo = series(task1, task2, task3) <span class="comment">// 串行任务</span></span><br><span class="line"></span><br><span class="line">exports.bar = parallel(task1, task2, task3) <span class="comment">// 并行任务</span></span><br></pre></td></tr></table></figure>





<h4 id="异步任务方式（gulp-中的任务都是异步任务）"><a href="#异步任务方式（gulp-中的任务都是异步任务）" class="headerlink" title="异步任务方式（gulp 中的任务都是异步任务）"></a>异步任务方式（gulp 中的任务都是异步任务）</h4><p>1.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.task1 = <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'task1 run'</span>)</span><br><span class="line">  done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>失败：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.error_task1 = <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error_task1 run'</span>)</span><br><span class="line">  done(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'task1 failed!'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样遵循错误优先原则</p>
<p>失败失败时会中断任务队列</p>
<ol start="2">
<li>Promise</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.task2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'task2 run'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve() <span class="comment">// resolve的值会被忽略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>失败：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.task2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'task2 run'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve() <span class="comment">// resolve的值会被忽略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 async…await…</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolvee</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.task3 = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(<span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'task3 run'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Stream</li>
</ol>
<p>返回 stream 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">exports.task4 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">'package.json'</span>)</span><br><span class="line">  <span class="keyword">const</span> writeStream = fs.createWriteStream(<span class="string">'temp.txt'</span>)</span><br><span class="line">  readStream.pipe(writeStream)</span><br><span class="line">  <span class="keyword">return</span> readStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等同于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.task4 = <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">'package.json'</span>)</span><br><span class="line">  <span class="keyword">const</span> writeStream = fs.createWriteStream(<span class="string">'temp.txt'</span>)</span><br><span class="line">  readStream.pipe(writeStream)</span><br><span class="line">  readStream.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    done()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上 gulp 中注册了 end 事件，监听流的结束</p>
<h4 id="文件操作-API-插件使用"><a href="#文件操作-API-插件使用" class="headerlink" title="文件操作 API + 插件使用"></a>文件操作 API + 插件使用</h4><p><strong>使用 gulp 实现构建任务的常用流程</strong>：</p>
<p>①. 使用 gulp 提供的 src 方法创建读取流 </p>
<p>②. 借助插件实现文件加工（或自己转换） </p>
<p>③. 使用 gulp 提供的 dest方法创建写入流，写入目标文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"><span class="keyword">const</span> cleanCss = <span class="built_in">require</span>(<span class="string">'gulp-clean-css'</span>)</span><br><span class="line"><span class="keyword">const</span> rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>)</span><br><span class="line"></span><br><span class="line">exports.default = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">'src/normalize.css'</span>)</span><br><span class="line">  	.pipe(cleanCss()) <span class="comment">// 使用插件压缩css</span></span><br><span class="line">  	.pipe(rename(&#123; <span class="attr">extends</span>: <span class="string">'min.css'</span> &#125;)) <span class="comment">// 使用插件重命名扩展名</span></span><br><span class="line">    .pipe(dest(<span class="string">'dist'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-FIS"><a href="#4-FIS" class="headerlink" title="4. FIS"></a>4. FIS</h3>]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>自动化构建</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程化之一：脚手架工具</title>
    <url>/2020/09/16/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B9%8B%E4%B8%80%EF%BC%9A%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>本文从脚手架的作用、常用的脚手架工具、通用脚手架工具剖析、开发一款脚手架几方面内容着手。记录本人在前端工程化中脚手架工具的学习</p>
<a id="more"></a>

<h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h2><p>创建项目基础结构、提供项目规范和约定</p>
<p>（快速创建项目骨架）</p>
<p>（在开发相同类型的项目时，它们的组织结构、开发范式、模块依赖、工具配置、基础代码很可能相同。通过脚手架工具解决创建项目时大量重复工作的问题）</p>
<h2 id="2-常用的脚手架工具"><a href="#2-常用的脚手架工具" class="headerlink" title="2. 常用的脚手架工具"></a>2. 常用的脚手架工具</h2><p>Yeoman 通用型，根据模板生成通用的项目结构</p>
<p>Plop 开发过程中创建特定类型的文件。</p>
<h2 id="3-Yeoman"><a href="#3-Yeoman" class="headerlink" title="3. Yeoman"></a>3. Yeoman</h2><p>The web’s scaffolding(脚手架) tool for modern webapps</p>
<p>可以通过 Yeoman 搭配 不同的generator 创建任何类型的项目</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol>
<li>全局安装yo</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn global add yo</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装所需的generator，例：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn global add generator-node</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过 yo 运行 generator</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir my-module</span><br><span class="line">cd my-module</span><br><span class="line"></span><br><span class="line">yo node</span><br></pre></td></tr></table></figure>



<h4 id="1-创建-Generator"><a href="#1-创建-Generator" class="headerlink" title="1. 创建 Generator"></a>1. 创建 Generator</h4><ol>
<li>创建一个包名为 generator-name（generator-开头，name：自定义名称）的项目</li>
<li>安装基类依赖</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add yeoman-generator</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>目录结构</li>
</ol>
<ul>
<li>结构一</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├───package.json</span><br><span class="line">└───generators&#x2F;</span><br><span class="line">    ├───app&#x2F;</span><br><span class="line">    │   └───index.js</span><br><span class="line">    └───router&#x2F;</span><br><span class="line">        └───index.js</span><br></pre></td></tr></table></figure>

<p>/app 下的 generator 为使用 yo 命令运行时的默认 generator（此例中指令为 yo name）。</p>
<p>其他文件夹下的 generator 为 sub-generator（此例中指令为 yo name:router）</p>
<ul>
<li>结构二</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├───package.json</span><br><span class="line">├───app&#x2F;</span><br><span class="line">│   └───index.js</span><br><span class="line">└───router&#x2F;</span><br><span class="line">    └───index.js</span><br></pre></td></tr></table></figure>

<p>此目录结构时，需确保 package.json 中包含如下字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;app&quot;,</span><br><span class="line">    &quot;router&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>定义 generator</li>
</ol>
<ul>
<li><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Generator = <span class="built_in">require</span>(<span class="string">'yeoman-generator'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Yeoman（yeoman-generator） 提供了一个基类，其中实现一些实用的函数。</p>
<p>使用 CommonJS 模块化规范定义一个继承自此基类的类，可以在定义的这个类中实现定义所需的功能。</p>
<ul>
<li>重写 constructor</li>
<li>定义所需的自定义原型方法</li>
</ul>
<ol start="5">
<li>关联项目到全局命令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn link</span><br></pre></td></tr></table></figure>



<h4 id="2-运行时上下文（Running-Context）"><a href="#2-运行时上下文（Running-Context）" class="headerlink" title="2. 运行时上下文（Running Context）"></a>2. 运行时上下文（Running Context）</h4><h5 id="定义私有方法"><a href="#定义私有方法" class="headerlink" title="定义私有方法"></a>定义私有方法</h5><ol>
<li>下划线前缀 编写方法名</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  method1() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hey 1'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _method2() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'private hey'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实例方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args, opts) &#123;</span><br><span class="line">    <span class="keyword">super</span>(args, opts)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.helperMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'won\'t be called automatically'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>继承自父 generator</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBase</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  helper() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'methods on the parent generator won\'t be called automatically'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">MyBase</span> </span>&#123;</span><br><span class="line">  exec() &#123;</span><br><span class="line">    <span class="keyword">this</span>.helper();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="运行循环方法（类似生命周期）"><a href="#运行循环方法（类似生命周期）" class="headerlink" title="运行循环方法（类似生命周期）"></a>运行循环方法（类似生命周期）</h5><ol>
<li><strong><code>initializing</code></strong></li>
<li><strong><code>prompting</code></strong>：yo name 后在终端中询问信息。使用 this.prompt() 调用</li>
<li><strong><code>configuring</code></strong></li>
<li><strong><code>default</code></strong></li>
<li><strong><code>writing</code></strong></li>
<li><strong><code>conflicts</code></strong></li>
<li><strong><code>install</code></strong>：安装依赖</li>
<li><strong><code>end</code></strong></li>
</ol>
<h5 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h5><p>在方法中返回一个 promise 对象，resolved 时继续执行，异常时失败并停止。</p>
<p>如果方法不会返回 promise 对象，可以使用 this.async() 方法，this.async() 返回一个函数，可以在完成任务后调用，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">asyncTask() &#123;</span><br><span class="line">  <span class="keyword">var</span> done = <span class="keyword">this</span>.async();</span><br><span class="line"></span><br><span class="line">  getUserEmail(<span class="function"><span class="keyword">function</span> (<span class="params">err, name</span>) </span>&#123;</span><br><span class="line">    done(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 done 函数参数为 Error 对象，则失败并停止。</p>
<h4 id="3-用户交互（User-Interactions）"><a href="#3-用户交互（User-Interactions）" class="headerlink" title="3. 用户交互（User Interactions）"></a>3. 用户交互（User Interactions）</h4><ul>
<li><strong>prompt</strong></li>
</ul>
<p>prompt 模块内部使用 <a href="https://github.com/SBoudrias/Inquirer.js" target="_blank" rel="noopener">Inquire.js</a> 实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> prompting() &#123;</span><br><span class="line">    <span class="keyword">const</span> answers = <span class="keyword">await</span> <span class="keyword">this</span>.prompt([</span><br><span class="line">      &#123;</span><br><span class="line">        type: <span class="string">"input"</span>,</span><br><span class="line">        name: <span class="string">"name"</span>,</span><br><span class="line">        message: <span class="string">"Your project name"</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">this</span>.appname <span class="comment">// Default to current folder name</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        type: <span class="string">"confirm"</span>,</span><br><span class="line">        name: <span class="string">"cool"</span>,</span><br><span class="line">        message: <span class="string">"Would you like to enable the Cool feature?"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.log(<span class="string">"app name"</span>, answers.name);</span><br><span class="line">    <span class="keyword">this</span>.log(<span class="string">"cool feature"</span>, answers.cool);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此实例中，在执行yo name指令之后，会发出命令行询问。</p>
<p>可以获取到用户输入，在 wring() 执行时使用，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> prompting() &#123;</span><br><span class="line">    <span class="keyword">this</span>.answers = <span class="keyword">await</span> <span class="keyword">this</span>.prompt([</span><br><span class="line">      &#123;</span><br><span class="line">        type: <span class="string">"confirm"</span>,</span><br><span class="line">        name: <span class="string">"cool"</span>,</span><br><span class="line">        message: <span class="string">"Would you like to enable the Cool feature?"</span>,</span><br><span class="line">        store: <span class="literal">true</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  writing() &#123;</span><br><span class="line">    <span class="keyword">this</span>.log(<span class="string">"cool feature"</span>, <span class="keyword">this</span>.answers.cool); <span class="comment">// user answer `cool` used</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>store: true 记住先前的输入作为新的默认输入。</p>
<h3 id="Sub-Generator"><a href="#Sub-Generator" class="headerlink" title="Sub Generator"></a>Sub Generator</h3><p>用来生成特定文件的 generator 特性</p>
<h3 id="使用-Yeoman-的步骤总结"><a href="#使用-Yeoman-的步骤总结" class="headerlink" title="使用 Yeoman 的步骤总结"></a>使用 Yeoman 的步骤总结</h3><ol>
<li>明确需求</li>
<li>找到合适的 Generator（ <a href="https://yeoman.io/" target="_blank" rel="noopener">https://yeoman.io/</a> ）</li>
<li>全局安装对应的 Generator</li>
<li>通过 Yo 运行对应的 Generator</li>
<li>填写选项</li>
<li>生成项目结构</li>
</ol>
<h2 id="4-Plop"><a href="#4-Plop" class="headerlink" title="4. Plop"></a>4. Plop</h2><p>一个小而美的脚手架工具</p>
<h3 id="使用-Plop-的步骤总结"><a href="#使用-Plop-的步骤总结" class="headerlink" title="使用 Plop 的步骤总结"></a>使用 Plop 的步骤总结</h3><ol>
<li>将 plop 模块作为项目开发依赖安装</li>
<li>在项目根目录下创建一个 plopfile.js 文件</li>
<li>在 plopfile.js 文件中定义脚手架任务</li>
<li>编写用于生成特定类型文件的模板</li>
<li>通过 Plop 提供的 CLI 运行脚手架任务</li>
</ol>
<h2 id="5-自定义脚手架"><a href="#5-自定义脚手架" class="headerlink" title="5. 自定义脚手架"></a>5. 自定义脚手架</h2><p>package.json 中定义 bin 字段为启动目录，其开头为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env node</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程化概述</title>
    <url>/2020/09/06/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>最近在学习前端工程化相关的内容。本文从前端工程化的原因、表现开始，对前端工程化进行整体的描述，以加深自身对前端工程化的意义的体会。</p>
<a id="more"></a>

<h2 id="1-进行前端工程化的原因"><a href="#1-进行前端工程化的原因" class="headerlink" title="1. 进行前端工程化的原因"></a>1. 进行前端工程化的原因</h2><p>解决当下面临的问题，如：</p>
<ol>
<li>传统语言或语法的弊端</li>
<li>无法使用模块化 / 组件化</li>
<li>重复的机械式工作</li>
<li>代码风格的统一、质量的保证</li>
<li>依赖后端服务接口支持</li>
<li>整体依赖后端项目</li>
</ol>
<h2 id="2-工程化的表现"><a href="#2-工程化的表现" class="headerlink" title="2. 工程化的表现"></a>2. 工程化的表现</h2><p>一切以提高效率、降低成本、保证质量为目的的手段都属于工程化</p>
<p>从 创建项目 =&gt; 编码 =&gt; 预览 / 测试 =&gt; 提交 =&gt; 部署，一切都应该被自动化</p>
<ul>
<li>创建项目：创建项目结构；创建特定类型文件</li>
<li>编码：格式化代码；代码风格校验；编译/构建/打包</li>
<li>预览 / 测试：Web Server；Live Reloading；HMR；Mock；Source Map</li>
<li>提交：Git Hooks；Lint-staged；持续集成</li>
<li>部署：CI/CD；自动发布</li>
</ul>
<h2 id="3-工程化不等于工具"><a href="#3-工程化不等于工具" class="headerlink" title="3. 工程化不等于工具"></a>3. 工程化不等于工具</h2><p>像 create-react-app、vue-cli、angular-cli、gatsby-cli 此类工具，其实是特定类型的项目，官方给出的 <strong>集成式工程化方案</strong>。</p>
<h2 id="4-Node-js-驱动了前端工程化的进步"><a href="#4-Node-js-驱动了前端工程化的进步" class="headerlink" title="4. Node.js 驱动了前端工程化的进步"></a>4. Node.js 驱动了前端工程化的进步</h2><p>Node.js 是前端工程化的基础，前端工程化的很多工具，都是基于 Node.js 开发的</p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript粗略实现散列表</title>
    <url>/2020/08/06/JavaScript%E7%B2%97%E7%95%A5%E5%AE%9E%E7%8E%B0%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>使用 <code>JavaScript</code> 的数组（Array）结构简单地实现一个采用<strong>链地址法</strong>处理<strong>冲突</strong>（碰撞）的<strong>散列表</strong>（<strong><code>hashTable</code></strong>，或称为<strong>哈希表</strong>）。</p>
<p>利用<strong>霍纳法则</strong>（秦九韶算法）将计算 <code>hashCode</code> 的时间复杂度由O(N^2)降低到O(N)。</p>
<p>并当<strong>装填因子</strong>（<strong><code>loadFactory</code></strong>，散列表内元素个数 / 散列表容量）大于<strong>0.75</strong>时，进行<strong>扩容</strong>；当装填因子小于<strong>0.25</strong>时，进行减容。并使其容量恒为质数，以减少散列化后造成的的冲突。</p>
<a id="more"></a>

<p>其结构如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[[[key, value], [key, value]...], [[key, value], [key, value]...]... ]</span><br></pre></td></tr></table></figure>

<p>使用图表示其结构：</p>
<img src="https://i.loli.net/2020/09/06/CpxeaSOk4wfgEQ5.png" alt="JavaScript粗略实现散列表_hashTable.png" style="zoom: 80%;" />

<p>实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">HashTable</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.storage = []</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.limit = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对传入标识进行散列化的函数</span></span><br><span class="line">    HashTable.prototype.hashFunction = <span class="function"><span class="keyword">function</span> (<span class="params">key, size</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> hashCode = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//利用霍纳法则（秦九韶算法）将计算hashCode的时间复杂度由O(N^2)降低到O(N)</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; key.length; index++) &#123;</span><br><span class="line">        hashCode = <span class="number">37</span> * hashCode + key.charCodeAt(index)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> index = hashCode % size</span><br><span class="line">      <span class="keyword">return</span> index</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增 / 修改</span></span><br><span class="line">    HashTable.prototype.put = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> index = <span class="keyword">this</span>.hashFunction(key, <span class="keyword">this</span>.limit)</span><br><span class="line">      <span class="keyword">let</span> bucket = <span class="keyword">this</span>.storage[index]</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!bucket) bucket = <span class="keyword">this</span>.storage[index] = []</span><br><span class="line">      <span class="comment">// 修改</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; bucket.length; index++) &#123;</span><br><span class="line">        <span class="keyword">const</span> tuple = bucket[index]</span><br><span class="line">        <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">          tuple[<span class="number">1</span>] = value</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 新增</span></span><br><span class="line">      <span class="keyword">this</span>.storage[index].push([key, value])</span><br><span class="line">      <span class="keyword">this</span>.count += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 判断 是否需要执行扩容操作，扩容后的散列表容量仍为质数（当loadFactor大于0.75时）</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">this</span>.count / <span class="keyword">this</span>.limit) * <span class="number">100</span> &gt; <span class="number">75</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.limit = <span class="keyword">this</span>.getPrime(<span class="keyword">this</span>.limit * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">this</span>.resize(<span class="keyword">this</span>.limit)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    HashTable.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> index = <span class="keyword">this</span>.hashFunction(key, <span class="keyword">this</span>.limit)</span><br><span class="line">      <span class="keyword">const</span> bucket = <span class="keyword">this</span>.storage[index]</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!bucket) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; bucket.length; index++) &#123;</span><br><span class="line">        <span class="keyword">const</span> tuple = bucket[index]</span><br><span class="line">        <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">          <span class="keyword">return</span> tuple[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    HashTable.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> index = <span class="keyword">this</span>.hashFunction(key, <span class="keyword">this</span>.limit)</span><br><span class="line">      <span class="keyword">const</span> bucket = <span class="keyword">this</span>.storage[index]</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!bucket) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; bucket.length; index++) &#123;</span><br><span class="line">        <span class="keyword">const</span> tuple = bucket[index]</span><br><span class="line">        <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">          <span class="keyword">const</span> value = tuple[<span class="number">1</span>]</span><br><span class="line">          bucket.splice(index, <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">this</span>.count -= <span class="number">1</span></span><br><span class="line">          <span class="keyword">if</span> (bucket.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.storage[index] = <span class="literal">null</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 判断 是否需要执行减容操作，减容后的散列表容量仍为质数（当loadFactor小于0.25时）</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.limit &gt; <span class="number">7</span> &amp;&amp; (<span class="keyword">this</span>.count / <span class="keyword">this</span>.limit) * <span class="number">100</span> &lt; <span class="number">25</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.limit = <span class="keyword">this</span>.getPrime(<span class="built_in">Math</span>.floor(<span class="keyword">this</span>.limit / <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">this</span>.resize(<span class="keyword">this</span>.limit)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> value</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashTable.prototype.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.count === <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashTable.prototype.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashTable.prototype.resize = <span class="function"><span class="keyword">function</span>(<span class="params">newLimit</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> oldStorage = <span class="keyword">this</span>.storage</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 重置散列表</span></span><br><span class="line">      <span class="keyword">this</span>.storage = [] </span><br><span class="line">      <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">      <span class="keyword">this</span>.limit = newLimit</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 将原来的数据以新的映射关系put到新的散列表中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; oldStorage.length; index++) &#123;</span><br><span class="line">        <span class="keyword">const</span> oldBucket = oldStorage[index]</span><br><span class="line">        <span class="keyword">if</span> (!oldBucket) <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; oldBucket.length; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> oldTuple =  oldBucket[i]</span><br><span class="line">          <span class="keyword">this</span>.put(oldTuple[<span class="number">0</span>], oldTuple[<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断传入数字是否是质数的辅助方法</span></span><br><span class="line">    HashTable.prototype.isPrime = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">2</span>; index &lt; <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.sqrt(num)); index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % index === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个大于所传入数字的质数的辅助方法</span></span><br><span class="line">    HashTable.prototype.getPrime = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(!<span class="keyword">this</span>.isPrime(num)) &#123;</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.HashTable = HashTable</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>

<p>完！</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>数据结构</tag>
        <tag>hashTable</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo deploy后Github Pages自定义域名失效</title>
    <url>/2020/07/06/hexo%20deploy%E5%90%8EGithub%20Pages%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%A4%B1%E6%95%88/</url>
    <content><![CDATA[<p>有一个小问题，每次写完博客 <code>hexo d</code> 部署到 <code>Github Pages</code> 后，进到自己的网站一看 404。</p>
<p>解决方法很简单：</p>
<p>在 <code>hexo</code> 博客根目录的 <code>source</code> 文件夹下新建一个<strong>文件名为 <code>CNAME</code> 的无格式后缀文件，内容为你的 <code>Github Pages</code> 自定义域名。</strong></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack HMR（热模块替换）</title>
    <url>/2020/07/05/webpack%20HMR%EF%BC%88%E7%83%AD%E6%A8%A1%E5%9D%97%E6%9B%BF%E6%8D%A2%EF%BC%89/</url>
    <content><![CDATA[<p>之前入门时，也是学习过 <code>glup</code>、<code>grunt</code> 和 <code>webpack</code>，但由于平时一般都是在脚手架环境下进行开发，记的越来越模糊了。打算再次系统的学习一次 <code>webpack</code>。至于另外二者，那就需要时再说。</p>
<p><strong><code>HMR</code></strong> 是 <code>hot module replacement</code> 的缩写，也就是<strong>热模块替换</strong>，或者叫模块热替换。</p>
<a id="more"></a>

<p>它的作用就是：<strong>当项目中的一个模块发生改变时，只会重新打包这一个模块</strong>。</p>
<p>这样，当项目中拥有很多模块时，如果修改了一个模块，<code>webpack</code> 只会重新打包这一个模块，而不是将全部模块重新打包。这样可以很大提升项目开发时的构建速度。</p>
<p>开启方式很简单，由于<code>devServer</code> 内部支持 <code>HMR</code> 功能，所以只需要在 <code>webpack</code> 的 <code>devServer</code> 配置中新增 <code>hot: true</code> 选项即可，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	...</span><br><span class="line">	devServer: &#123;</span><br><span class="line">		contentBase: <span class="string">'build'</span>,</span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 开启HMR</span></span><br><span class="line">    hot: <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步完成，就可以实现样式文件的热模块替换了（因为 <code>style-loader</code> 已经内部实现了 <code>HMR</code>）</p>
<p>那 <code>html</code> 文件和 <code>js</code> 文件该如何实现呢？</p>
<p>答案是：</p>
<p><code>html</code> 文件不需要实现热模块替换，因为 <code>html</code> 文件只有一个，当发生改变时一定会重新打包，因此无需处理，也没有办法处理；</p>
<p>而且，当开启了 <code>HMR</code> 时，还会有一个问题：修改了 <code>html</code>，<code>webpack</code> 不会重新打包。只需要将 <code>entry</code> 入口改为一个数组，同时将 <code>html</code> 的相对路径添加到数组中。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  entry: [<span class="string">'./src/js/index.js'</span>, <span class="string">'./src/index.html'</span>]</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有 <code>js</code> 文件，假设有一个 <code>print.js</code> 模块，向外暴露函数对象 <code>print</code>。</p>
<p>若需要为其实现热模块替换，则需在入口文件中新增如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 判断HMR是否开启</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="comment">// 监听print.js文件的变化，一旦其发生变化，不会重新打包，而是执行后续的回调函数</span></span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">'./print.js'</span>, () =&gt; &#123;</span><br><span class="line">    print()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>HMR</code> 对 <code>js</code> 文件的处理，只能处理非入口文件的 <code>js</code> 文件，因为一旦入口文件发生变化，各模块就会重新引入处理打包，这也是合情合理的。</p>
<hr>
<p>一些原因，很久没有写博客了，以后一定抽时间多进行输出！</p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>对JavaScript再次审视的总结</title>
    <url>/2020/05/21/%E5%AF%B9JavaScript%E5%86%8D%E6%AC%A1%E5%AE%A1%E8%A7%86%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>此文没有什么长篇大论，仅仅是个人再次深入学习 <code>JavaScript</code> 的记录，以及遗忘知识点的回顾。</p>
<a id="more"></a>



<hr>
<ul>
<li><p>翻阅 <code>ECMAScript Specification</code>，解决了我很长时间的一个疑惑。<strong><code>Object.prototype</code> 是浏览器基于 spec 而创建的一个 <code>built-in</code> 的对象</strong>。</p>
<p>对此，很多人说的 “<code>JavaScript</code> 中所有函数的 <code>prototype</code> 属性值都是 <code>Object</code> 构造函数的实例对象” 这句话，是不完全正确的。</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong><code>instanceof</code></strong> <strong>运算符</strong>仅仅用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p>
<p><code>Object instanceof Function</code> 为 <code>true</code> 是由于 <code>Object.__proto__ === Function.prototype</code>。而 <code>Function instanceof Object</code> 、<code>Function instanceof Function</code>、<code>Object instanceof Object</code> 也都可以用原型链证实。</p>
</li>
</ul>
<p>因此 <code>instanceof</code> 无法判断 <code>Function</code> 和 <code>Object</code> 哪个是鸡哪个是蛋。</p>
<hr>
<ul>
<li><code>JavaScript</code> 的作用域为<strong>词法作用域</strong>（即静态作用域）。<strong>函数的作用域在函数定义的时候就决定了</strong>。</li>
</ul>
<hr>
<ul>
<li><p><code>JS</code> 引擎在<strong>代码执行之前</strong>，会创建执行上下文环境，做出以下操作：</p>
<ul>
<li>收集变量、函数以及函数的参数 <code>arguments</code> （如果是函数执行上下文的话）作为<strong>变量对象</strong>（Variable Object，VO）（在进入执行上下文阶段为 VO，在执行代码阶段变为AO。AO即 Activation Object）。</li>
<li>确认 <code>this</code> 的指向</li>
<li>创建作用域链</li>
</ul>
<p>“收集变量、函数” 就是 <strong>“使用 <code>var</code> 声明的变量存在提升，即函数声明提升”</strong>的原因（切记是声明提升，就是只声明，并不赋值）。</p>
<p><strong>函数声明提升的优先级高于变量声明提升的优先级</strong>，就像下方代码这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>最后会输出<code>foo</code> 函数体。是因为<strong>在进入执行上下文时，首先会处理函数声明，其次会处理变量声明。如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</strong>。（这句话，如果用下方模拟的这个例子来解释的话，就是：在进入全局执行上下文阶段，由于函数声明提升的优先级比变量声明提升的优先级高，所以 <code>foo</code> 函数先声明，再 <code>var foo</code> 声明，没有任何卵用！） </p>
<p>如果模拟一下 <code>JS</code> 引擎实际的执行流程，那就是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo</span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line">foo = <span class="number">1</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<hr>
<ul>
<li><p>关于闭包</p>
<ul>
<li>从理论角度来说，<code>JavaScript</code> 中所有的函数都会产生闭包，这是因为：函数在创建的时候，就会将外层执行上下文中的作用域链保存当前执行上下文的作用域 <code>[[Scopes]]</code> 中。</li>
<li>从实践角度来说，<strong>闭包</strong>的产生实际就是：<strong>即使执行上下文中的变量对象已经销毁了，而变量仍可以使用</strong>。实际开发时有两种情况：①函数中引用了外部的变量；②外层函数将内层函数 <code>return</code> （实际开发意义很大）</li>
</ul>
<p>理论角度的闭包就是理论而已，确实时这个理，实际开发中没啥卵用。</p>
<p>闭包就是为了延长变量对象的生命周期而已，并无其他深奥之处。</p>
</li>
</ul>
<hr>
<ul>
<li><code>let</code> 与 <code>const</code> 没有提升的原因是：使用 <code>let</code> 和 <code>const</code> 声明的变量， <code>JavaScript</code> 引擎在扫描代码发现变量声明时（也就是进入执行上下文时），将二者声明的变量放入临时性死区（ Temporal Dead Zone，TDZ ）。访问 <code>TDZ</code> 内的变量会报错。在执行代码时，将变量从 <code>TDZ</code> 内取出，这事方可访问。</li>
</ul>
<hr>
<ul>
<li><p><code>Symbol</code> 作为属性名时，该属性不会出现在  <code>for...in</code>、<code>for...of</code> 循环中，也不会被 <code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code> 返回。<strong>可以使用<code>Object.getOwnPropertySymbols</code> 方法，获取指定对象的所有 <code>Symbol</code> 属性名。</strong></p>
<p>如果希望使用同一个 <code>Symbol</code> 值，可以使用 <code>Symbol.for</code>。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 <code>Symbol</code> 值。如果有，就返回这个 <code>Symbol</code> 值，否则就新建并返回一个以该字符串为名称的 <code>Symbol</code> 值。就像下方这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>以前一直搞不懂 <code>Symbol</code> 在实际开发中的用途，在 issue 中发现了解答，用途如下：</p>
<ul>
<li>定义类的私有变量/方法</li>
<li>运用在单例模式中   </li>
</ul>
</li>
</ul>
<p>以上，大部分取经自 <a href="[https://github.com/mqyqingfeng/Blog#%E5%86%B4%E7%BE%BD%E7%9A%84%E5%8D%9A%E5%AE%A2](https://github.com/mqyqingfeng/Blog#冴羽的博客)">冴羽的博客</a>。</p>
<hr>
<ul>
<li><strong>继承</strong><ul>
<li><strong>原型链继承</strong>。即将子类的原型指向父类的实例，并校正子类原型的 <code>constructor</code> 属性。</li>
<li>借用构造函数继承（伪继承）。使用 <code>call</code> 或 <code>apply</code> 在子类中调用父类，将父类的 <code>this</code> 指向子类的 <code>this</code>。</li>
<li>组合继承。实际上就是 原型链继承 + 借用构造函数继承。<ul>
<li>原型链继承的作用：实现真正的继承</li>
<li>借用构造函数继承的作用：当子类中有与父类相同的属性时，节省代码量</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>mint-ui按需引入的问题</title>
    <url>/2020/05/07/mint-ui%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>按 <strong>Mint UI</strong> 官网中描述，实现<strong>按需打包</strong>的步骤如下：</p>
<ol>
<li>安装开发依赖 <code>babel-plugin-component</code></li>
<li>配置：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    [<span class="string">"es2015"</span>, &#123; <span class="string">"modules"</span>: <span class="literal">false</span> &#125;]</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"plugins"</span>: [[<span class="string">"component"</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"libraryName"</span>: <span class="string">"mint-ui"</span>,</span><br><span class="line">      <span class="string">"style"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>在项目中配置后，<code>npm run serve</code> 重新运行报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR  Error: .plugins[0][1] must be an object, false, or undefined</span><br></pre></td></tr></table></figure>

<p>就是说 <strong><code>plugins</code> 索引为0的第一个元素 的 索引为1的第二个元素必须是个 <code>object</code> 或 <code>false</code> 或 <code>undefined</code>。</strong></p>
<p>又回去官网瞅了瞅，发现官网说的是在 <code>.babelrc</code> 中配置。</p>
<p>所以官网应该是没有更新，说的还是二版本脚手架 <code>vue-cli2</code> 中的按需引入配置。</p>
<p><strong>按照错误提示</strong>，将项目根路径下 <code>babel.config.js</code> （三版本脚手架 <code>@vue/cli</code> 的 <code>babel</code> 配置文件）中内容修改如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    <span class="string">'@vue/cli-plugin-babel/preset'</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'component'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"libraryName"</span>: <span class="string">"mint-ui"</span>,</span><br><span class="line">        <span class="string">"style"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置后重新运行即可。  </p>
<p>完！</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>vue</tag>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title>git clone后本地只有master分支的问题</title>
    <url>/2020/05/07/gitclone%E5%90%8E%E6%9C%AC%E5%9C%B0%E5%8F%AA%E6%9C%89master%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<p><strong>举个例子：</strong></p>
<p>在公司上班时是在 <em>dev</em> 分支进行开发并提交到 <em>dev</em> 分支，回家后想要接着进行开发。</p>
<p> <code>git clone</code> 后进行 <code>git branch</code> 查看本地分支，只有 <em>master</em> 分支；而 <code>git branch -a</code> 查看远程分支，所有分支都在。如下：</p>
<a id="more"></a>

<p><a href="https://i.loli.net/2020/05/07/JQb4LKsCPVUkIHx.png" target="_blank"><img src="https://i.loli.net/2020/05/07/JQb4LKsCPVUkIHx.png" ></a></p>
<p><strong>两个命令，都可以追溯远程分支：</strong></p>
<ul>
<li>命令一：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b mybranch origin&#x2F;abranch</span><br></pre></td></tr></table></figure>

<p>此命令可以追溯远程分支的同时自定义本地分支名称，其余与下方命令无区别</p>
<ul>
<li>命令二：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout --track origin&#x2F;branch</span><br></pre></td></tr></table></figure>



<p>完！</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>vee-validate3.3.0的使用</title>
    <url>/2020/05/06/vee-validate%203.3.0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在 <em>vue</em> 项目中用到 <em>vee-validate</em> 进行表单验证时，用之前版本的语法一直报错，发现 <em>vee-validate</em> 已经升级到 3.3.0 版本。只有英文文档，而且个人感觉写的也不是很好。总结一下，以免再次踩坑。</p>
<p>新版本本人也是边学边用，如有纰漏，欢迎指正。</p>
<a id="more"></a>

<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>安装</li>
<li>编写 <em>validate.js</em> 并引入</li>
<li>在模板中使用验证规则</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用 <code>npm</code> 或者 <code>yarn</code> 安装（包名 <em>vee-validate</em>），也可 <code>CDN</code> 引入，不再赘述，详见官网 <a href="https://logaretm.github.io/vee-validate/overview.html#installation" target="_blank" rel="noopener">Installation</a>。</p>
<h2 id="validate-js"><a href="#validate-js" class="headerlink" title="validate.js"></a><em>validate.js</em></h2><p>在项目中创建 <em>validate.js</em> 文件。内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123;extend, ValidationProvider, ValidationObserver, localize&#125; <span class="keyword">from</span> <span class="string">'vee-validate'</span></span><br><span class="line"><span class="keyword">import</span> zh_CN <span class="keyword">from</span> <span class="string">'vee-validate/dist/locale/zh_CN.json'</span></span><br><span class="line"><span class="keyword">import</span> &#123;required&#125; <span class="keyword">from</span> <span class="string">'vee-validate/dist/rules'</span></span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'ValidationProvider'</span>, ValidationProvider)</span><br><span class="line">Vue.component(<span class="string">'ValidationObserver'</span>, ValidationObserver)</span><br><span class="line"></span><br><span class="line">localize(<span class="string">'zh_CN'</span>, zh_CN)</span><br><span class="line"></span><br><span class="line">extend(<span class="string">'required'</span>, &#123;</span><br><span class="line">  ...required</span><br><span class="line">&#125;)</span><br><span class="line">extend(<span class="string">'phoneNumber'</span>, &#123;</span><br><span class="line">  validate: <span class="function"><span class="params">value</span> =&gt;</span> <span class="regexp">/^(0|86|17951)?(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]&#123;8&#125;$/</span>.test(value),</span><br><span class="line">  message: <span class="function"><span class="params">filed</span> =&gt;</span> <span class="string">'请输入正确的'</span> + filed</span><br><span class="line">&#125;)</span><br><span class="line">extend(<span class="string">'SMSVerficationCode'</span>, &#123;</span><br><span class="line">  validate: <span class="function"><span class="params">value</span> =&gt;</span> <span class="regexp">/^\d&#123;6&#125;$/</span>.test(value),</span><br><span class="line">  message: <span class="function"><span class="params">filed</span> =&gt;</span> <span class="string">'请输入正确的'</span> + filed</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>需在入口文件 <em>main.js</em> 中引入。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./common/utils/validator'</span></span><br></pre></td></tr></table></figure>

<h3 id="拆解"><a href="#拆解" class="headerlink" title="拆解"></a>拆解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;extend, ValidationProvider, ValidationObserver, localize&#125; <span class="keyword">from</span> <span class="string">'vee-validate'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>extend</code> ：扩展验证规则的函数。</li>
<li><code>ValidationProvider</code> ：<em>vee-validate</em> 最核心组件对象，用来包裹需要规则验证的 <code>input</code> 进行实时验证。 </li>
<li><code>ValidationObserver</code> ：使用它可以在提交时进行表单的统一验证。</li>
<li><code>localize</code> ：进行错误提示本地化的函数。</li>
</ul>
<p><em>vee-validate</em> 向外暴露的不止这四个对象，还有 <code>normalizeRules</code>、<code>configure</code> 等，我这里没有用到，暂不讨论。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zh_CN <span class="keyword">from</span> <span class="string">'vee-validate/dist/locale/zh_CN.json'</span></span><br></pre></td></tr></table></figure>

<p>引入中文语言包。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;required&#125; <span class="keyword">from</span> <span class="string">'vee-validate/dist/rules'</span></span><br></pre></td></tr></table></figure>

<p> 引入内置验证规则 <code>required</code>。</p>
<p><em>vee-validate</em> 提供了一些通用的验证规则供使用，详见<a href="https://logaretm.github.io/vee-validate/guide/rules.html#rules" target="_blank" rel="noopener">Rules</a>。可以引入你所需要的，也可以全部引入，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> rules <span class="keyword">from</span> <span class="string">'vee-validate/dist/rules'</span></span><br></pre></td></tr></table></figure>

<p>声明使用内置的验证规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(rules).forEach(<span class="function"><span class="params">rule</span> =&gt;</span> &#123;</span><br><span class="line">	extend(rule, rules[rule])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'ValidationProvider'</span>, ValidationProvider)</span><br><span class="line">Vue.component(<span class="string">'ValidationObserver'</span>, ValidationObserver)</span><br></pre></td></tr></table></figure>

<p>全局注册 <code>ValidationProvider</code> 组件与 <code>ValidationObserver</code> 组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">localize(<span class="string">'zh_CN'</span>, zh_CN)</span><br></pre></td></tr></table></figure>

<p>使用中文提示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">extend(<span class="string">'ruleName'</span>, &#123;</span><br><span class="line">	<span class="comment">// options</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>为了保持包的小巧，<em>vee-validate</em> 默认没有安装任何验证规则。可以使用 <code>extend</code> 函数来自定义验证规则。</p>
<p>函数的第一个参数为验证规则名，第二个参数为验证规则的配置。这里只是 <code>extend</code> 函数的语法之一，其他语法请见<a href="https://logaretm.github.io/vee-validate/guide/basics.html#adding-rules" target="_blank" rel="noopener">Adding Rules</a>。</p>
<h2 id="在模板中使用验证规则"><a href="#在模板中使用验证规则" class="headerlink" title="在模板中使用验证规则"></a>在模板中使用验证规则</h2><h3 id="实时验证（单独验证）"><a href="#实时验证（单独验证）" class="headerlink" title="实时验证（单独验证）"></a>实时验证（单独验证）</h3><p>相较于 2.x 版本的 <em>vee-validate</em>，3.x 版本的最大变动就是通过使用 <code>ValidationProvider</code> 组件包裹 input，替代直接添加在 input 上的 <code>v-validate</code> 指令。</p>
<p> <code>ValidationProvider</code> 利用 <code>v-slot</code> （插槽）为模板提供错误信息。</p>
<p>2.x版本语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"myemail"</span> <span class="attr">v-validate</span>=<span class="string">"'required|email'"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">calss</span>=<span class="string">"error"</span> <span class="attr">v-show</span>=<span class="string">"errors.has('myemail')"</span>&gt;</span>&#123;&#123;errors.first('myemail')&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>3.x版本语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ValidationProvider</span> <span class="attr">name</span>=<span class="string">"手机号码"</span> <span class="attr">rules</span>=<span class="string">"required|phoneNumber"</span> <span class="attr">v-slot</span>=<span class="string">"&#123;errors&#125;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span> <span class="attr">maxlength</span>=<span class="string">"11"</span> <span class="attr">placeholder</span>=<span class="string">"手机号"</span> <span class="attr">v-model</span>=<span class="string">"phoneNumber"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span>&#123;&#123;errors[0]&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ValidationProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>参数 <code>rules</code> 的值为 <em>validate.js</em> 中定义的验证规则名的字符串。</p>
<p>如有多个验证规则，用 <code>|</code> 隔开。或者可以采用 规则的对象语法（<a href="https://logaretm.github.io/vee-validate/advanced/rules-object-expression.html#rules-object-expression" target="_blank" rel="noopener">Rules Object Expression</a>），就像这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ValidationProvider</span> <span class="attr">name</span>=<span class="string">"手机号码"</span> <span class="attr">:rules</span>=<span class="string">"&#123;required: true, phoneNumber: true&#125;"</span> <span class="attr">v-slot</span>=<span class="string">"&#123;errors&#125;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span> <span class="attr">maxlength</span>=<span class="string">"11"</span> <span class="attr">placeholder</span>=<span class="string">"手机号"</span> <span class="attr">v-model</span>=<span class="string">"phoneNumber"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span>&#123;&#123;errors[0]&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ValidationProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="统一验证"><a href="#统一验证" class="headerlink" title="统一验证"></a>统一验证</h3><p>3.x 版本提交表单时的<strong>统一验证</strong>证相比之前也有了很大的变动。</p>
<p>举个例子。</p>
<p>这是 2.x 版本的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">v-validate</span>=<span class="string">"'required|username'"</span> <span class="attr">placeholder</span>=<span class="string">"用户名"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">calss</span>=<span class="string">"error"</span> <span class="attr">v-show</span>=<span class="string">"errors.has('username')"</span>&gt;</span>&#123;&#123;errors.first('username')&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">v-validate</span>=<span class="string">"'required|password'"</span> <span class="attr">placeholder</span>=<span class="string">"密码"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">calss</span>=<span class="string">"error"</span> <span class="attr">v-show</span>=<span class="string">"errors.has('password')"</span>&gt;</span>&#123;&#123;errors.first('password')&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.prevent</span>=<span class="string">"validateBeforeSubmit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    validateBeforeSubmit() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$validator.validate().then(<span class="function"><span class="params">success</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// Do something!</span></span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.x 版本需要这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ValidationObserver</span> <span class="attr">v-slot</span>=<span class="string">"&#123; handleSubmit &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ValidationProvider</span> <span class="attr">v-slot</span>=<span class="string">"&#123;errors&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">rules</span>=<span class="string">"required|username"</span> <span class="attr">placeholder</span>=<span class="string">"用户名"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">calss</span>=<span class="string">"error"</span>&gt;</span>&#123;&#123;errors[0]&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ValidationProvider</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">ValidationProvider</span> <span class="attr">v-slot</span>=<span class="string">"&#123;errors&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">rules</span>=<span class="string">"required|password"</span> <span class="attr">placeholder</span>=<span class="string">"密码"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">calss</span>=<span class="string">"error"</span>&gt;</span>&#123;&#123;errors[0]&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ValidationProvider</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.prevent</span>=<span class="string">"handleSubmit(submit)"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ValidationObserver</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    submit() &#123;</span><br><span class="line"><span class="actionscript">      <span class="comment">// Only executes when validation passes!</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>ValidationObserver</code> 通过 <code>v-slot</code> 提供了一个函数 <code>handleSubmit</code> 用来进行表单的统一验证，<code>handleSubmit</code>接收一个函数参数，这个函数只有当提交的表单合法时，才会调用。</p>
<p>上方代码中，当点击 <kbd>Submit</kbd>进行表单提交时，只有当输入的 <em>username</em> 与 <em>password</em> 都符合验证规则时，才会执行函数 <code>submit</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://logaretm.github.io/vee-validate/" target="_blank" rel="noopener">VeeValidate</a> </li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>函数声明与函数表达式</title>
    <url>/2020/05/02/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>函数声明与函数表达式是 <code>JavaScript</code> 中创建函数最常见的两种方式。此文记录本人对其二者的理解。</p>
<a id="more"></a>

<hr>
<h2 id="函数声明（Function-Declaration）"><a href="#函数声明（Function-Declaration）" class="headerlink" title="函数声明（Function Declaration）"></a>函数声明（Function Declaration）</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">[param,[, param,[..., param]]]</span>) </span>&#123;</span><br><span class="line">   [statements]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用函数声明的函数定义为一条完整的语句。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>有提升，可以在函数声明之前被调用（原因：<code>js</code> 引擎会在代码执行之前创建执行上下文环境，将函数声明保存到执行上下文对象中）。</li>
</ul>
<p>就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn1(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>开发中应尽量避免使用函数提升。</strong></p>
<hr>
<h2 id="函数表达式（Function-Expression）"><a href="#函数表达式（Function-Expression）" class="headerlink" title="函数表达式（Function Expression）"></a>函数表达式（Function Expression）</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">let function_expression = function [name]([param1[, param2[, ..., paramN]]]) &#123;</span><br><span class="line">   [statements]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数表达式其与函数声明十分相似，二者最主要区别是函数名称。函数表达式中的函数名称可以省略，从而创建匿名函数。</p>
<p>使用没有函数名函数表达式的函数定义，本身不是一个完整的语句，不能单独存在，只能与其他语句配合成为一条完整的语句。</p>
<h3 id="匿名函数表达式使用的多种方式"><a href="#匿名函数表达式使用的多种方式" class="headerlink" title="匿名函数表达式使用的多种方式"></a>匿名函数表达式使用的多种方式</h3><h4 id="赋值-保存给一个变量"><a href="#赋值-保存给一个变量" class="headerlink" title="赋值/保存给一个变量"></a>赋值/保存给一个变量</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a * b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn2(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="作为另一个函数的实参（配合高阶函数）"><a href="#作为另一个函数的实参（配合高阶函数）" class="headerlink" title="作为另一个函数的实参（配合高阶函数）"></a>作为另一个函数的实参（配合高阶函数）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'延迟执行的函数表达式'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>该方式本质上也是将函数表达式保存为一个变量，内部会将定义的匿名函数赋值给内部定义的实参。</p>
<h4 id="作为另一个函数的返回值（配合高阶函数）"><a href="#作为另一个函数的返回值（配合高阶函数）" class="headerlink" title="作为另一个函数的返回值（配合高阶函数）"></a>作为另一个函数的返回值（配合高阶函数）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn3(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>同样，该方式本质上也是将函数表达式保存为一个变量。</p>
<h4 id="立即执行（IIFE实现模块化）"><a href="#立即执行（IIFE实现模块化）" class="headerlink" title="立即执行（IIFE实现模块化）"></a>立即执行（IIFE实现模块化）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="命名函数表达式"><a href="#命名函数表达式" class="headerlink" title="命名函数表达式"></a>命名函数表达式</h3><p><strong>当函数表达式不省略函数名时，可以在该函数内部（并且只能在该函数内部）使用该函数名访问该函数，该函数名作为的变量保存的值只读不可修改。</strong></p>
<p>可以借助<strong>命名函数表达式</strong>代替 <code>ECMAScript</code> 不推荐使用的 <code>arguments.callee</code>，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn4 = <span class="function"><span class="keyword">function</span> <span class="title">fn5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fn5)</span><br><span class="line">  <span class="built_in">console</span>.log(fn5 === fn4)</span><br><span class="line">  fn5 = <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(fn5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn4()</span><br></pre></td></tr></table></figure>

<p>执行输出如下：</p>
<p><a href="https://i.loli.net/2020/05/02/ToVPEl1ZYM5xgdF.png" target="_blank"><img src="https://i.loli.net/2020/05/02/ToVPEl1ZYM5xgdF.png"  style="zoom: 60%;" /></a></p>
<center>图：命名函数表达式执行</center>  
### 命名函数表达式的应用

<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>需求：<strong>使用演示定时器模拟实现循环定时器</strong>。</p>
<p>实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'action'</span>)</span><br><span class="line">  setTimeout(callback, <span class="number">1000</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>此时，可以实现控制台中每隔一秒输出一次 <code>action</code>。</p>
<p>这里只是举个例子，不推荐实际开发中这样使用，毕竟浏览器栈空间有限，这样很可能会造成栈溢出报错。</p>
<h3 id="函数表达式的提升"><a href="#函数表达式的提升" class="headerlink" title="函数表达式的提升"></a>函数表达式的提升</h3><p>不同于函数声明语句，函数表达式没有提升，无法在使用函数表达式的函数定义之前调用，如果调用会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn6(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Uncaught ReferenceError: fn6 is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn6 = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a - b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数声明与函数表达式其实都没什么难点，只是要注意匿名函数表达式的延申。</p>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function" target="_blank" rel="noopener">MDN - 函数声明</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function" target="_blank" rel="noopener">MDN - 函数表达式</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Function</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo报错TypeError [ERR_INVALID_URL]&quot;:&quot; Invalid URL&quot;:&quot;</title>
    <url>/2020/04/25/hexo%E6%8A%A5%E9%94%99TypeError%20%5BERR_INVALID_URL%5D%20Invalid%20URL/</url>
    <content><![CDATA[<p>在写完上一篇，进行 <code>hexo g</code> 时报错：</p>
<p><code>TypeError [ERR_INVALID_URL]: Invalid URL: http://localhost:8080&amp;#39;</code></p>
<p>具体如下图：</p>
<a id="more"></a>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a href="https://i.loli.net/2020/04/25/DEaKcokQ5wJAHs1.png" target="_blank"><img src="https://i.loli.net/2020/04/25/DEaKcokQ5wJAHs1.png" style="zoom: 80%;"></a></p>
<center>图：hexo报错TypeError [ERR_INVALID_URL]: Invalid URL:</center>  



<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>更改文章中此格式的链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;http:&#x2F;&#x2F;localhost:8080&#39;</span><br></pre></td></tr></table></figure>

<p>更改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\&#39;&lt;http:&#x2F;&#x2F;localhost:8080&gt;\&#39;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用反斜杠对单引号进行转义。</li>
<li>使用尖括号包裹链接（markdown 语法）。  </li>
</ol>
<p>个人猜测应该是 hexo 某插件对文章内链接的解析存在问题，这里就不深究！</p>
<p><strong>完！</strong></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>vue脚手架中使用开发环境代理</title>
    <url>/2020/04/25/vue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>在 <code>vue-cli</code> 和 <code>@vue/cli</code> 中使用开发环境代理解决跨域（ cross-origin ）问题。</p>
<p>Access to XMLHttpRequest at &#39;<a href="http://localhost:2000/index_category" target="_blank" rel="noopener">http://localhost:2000/index_category</a>&#39; from origin &#39;<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>&#39; has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</p>
<a id="more"></a>

<h2 id="vue-cli-中（二版本脚手架）"><a href="#vue-cli-中（二版本脚手架）" class="headerlink" title="vue-cli 中（二版本脚手架）"></a>vue-cli 中（二版本脚手架）</h2><p>配置项目根目录下 <code>config</code> 文件夹中文件 <code>index.js</code> 的 <code>dev.proxyTable</code> 选项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  dev: &#123;</span><br><span class="line">    ...</span><br><span class="line">    proxyTable: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http://www.example.org'</span>, <span class="comment">// target host</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>, <span class="comment">// needed for virtual hosted sites</span></span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api/old-path'</span>: <span class="string">'/api/new-path'</span>, <span class="comment">// rewrite path</span></span><br><span class="line">          <span class="string">'^/api/remove/path'</span>: <span class="string">'/path'</span>, <span class="comment">// remove base path</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 其他代理路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在需要使用代理转发的接口请求函数中将指定的名称（上方示例中是 <code>&#39;/api&#39;</code>）拼串到对应的 URL 前，重启项目即可。</p>
<h2 id="vue-cli-中（三版本脚手架）"><a href="#vue-cli-中（三版本脚手架）" class="headerlink" title="@vue-cli 中（三版本脚手架）"></a>@vue-cli 中（三版本脚手架）</h2><p>配置项目根目录下  <code>vue.config.js</code> 中的 <code>devServer.proxy</code> 选项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 配置开发代理服务器</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: <span class="string">'http://www.example.org'</span>, <span class="comment">// target host</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种对策适用于只有一个后台时，当不同请求需要通过代理转发到不同的服务器时，可以采用下方的配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 配置开发代理服务器</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http://www.example.org'</span>, <span class="comment">// target host</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>, <span class="comment">// needed for virtual hosted sites</span></span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api/old-path'</span>: <span class="string">'/api/new-path'</span>, <span class="comment">// rewrite path</span></span><br><span class="line">          <span class="string">'^/api/remove/path'</span>: <span class="string">'/path'</span>, <span class="comment">// remove base path</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'/foo'</span>: &#123;</span><br><span class="line">        target: <span class="string">'&lt;other_url&gt;'</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api/old-path'</span>: <span class="string">'/api/new-path'</span>, <span class="comment">// rewrite path</span></span><br><span class="line">          <span class="string">'^/api/remove/path'</span>: <span class="string">'/path'</span>, <span class="comment">// remove base path</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>vue-cli</code> 中的用法大同小异。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://cli.vuejs.org/zh/config/#devserver-proxy" target="_blank" rel="noopener">devServer.proxy</a></li>
<li><a href="https://github.com/chimurai/http-proxy-middleware#proxycontext-config" target="_blank" rel="noopener">http-proxy-middleware</a></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟JS中的new运算符</title>
    <url>/2020/04/11/%E6%A8%A1%E6%8B%9FJS%E4%B8%AD%E7%9A%84new%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>模拟 JavaScript 中使用 new 关键字配合构造函数创建实例对象。其基本思想如下：</p>
<ol>
<li>创建一个新的空对象（{}）。</li>
<li>给新创建的对象添加 __proto__ 属性，属性值为构造函数的 prototype 属性值。</li>
<li>将构造函数的作用域赋值给新创建的对象（此时 this 就指向了新创建的对象）。</li>
<li>执行构造函数中的代码（为新创建的对象添加属性）</li>
<li>判断构造函数的返回值类型，返回新的对象。</li>
</ol>
<a id="more"></a>

<h2 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h2><p>创建一个名为 <code>newInstance</code> 的函数，接收的第一个参数为构造函数，剩余参数为构造函数指定的实参。</p>
<p>其返回值为其第一个构造函数参数的实例对象。</p>
<blockquote>
<p><strong>newInstance(constructor[, argument1, argument2, argument3, ……])</strong></p>
</blockquote>
<p>具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newInstance</span>(<span class="params">constructor, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个新的空对象</span></span><br><span class="line">  <span class="keyword">const</span> instance = &#123;&#125;</span><br><span class="line">  <span class="comment">// 给新创建的对象添加 __proto__ 属性，属性值为构造函数的 prototype 属性值</span></span><br><span class="line">  instance.__proto__ = <span class="keyword">constructor</span>.prototype</span><br><span class="line">  </span><br><span class="line">  // 将构造函数中的 this 指向新创建的对象，并执行构造函数</span><br><span class="line">  const result = <span class="keyword">constructor</span>.apply(instance, args)</span><br><span class="line"></span><br><span class="line">  // 如果构造函数的返回值为对象类型，函数的返回值就是构造函数的返回值</span><br><span class="line">  // 如果构造函数的返回值为其他基本类型，函数的返回值为构造函数内部新创建的对象</span><br><span class="line">  return result instanceof Object ? result : instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《JavaScript 高级程序设计（第3版）》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">MDN - new 运算符</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>vue.esm.js与vue.runtime.esm.js的差异</title>
    <url>/2020/04/09/vue.esm.js%E4%B8%8Evue.runtime.esm.js%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
    <content><![CDATA[<p>在使用@vue/cli编译项目时，控制台报出如下错误：</p>
<p>[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.</p>
<a id="more"></a>

<p>翻译过来就是说：你正在使用的vue，是<strong>只包含运行时</strong>（<em>runtime-only</em>） 的构建版本，而不包含<strong>编译器</strong>（<em>compiler</em>）。要么将模板预编译进渲染（render）函数，要么使用包含编译器的构建版本。</p>
<p>此时入口文件 main.js 的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App /&gt;'</span></span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="vue的版本"><a href="#vue的版本" class="headerlink" title="vue的版本"></a>vue的版本</h2><p>要想知道问题出现的原因，得先了解 vue 的各个版本：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"><strong>UMD</strong></th>
<th><strong>CommonJS</strong></th>
<th align="left"><strong>ES Module (基于构建工具使用)</strong></th>
<th><strong>ES Module (直接用于浏览器)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>完整版（Full）</strong></td>
<td align="left">vue.js</td>
<td>vue.common.js</td>
<td align="left">vue.esm.js</td>
<td>vue.esm.browser.js</td>
</tr>
<tr>
<td align="left"><strong>只包含运行时版（Runtime-only）</strong></td>
<td align="left">vue.runtime.js</td>
<td>vue.runtime.common.js</td>
<td align="left">vue.runtime.esm.js</td>
<td>-</td>
</tr>
<tr>
<td align="left"><strong>完整版 (生产环境)</strong></td>
<td align="left">vue.min.js</td>
<td>-</td>
<td align="left">-</td>
<td>vue.esm.browser.min.js</td>
</tr>
<tr>
<td align="left"><strong>只包含运行时版 (生产环境)</strong></td>
<td align="left">vue.runtime.min.js</td>
<td>-</td>
<td align="left">-</td>
<td>-</td>
</tr>
</tbody></table>
<center>表：vue各版本</center>  
### 各版本解释

<ul>
<li><p><strong>完整版</strong>：同时包含编译器和运行时的版本。</p>
</li>
<li><p><strong>编译器</strong>：用来将模板编译成为 JavaScript 渲染函数的代码。</p>
</li>
<li><p><strong>运行时</strong>：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。  </p>
</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>当需要在客户端进行编译模板 (比如传入一个字符串给 <code>template</code> 选项，或挂载到一个元素上并以其 DOM 内部的 HTML 作为模板)时，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  component: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App /&gt;'</span></span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>此时就需要使用完整版的 vue。</p>
<p>当使用 <code>vue-loader</code> 或 <code>vueify</code> 的时候，<code>*.vue</code> 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。就像这样： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>render 函数接收一个函数作为参数，用来创建<strong>虚拟DOM</strong>（VNode）。</p>
<p>因为运行时版本相比完整版体积要小大约 30%，所以应该尽可能使用运行时版本。 </p>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>@vue/cli 默认使用的是不带编译器的 runtime-only 版（即 vue.runtime.esm.js），无法对模板进行预编译。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案一：使用带编译器的-vue"><a href="#方案一：使用带编译器的-vue" class="headerlink" title="方案一：使用带编译器的 vue"></a>方案一：使用带编译器的 vue</h3><p>三版本的脚手架 <strong>@vue/cli</strong> 相较于二版本的脚手架 <strong>vue-cli</strong> ，最大的变化就是将配置文件隐藏，我们无法直接修改配置。</p>
<p>当需要修改配置时，可以在 @vue/cli 创建的项目根目录下，新建一个名为 <code>vue.config.js</code> 的配置文件。</p>
<p>1）、我们的目的是修改 webpack 的配置，将引入的 vue 变更为 <strong>vue.esm.js</strong>。参照 @vue/cli 的<a href="https://cli.vuejs.org/zh/config/#configurewebpack" target="_blank" rel="noopener">配置参考</a>和 webpack的<a href="https://webpack.docschina.org/configuration/resolve/#resolve-alias" target="_blank" rel="noopener">配置</a>，在 <code>vue.config.js</code> 中新增一个名为 <code>configureWebpack</code> 的配置选项，具体如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 选项...</span></span><br><span class="line">  configureWebpack: &#123; <span class="comment">// webpack的配置</span></span><br><span class="line">    resolve: &#123;</span><br><span class="line">      alias: &#123; <span class="comment">// 模块路径别名</span></span><br><span class="line">        <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span>  <span class="comment">// $代表精确匹配</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>或者：</strong></p>
<p>在 <code>vue.config.js</code> 中新增一个名为 <code>runtimeCompiler</code> 的配置选项，具体如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 选项...</span></span><br><span class="line">  runtimeCompiler: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runtimeCompiler 的值决定是否使用包含运行时编译器的 vue 构建版本。</p>
<p>其默认值为 <code>false</code>，也就是 @vue/cli 默认使用的是不带编译器的 vue；</p>
<p> 设置为 <code>true</code> 后，则使用带编译器的完整版 vue，就可以在 vue 组件中使用 <code>template</code> 选项了。</p>
<p><strong>再者：</strong></p>
<p>直接引入带编译器的完整版 vue：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue/dist/vue.esm.js'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App /&gt;'</span></span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>不推荐使用这种方式。</p>
<p><strong>三种方式本质一样，都是将 vue 的构架版本修改为带编译器的完整版（vue.esm.js）</strong></p>
<p><strong>前两种方式修改配置后，需重新运行项目。</strong></p>
<h3 id="方案二：使用渲染函数"><a href="#方案二：使用渲染函数" class="headerlink" title="方案二：使用渲染函数"></a>方案二：使用渲染函数</h3><p>直接上代码，将 main.js 的代码修改如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>使用渲染函数，会在项目构建时进行预编译。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="[https://cn.vuejs.org/v2/guide/installation.html#%E5%AF%B9%E4%B8%8D%E5%90%8C%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E9%87%8A](https://cn.vuejs.org/v2/guide/installation.html#对不同构建版本的解释)">vue官方文档 - 对不同构建版本的解释</a></li>
<li><a href="[https://cli.vuejs.org/zh/config/#%E9%85%8D%E7%BD%AE%E5%8F%82%E8%80%83](https://cli.vuejs.org/zh/config/#配置参考)">@vue/cli - 配置参考</a></li>
<li><a href="https://webpack.docschina.org/configuration/resolve/#resolve-alias" target="_blank" rel="noopener">webpack - 配置</a></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>new Date().getTime()与Date.now()效率对比</title>
    <url>/2020/04/05/new%20Date.getTime()%E4%B8%8EDate.now()%E6%95%88%E7%8E%87%E5%B0%8F%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>看到好多人的文章里获取时间戳时，会用 <code>new Date().getTime()</code> 获取，而不是使用 <code>Date.now()</code>，难道是前者性能更好？于是做了一个简单的小测试对比一下。</p>
<a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">times1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行new Date().getTime()1次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">1</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行new Date().getTime()1次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行Date.now()1次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">1</span>; index++) &#123;</span><br><span class="line">    <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行Date.now()1次，耗时'</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'------------------------------------------'</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">times10</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行new Date().getTime()10次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行new Date().getTime()10次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行Date.now()10次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">    <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行Date.now()10次，耗时'</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'------------------------------------------'</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">times100</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行new Date().getTime()100次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">100</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行new Date().getTime()100次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行Date.now()100次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">100</span>; index++) &#123;</span><br><span class="line">    <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行Date.now()100次，耗时'</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'------------------------------------------'</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">times1000</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行new Date().getTime()1000次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">1000</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行new Date().getTime()1000次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行Date.now()1000次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">1000</span>; index++) &#123;</span><br><span class="line">    <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行Date.now()1000次，耗时'</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'------------------------------------------'</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">times10000</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行new Date().getTime()10000次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">10000</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行new Date().getTime()10000次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行Date.now()10000次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">10000</span>; index++) &#123;</span><br><span class="line">    <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行Date.now()10000次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'------------------------------------------'</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">times100000</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行new Date().getTime()100000次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">100000</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行new Date().getTime()100000次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行Date.now()100000次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">100000</span>; index++) &#123;</span><br><span class="line">    <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行Date.now()100000次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'------------------------------------------'</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">times1000000</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行new Date().getTime()1000000次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">1000000</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行new Date().getTime()1000000次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'执行Date.now()1000000次，耗时'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">1000000</span>; index++) &#123;</span><br><span class="line">    <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'执行Date.now()1000000次，耗时'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'------------------------------------------'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><a href="https://i.loli.net/2020/04/05/hQnTXxrSB1uCZde.png" target="_blank"><img src="https://i.loli.net/2020/04/05/hQnTXxrSB1uCZde.png" style="zoom:50%;" /></a></p>
<center>new Date().getTime()与Date.now()效率多次对比</center>

<p><strong><code>Date.now()</code> 的性能明显比 <code>new Date().getTime()</code> 要高</strong>嘛，而且无论是单次调用还是多次调用，都是 <code>Date.now()</code> 较快。</p>
<p>奇怪，那为什么你们都用 <code>new Date().getTime()</code> 哇？（陷入全世界只有我一个人不知道的恐慌）。</p>
<p>此处存疑，欢迎指正！</p>
]]></content>
      <tags>
        <tag>性能优化</tag>
        <tag>小测试</tag>
      </tags>
  </entry>
  <entry>
    <title>你知道requestAnimationFrame()吗？</title>
    <url>/2020/04/05/%E4%BD%A0%E7%9F%A5%E9%81%93requestAnimationFrame()%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<p>Web 应用中，实现动画效果的手段有很多。可以使用 CSS3 的 <em>transition</em> 和 <em>animation</em> 实现；可以使用 HTML5 中的 canvas 实现；也可以可以使用 Javascript 中的定时器进行实现。</p>
<p>除此之外，HTML5 为 Javascript 增加了一个新的 API，即 <code>Window.requestAnimationFrame()</code>，翻译成中文。这个方法会告诉浏览器：你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。</p>
<a id="more"></a>

<h2 id="为什么要使用-requestAnimationFrame"><a href="#为什么要使用-requestAnimationFrame" class="headerlink" title="为什么要使用 requestAnimationFrame()"></a>为什么要使用 requestAnimationFrame()</h2><h3 id="定时器实现动画的弊端"><a href="#定时器实现动画的弊端" class="headerlink" title="定时器实现动画的弊端"></a>定时器实现动画的弊端</h3><p>很长时间以来，<code>setTimeout()</code> 和 <code>setInterval()</code> 都是 JavaScript 实现动画的最核心技术。就像下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">updateAnimations</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    doAnimation1()</span><br><span class="line">    doAnimation2()</span><br><span class="line">    <span class="comment">// 其他动画...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  setInterval(updateAnimations, <span class="number">100</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>函数 <code>updateAnimations</code> 会每隔 100ms 调用一次，根据其内部代码对相应元素进行修改，进行页面的重绘（repaint）。</p>
<h4 id="循环间隔的衡量"><a href="#循环间隔的衡量" class="headerlink" title="循环间隔的衡量"></a>循环间隔的衡量</h4><p>使用这种方式实现动画循环，需要对间隔时间需要从两个方面进行考虑。第一，循环的间隔不能太长，这样才能保证动画效果显得平滑流畅；第二，循环的时间也不能太短，以确保浏览器能够完整的渲染动画。</p>
<p>现如今大多数电脑的刷新率都是 60HZ，也就是说，页面每秒最多只能进行60次重绘。大多数浏览器都会对重绘的操作进行限制，不超过显示器刷新的最大频率。因为即使超过，用户体验也不会有提升，反而可能会使动画抖动，也就是我们日常所说的“掉帧”。</p>
<p>因此，动画的最佳循环间隔是 1000ms/60，约等于 17ms。以这个循环间隔绘制的动画是最平滑流畅的，因为它接近浏览器的极限绘制速度。</p>
<p>在声明式编程时代，这样需要由开发者计算，而最佳方案却只有一个，无疑是不友好的。</p>
<h4 id="定时器的精准问题"><a href="#定时器的精准问题" class="headerlink" title="定时器的精准问题"></a>定时器的精准问题</h4><p>由于 JavaScript 是单线程运行的，所以定时器的回调函数需要等待前面的任务全部执行完毕后，才能执行。因此，当前面任务的执行时间超过定时器所设置的时间间隔，就会导致定时器变得“并不准时”。如下代码所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> end = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="built_in">console</span>.log(end - start)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">30000</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'主线程上的代码正在执行'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 chrome 中运行，如所示：</p>
<p><a href="https://i.loli.net/2020/04/05/uoaQCtTG2jN65fp.png" target="_blank"><img src="https://i.loli.net/2020/04/05/uoaQCtTG2jN65fp.png" style="zoom:50%;" /></a></p>
 <center>定时器“不准时”</center>
可以看到，定时器执行所用的时间并不与所设定的间隔时间吻合。

<p>CSS 动画的优势在于浏览器知道动画什么时候开始，因此其可以明确每次执行动画重绘页面的间隔时间，其动画会更显顺滑。而受限于 JavaScript 的单线程特性，定时器实现的动画，无法保证每次动画执行的间隔时间完全相同。因此定时器实现的动画，可能会出现抖动、卡顿的现象。</p>
<h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame()"></a>requestAnimationFrame()</h3><p>JavaScript 动画受限于定时器的弊端，因此，<code>requestAnimationFrame</code> 应运而生。与定时器相比，其最大的优势在于其顺应浏览器的最大重绘频率（也就是显示器的刷新率）。它保证屏幕的每一次刷新间隔中，操作动画的函数只会执行一次。因此不会出现“丢帧”的情况。</p>
<p>此外，在大多数浏览器里，当 <code>requestAnimationFrame()</code> 运行在后台标签页或者隐藏的<em>&lt;iframe&gt;</em>里时，<code>requestAnimationFrame()</code> 会被暂停调用以提升性能和电池寿命。 </p>
<hr>
<h2 id="requestAnimationFrame-的使用"><a href="#requestAnimationFrame-的使用" class="headerlink" title="requestAnimationFrame()的使用"></a>requestAnimationFrame()的使用</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p> 该方法需要传入一个回调函数作为参数，该回调函数会在浏览器的重绘之前执行。</p>
<blockquote>
<p><strong>window.requestAnimationFrame(callback)</strong></p>
</blockquote>
<p>被传入的回调函数会接收一个参数 DOMHighResTimeStamp， 该参数与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/now" target="_blank" rel="noopener"><code>performance.now()</code></a> 的返回值相同，用于标识 <code>requestAnimationFrame()</code> 开始去执行回调函数的时刻。</p>
<p><code>requestAnimationFrame()</code> 的返回值为一个长整型的数值。 是回调列表中唯一的<strong>标识</strong>，与定时器的返回值类似。是个非零值，没别的意义。可以将之传给 <code>window.cancelAnimationFrame()</code> 以取消回调函数。 </p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'SomeElementYouWantToAnimate'</span>)</span><br><span class="line"><span class="keyword">let</span> moveLength = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeatMove</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  moveLength++</span><br><span class="line">  element.style.transform = <span class="string">`translateX(<span class="subst">$&#123;moveLength&#125;</span>px)`</span></span><br><span class="line">  requestAnimationFrame(repeatMove)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repeatMove()</span><br></pre></td></tr></table></figure>

<p>在动画函数内部调用 <code>requestAnimationFrame</code>，同时传入该动画函数。在执行动画函数时，页面重新绘制，此时 <code>requestAnimationFrame</code> 会调用传入的函数。有点像递归的感觉。</p>
<h2 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级"></a>优雅降级</h2><p><code>requestAnimationFrame</code> 的兼容性，可以参考 <a href="https://caniuse.com/#search=requestAnimationFrame" target="_blank" rel="noopener">CanIUse</a>。</p>
<p><code>requestAnimationFrame</code> 在大多数主流浏览器中都可以使用，但少数低版本浏览器无法使用，因此需要向下兼容，在不兼容的浏览器中使用定时器模拟 <code>requestAnimationFrame</code> 。</p>
<p>以下代码摘自<a href="https://www.zhangxinxu.com/" target="_blank" rel="noopener">张鑫旭的个人博客</a><sup>参考</sup></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> vendors = [<span class="string">'webkit'</span>, <span class="string">'moz'</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; vendors.length &amp;&amp; !<span class="built_in">window</span>.requestAnimationFrame; ++x) &#123;</span><br><span class="line">      <span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vendors[x] + <span class="string">'RequestAnimationFrame'</span>];</span><br><span class="line">      <span class="built_in">window</span>.cancelAnimationFrame = <span class="built_in">window</span>[vendors[x] + <span class="string">'CancelAnimationFrame'</span>] ||    <span class="comment">// Webkit中此取消方法的名字变了</span></span><br><span class="line">                                    <span class="built_in">window</span>[vendors[x] + <span class="string">'CancelRequestAnimationFrame'</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">window</span>.requestAnimationFrame) &#123;</span><br><span class="line">      <span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">callback, element</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> currTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">          <span class="keyword">var</span> timeToCall = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">16.7</span> - (currTime - lastTime));</span><br><span class="line">          <span class="keyword">var</span> id = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">              callback(currTime + timeToCall);</span><br><span class="line">          &#125;, timeToCall);</span><br><span class="line">          lastTime = currTime + timeToCall;</span><br><span class="line">          <span class="keyword">return</span> id;</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">window</span>.cancelAnimationFrame) &#123;</span><br><span class="line">      <span class="built_in">window</span>.cancelAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">          clearTimeout(id);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>使用之后，就可以向下兼容到 IE6。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>JavaScript 高级程序设计（第3版）</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">MDN - window.requestAnimationFrame</a></li>
<li><a href="https://javascript.ruanyifeng.com/" target="_blank" rel="noopener">JavaScrip标准参考教程（alpha），by 阮一峰</a></li>
<li><a href="[https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/?_t_t_t=0.3547051663712042](https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-动画算法/?_t_t_t=0.3547051663712042)">张鑫旭的个人博客 - CSS3动画那么强，requestAnimationFrame还有毛线用？</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>函数节流与函数防抖</title>
    <url>/2020/04/04/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96/</url>
    <content><![CDATA[<p>函数节流与函数防抖，实际上就是为了解决事件频繁被触发，而造成不必要的性能浪费的性能优化手段。例如，浏览器的 <code>onresize</code> 事件，鼠标的 <code>mousemove</code> 事件，如果其频繁触发，很可能会造成浏览器的卡顿；或者，如果向后台频繁发送请求，也会增大服务器的压力。这时，我们就可以使用函数节流或函数防抖进行优化。</p>
<a id="more"></a>

<h2 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h2><blockquote>
<p><strong>概念：在设定的执行周期内，函数只会执行一次</strong></p>
</blockquote>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span> <span class="comment">// start = 0 ，保证第一次current - start 一定大于间隔值 delay，从而保证第一次调用一定会执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">if</span> (current - start &gt; delay) &#123;</span><br><span class="line">      callback.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) <span class="comment">// 1).使this与原事件处理函数中的this相同 2).传入原事件处理函数的参数</span></span><br><span class="line">      start = current</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>函数节流适合多次事件按时间做平均分配触发。</p>
<p>例如：</p>
<ul>
<li>浏览器窗口调整（resize）</li>
<li>页面滚动（scroll）</li>
<li>DOM 元素的拖拽（mousemove）</li>
<li>购物网站抢购（mousedown）</li>
</ul>
<hr>
<h2 id="函数防抖（debounce）"><a href="#函数防抖（debounce）" class="headerlink" title="函数防抖（debounce）"></a>函数防抖（debounce）</h2><blockquote>
<p><strong>概念： 在函数触发一段时间后再执行，如果在这段时间内再次触发，则重新计时。</strong></p>
</blockquote>
<h3 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeId</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存arguments</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">arguments</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除待执行的定时器任务</span></span><br><span class="line">    clearTimeout(timeId)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每隔delay的时间，启动一个新的延时定时器，去准备调用callback</span></span><br><span class="line">    timeId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      callback.apply(<span class="keyword">this</span>, args) <span class="comment">// 1).使this与原事件处理函数中的this相同 2).传入原事件处理函数的参数</span></span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>适合多次事件一次响应的情况</p>
<p>例如：</p>
<ul>
<li>实时搜索联想（keyup）</li>
<li>文本输入的验证（连续输入文字后发送 ajax 请求进行验证，验证一次就好）</li>
<li>判断scroll是否滑到底部（滚动事件+函数防抖）</li>
</ul>
<h2 id="函数节流与函数防抖的比较"><a href="#函数节流与函数防抖的比较" class="headerlink" title="函数节流与函数防抖的比较"></a>函数节流与函数防抖的比较</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul>
<li>都是为了对函数的频繁触发进行优化</li>
</ul>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul>
<li>节流是让函数在每个时间段内只执行一次；而防抖是，规定时间段内的连续触发，只会执行最后一次。</li>
</ul>
]]></content>
      <tags>
        <tag>性能优化</tag>
        <tag>Lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义实现数组的difference方法与merge方法</title>
    <url>/2020/03/25/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84difference%E6%96%B9%E6%B3%95%E4%B8%8Emerge%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="difference-arr"><a href="#difference-arr" class="headerlink" title="difference(arr)"></a>difference(arr)</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>得到一个当前数组中所有不与指定数组 <code>arr</code> 中元素相同的数组（改方法不会改变原数组）。</p>
<p>举个例子，假设数组有一个名为 <code>difference</code> 的方法，可以实现上述功能，那么：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"><span class="built_in">console</span>.log(array.difference([<span class="number">5</span>, <span class="number">7</span>])) <span class="comment">// (3) [1, 2, 5]</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.difference = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!arr || arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...this]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function"><span class="params">item</span> =&gt;</span> arr.indexOf(item) === <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 <code>filter()</code> 与 <code>indexOf()</code> 对当前数组进行过滤，得到结果数组。</p>
<hr>
<h2 id="merge-arr"><a href="#merge-arr" class="headerlink" title="merge(arr)"></a>merge(arr)</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>得到一个由当前数组与指定数组 <code>arr</code> 合并后组成的新的数组（改方法不会改变原数组）。</p>
<p>举个例子，假设数组有一个名为 <code>merge</code> 的方法，可以实现上述功能，那么：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(array.merge([<span class="number">2</span>, <span class="number">6</span>])) <span class="comment">// (5) [1, 2, 3, 6]</span></span><br></pre></td></tr></table></figure>

<p>该方法与数组原生方法 <code>concat</code> 的不同之处在于，如果指定数组 <code>arr</code> 中的元素，在当前数组中已经存在，<code>merge</code> 方法则不会将该重复元素合并到当前数组中。而 <code>concat</code> 会进行合并。</p>
<h2 id="自定义实现-1"><a href="#自定义实现-1" class="headerlink" title="自定义实现"></a>自定义实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.merge = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resultArr = [...this]</span><br><span class="line">  <span class="keyword">if</span> (!arr || arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> resultArr</span><br><span class="line">  &#125;</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (resultArr.indexOf(item) === <span class="number">-1</span>) &#123;</span><br><span class="line">      resultArr.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> resultArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对指定的数组进行遍历，逐个判断是否需要塞入当前数组，从而得到结果数组。</p>
]]></content>
      <tags>
        <tag>Lodash</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义实现Lodash中数组的chunk方法与compact方法</title>
    <url>/2020/03/22/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0Lodash%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84chunk%E6%96%B9%E6%B3%95%E4%B8%8Ecompact%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="chunk-size"><a href="#chunk-size" class="headerlink" title="chunk(size)"></a>chunk(size)</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>将数组（array）拆分成多个 <code>size</code> 长度的区块，并将这些区块组成一个新数组。 如果 <code>array</code>  无法被分割成全部等长的区块，那么最后剩余的元素将组成一个区块。  </p>
<p>举个例子，假设数组有一个名为 <code>chunk</code> 的方法，可以实现上述功能，那么：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.chunk(<span class="number">2</span>)) <span class="comment">// [[1, 2], [3, 4], [5, 6], [7]]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.chunk(<span class="number">3</span>)) <span class="comment">// [[1, 2, 3], [4, 5, 6], [7]]</span></span><br></pre></td></tr></table></figure>

<p>参数 <code>size</code> 的默认值为 1。</p>
<a id="more"></a>

<h3 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.chunk = <span class="function"><span class="keyword">function</span> (<span class="params">size</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// size的默认值为1</span></span><br><span class="line">  size = size || <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> length = <span class="keyword">this</span>.length</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> []</span><br><span class="line">  <span class="keyword">if</span> (size &gt; length) size = length</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> resultArrayLength = <span class="built_in">Math</span>.ceil(length / size)</span><br><span class="line">  <span class="comment">// 结果数组</span></span><br><span class="line">  <span class="keyword">const</span> resultArray = <span class="keyword">new</span> <span class="built_in">Array</span>(resultArrayLength)</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (index &lt; resultArrayLength) &#123;</span><br><span class="line">    resultArray[index++] = <span class="keyword">this</span>.slice(start, start += size)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> resultArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 <code>while</code> 循环与数组的 <code>slice</code> 方法对原数组进行反复的抽取，得到目标数组。</p>
<hr>
<h2 id="compact"><a href="#compact" class="headerlink" title="compact()"></a>compact()</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p> 创建一个新数组，包含原数组中所有的非假值元素。例如 <code>false</code>, <code>null</code>, <code>0</code>, <code>&quot;&quot;</code>, <code>undefined</code>, 和 <code>NaN</code> 都是被认为是“假值”。 </p>
<p>举个例子，假设数组有一个名为 <code>compact</code> 的方法，可以实现上述功能，那么：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">null</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.compact()) <span class="comment">// [1, 'a', 'b', true]</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义实现-1"><a href="#自定义实现-1" class="headerlink" title="自定义实现"></a>自定义实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.compact = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function"><span class="params">value</span> =&gt;</span> value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用数组的 <code>filter</code> 方法对原数组进行过滤，得到目标数组。</p>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.lodashjs.com/docs/lodash.chunk" target="_blank" rel="noopener">Lodash - “Array” 方法</a></li>
</ul>
]]></content>
      <tags>
        <tag>Lodash</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>数组扁平化</title>
    <url>/2020/03/04/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/</url>
    <content><![CDATA[<h2 id="何为数组扁平化？"><a href="#何为数组扁平化？" class="headerlink" title="何为数组扁平化？"></a>何为数组扁平化？</h2><p><strong>数组扁平化是指将一个多维数组转化为一维数组</strong>。</p>
<p>举个例子，假设有个名为 <code>flatten</code> 的函数，接受一个数组作为参数，并将之扁平化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]]</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr)) <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<hr>
<h2 id="实现数组扁平化的方法"><a href="#实现数组扁平化的方法" class="headerlink" title="实现数组扁平化的方法"></a>实现数组扁平化的方法</h2><h3 id="flat"><a href="#flat" class="headerlink" title="flat()"></a>flat()</h3><p>ES2015（即ES6）中新增了数组的 <code>flat()</code> 方法，可以直接对<strong>多维数组</strong>进行“展平”，返回一个“展平”后的数组。</p>
<p><code>flat()</code> 方法和数组的其他方法一样，定义在原型对象 <code>Array.prototype</code> 上。</p>
<p><strong><code>flat()</code> 接收一个可选参数 <code>depth</code>， 用于指定要提取嵌套数组的结构深度，默认值为1。</strong></p>
<p>使用如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'a'</span>, [<span class="string">'b'</span>, [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]], <span class="string">'d'</span>]]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.flat()) <span class="comment">// ['a', 'b', [1, [2, 3]], 'd']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="number">2</span>)) <span class="comment">// ['a', 'b', 1, [2, 3], 'd']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="number">3</span>)) <span class="comment">// ['a', 'b', 1, 2, 3, 'd']</span></span><br></pre></td></tr></table></figure>

<p>可以使用 <strong><code>Infinity</code></strong>，展开任意深度的嵌套数组。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, [<span class="number">5</span>, [<span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]]]]]]</span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="literal">Infinity</span>)) <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<p>当参数 <code>depth</code> 为负数时，会返回一个由原数组<strong>浅拷贝</strong>后的数组。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="keyword">const</span> arr2 = arr.flat(<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// [1, 2, [3, 4]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改浅拷贝得到的数组，原数组也会发生改变</span></span><br><span class="line">arr2[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, [5, 4]]</span></span><br></pre></td></tr></table></figure>

<p><code>flat()</code> 方法会将数组中的空项移除：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.flat() <span class="comment">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="函数递归-reduce-concat"><a href="#函数递归-reduce-concat" class="headerlink" title="函数递归 + reduce() + concat()"></a>函数递归 + reduce() + concat()</h3><p>自定义一个数组的方法 <code>flatten</code>，用于扁平化指定数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDepth</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array.reduce(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">      acc = acc.concat(flattenDepth(item))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      acc = acc.concat(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简写后：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDepth</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> acc.concat(<span class="built_in">Array</span>.isArray(item) ? flattenDepth(item) : item), [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展运算符-some-concat"><a href="#扩展运算符-some-concat" class="headerlink" title="扩展运算符 + some() + concat()"></a>扩展运算符 + some() + concat()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDepth</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (array.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">    array = [].concat(...array)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 ES6 的扩展运算符语法（…）将目标数组中的所有元素遍历取出，进行 <code>concat ()</code> 合并。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>核心思想就是，遍历目标数组，若数组中的元素为非数组，则与返回的新数组进行 <code>concat()</code> 合并；若数组中的元素仍为数组，则进行递归遍历，并同时与返回的新数组进行 <code>concat()</code> 合并，直到目标数组中的所有元素都不是数组为止。</p>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat" target="_blank" rel="noopener">MDN - Array.prototype.flat()</a></li>
</ul>
]]></content>
      <tags>
        <tag>Lodash</tag>
        <tag>Array</tag>
        <tag>flatten</tag>
      </tags>
  </entry>
  <entry>
    <title>promise.then()的返回值</title>
    <url>/2020/02/23/promise.then()%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<p>Promise 实例具有 <code>then</code> 方法，也就是说，<code>then</code> 方法是定义在原型对象 <code>Promise.prototype</code> 上的。它的作用是为 Promise 实例添加状态改变时的回调函数。</p>
<p><code>Promise.prototype.then()</code> 方法返回的是一个<strong>新的 Promise 实例对象</strong>，因此可以采用<strong>链式写法</strong>。</p>
<p>本文主要记录 <code>promise.then()</code> 返回值的不同情况。</p>
<a id="more"></a>

<hr>
<h2 id="then-的基本用法"><a href="#then-的基本用法" class="headerlink" title="then() 的基本用法"></a>then() 的基本用法</h2><blockquote>
<p><strong><code>new Promise(executor).then(onFulfilled[, onRejected])</code></strong> </p>
</blockquote>
<ul>
<li><strong>onFulfilled</strong>： 当 Promise 变成 <strong><em>fulfilled</em></strong> 状态时调用的函数。</li>
<li><strong>onRejected</strong>： 当 Promise 变成 <strong><em>rejected</em></strong> 状态时调用的函数。</li>
</ul>
<hr>
<h2 id="then方法的返回值"><a href="#then方法的返回值" class="headerlink" title="then方法的返回值"></a>then方法的返回值</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong><code>then()</code> 返回的 promise 实例对象的结果由 <code>then()</code> 中指定的回调函数执行的结果决定</strong>。即由传入的 <strong>onFulfilled</strong> 或 <strong>onRejected</strong> 执行的结果决定。</p>
<ul>
<li>没有返回任何值（实际返回 undefined），那么 <code>then()</code> 返回的 promise 将会成为接受（resolved）状态。promise 携带的 value 为 undefined。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onFulfilled'</span>, value)) <span class="comment">// onFulfilled undefined</span></span><br></pre></td></tr></table></figure>



<ul>
<li>返回了一个一般的值，那么 <code>then()</code> 返回的 promise 将会成为接受（resolved）状态。promise 携带的 value 为返回的值。 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">1</span>, () =&gt; <span class="number">2</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onFulfilled'</span>, value)) <span class="comment">// onFulfilled 1</span></span><br></pre></td></tr></table></figure>



<ul>
<li>抛出一个错误（throw xxx），那么 <code>then()</code> 返回的 promise 将会成为拒绝（rejected）状态。promise 携带的 reason 为抛出的错误。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使 .then() 返回一个 rejected promise</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'3'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'不会调用'</span>),</span><br><span class="line">    (reason) =&gt; <span class="built_in">console</span>.log(<span class="string">'onRejected'</span>, reason) <span class="comment">// onRejected Error: 3</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>



<ul>
<li>返回一个接受（resolved）状态的 promise，那么 <code>then()</code> 返回的 promise 将会成为接受（resolved）状态。<code>then()</code> 返回的 promise 携带的 value 为回调函数返回的 promise 携带的 value。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="number">4</span>))</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'onFulfilled'</span>, value)) <span class="comment">// onFulfilled 4</span></span><br></pre></td></tr></table></figure>



<ul>
<li>返回一个拒绝（rejected）状态的 promise，那么 <code>then()</code> 返回的 promise 将会成为拒绝（rejected）状态。<code>then()</code> 返回的 promise 携带的 reason 为回调函数返回的 promise 携带的 reason 。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.reject(<span class="number">5</span>))</span><br><span class="line">  .then(</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'不会调用'</span>),</span><br><span class="line">    (reason) =&gt; <span class="built_in">console</span>.log(<span class="string">'onRejected'</span>, reason) <span class="comment">// onRejected 5</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>



<ul>
<li>返回一个初始（pending）状态的 promise，那么 <code>then()</code> 返回的 promise 将会成为初始（pending）状态。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise) <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener">使用 Promise</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的错误Error与错误处理</title>
    <url>/2020/02/20/JS%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AFError%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="Error实例对象"><a href="#Error实例对象" class="headerlink" title="Error实例对象"></a>Error实例对象</h2><p><code>Error</code> 是 JavaScript 中的错误类，它同时也是一个构造函数，可以用来创建一个错误对象。<code>Error</code> 的实例会在运行发生错误时抛出，<code>Error</code> 对象像其它对象一样，也可以由用户自定义创建。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error message'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(err) <span class="comment">// Error: error message</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><blockquote>
<p><strong>new Error([message])</strong></p>
</blockquote>
<ul>
<li><strong>message</strong>：可选参数，表示出错时的提示信息 。</li>
</ul>
<p>JavaScript 语言标准只提到，<code>Error</code> 实例对象有 <code>message</code> 属性，没有提到其他属性 。</p>
<p>不同执行引擎对 <code>Error</code> 类的实现有所不同， 大多数 JavaScript 引擎，对 <code>Error</code> 实例还提供 <code>name</code> 和 <code>stack</code> 属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。 </p>
<ul>
<li><strong>name</strong>：错误名称（非标准属性）</li>
<li><strong>stack</strong>：错误的堆栈（非标准属性）</li>
</ul>
<p><strong>作为函数使用</strong></p>
<p>当像函数一样使用 <code>Error</code> 时 – 如果没有 <code>new</code>，它也会返回一个 <code>Error</code> 对象。也就是说，仅仅调用 <code>Error</code> 将产生与通过 <code>new</code> 关键字构造 <code>Error</code> 输出相同的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> err1 = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(err1) <span class="comment">// Error: 1</span></span><br><span class="line"><span class="keyword">let</span> err2 = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(err2) <span class="comment">// Error: 1</span></span><br></pre></td></tr></table></figure>

<h3 id="Error类的方法与属性"><a href="#Error类的方法与属性" class="headerlink" title="Error类的方法与属性"></a>Error类的方法与属性</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h4><p><code>Error</code> 类本身没有任何方法。但是，由于在 JavaScript 中所有类都是 Object 的子类，所以其会包含一些继承自 <code>Object</code> 类的方法。 </p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p> <code>Error</code> 类也没有自身定义的类属性，其所有属性据来自于其父类<code>Object</code>。 </p>
<ul>
<li><code>Error.prototype</code> － 添加到其实例中的属性</li>
</ul>
<h3 id="Error实例"><a href="#Error实例" class="headerlink" title="Error实例"></a>Error实例</h3><p>运行时错误实例会由执行引擎自动创建和抛出，我们也可以通过构造函数自定义 <code>Error</code> 实例，与其它类一样我们也可以通过 <code>Error.prototype</code> 向实例中添加属性和方法。</p>
<p><code>Error</code> 实例包含以下属性或方法：</p>
<ul>
<li><code>Error.prototype.constructor</code> － 指定对象的构造函数</li>
<li><code>Error.prototype.message</code> － 错误信息</li>
<li><code>Error.prototype.name</code> － 错误名</li>
<li><code>Error.prototype.stack</code> － 错误堆栈信息。该属性是一个非标准属性，但被大多数执行引擎所支持。</li>
<li><code>Error.prototype.toString()</code> － 表示错误对象的描述信息。继承并重写<code>Object.prototype.toString()</code></li>
</ul>
<hr>
<h2 id="Error类型"><a href="#Error类型" class="headerlink" title="Error类型"></a>Error类型</h2><p>除标准错误对象 <code>Error</code> 外，JavaScript 中还内置了一些类型错误对象。它们会在特殊时刻，或由特定的对象触发。 </p>
<p>常用的有：</p>
<h3 id="ReferenceError-引用错误"><a href="#ReferenceError-引用错误" class="headerlink" title="ReferenceError - 引用错误"></a>ReferenceError - 引用错误</h3><p> <code>ReferenceError</code> 错误对象会在<strong>无效引用</strong>时触发。也可以通过构造函数创建该对象的实例：</p>
<blockquote>
<p><strong>new ReferenceError([message])</strong></p>
</blockquote>
<p>引用未定义的变量时，会抛出该错误： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<p> 另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者 <code>this</code> 赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等号左侧不是变量</span></span><br><span class="line"><span class="built_in">console</span>.log() = <span class="number">1</span></span><br><span class="line"><span class="comment">// Uncaught ReferenceError: Invalid left-hand side in assignment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this 对象不能手动赋值</span></span><br><span class="line"><span class="keyword">this</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>

<h3 id="TypeError-类型错误"><a href="#TypeError-类型错误" class="headerlink" title="TypeError - 类型错误"></a>TypeError - 类型错误</h3><p> <code>TypeError</code> 错误会在<strong>变量或参数不属于有效类型</strong>时触发。也可以通过构造函数创建该对象的实例：</p>
<blockquote>
<p><strong>new TypeError([message])</strong></p>
</blockquote>
<p>比如，对字符串、布尔值、数值等原始类型的值使用 <code>new</code> 命令，就会抛出这种错误，因为 <code>new</code> 命令的参数应该是一个构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="number">123</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: 123 is not a constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: true is not a constructor</span></span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>或是当调用对象不存在的方法，也会抛出 <code>TypeError</code> 错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj.unknownMethod()</span><br><span class="line"><span class="comment">// Uncaught TypeError: obj.unknownMethod is not a function</span></span><br></pre></td></tr></table></figure>

<h3 id="SyntaxError-语法错误"><a href="#SyntaxError-语法错误" class="headerlink" title="SyntaxError - 语法错误"></a>SyntaxError - 语法错误</h3><p><code>SyntaxError</code> 错误对象会在解析代码的过程中发生的语法错误时触发。也可以通过构造函数创建该对象的实例：</p>
<blockquote>
<p><strong>new SyntaxError([message])</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量名错误</span></span><br><span class="line"><span class="keyword">let</span> <span class="number">1</span>a</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺少括号</span></span><br><span class="line"><span class="built_in">console</span>.log <span class="string">'hello'</span>)</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected string</span></span><br></pre></td></tr></table></figure>

<p>上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出<code>SyntaxError</code>。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。 </p>
<h3 id="RangeError-范围错误"><a href="#RangeError-范围错误" class="headerlink" title="RangeError - 范围错误"></a>RangeError - 范围错误</h3><p><code>RangeError</code>错误对象会在数值变量或参数超出其有效范围时触发。也可以通过构造函数创建该对象的实例：</p>
<blockquote>
<p><strong>new RangeError([message])</strong></p>
</blockquote>
<p> 触发<code>RangeError</code>错误的情况有：对 <code>Array</code> 构造函数使用错误的长度值； 对 <code>Number</code> 对象的方法参数超出范围； 以及函数堆栈超过最大值等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 Array 构造函数使用错误的长度值</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// Uncaught RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 Number 对象的方法参数超出范围</span></span><br><span class="line"><span class="keyword">let</span> numObj = <span class="number">77.1234</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj.toExponential(<span class="number">101</span>))</span><br><span class="line"><span class="comment">// Uncaught RangeError: toExponential() argument must be between 0 and 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数堆栈超过最大值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fn()</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="comment">// RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>



<p>除了这几种常见的的错误类型之外，还有：</p>
<h3 id="URIError"><a href="#URIError" class="headerlink" title="URIError"></a>URIError</h3><p><code>URIError</code>错误会错误使用全局URI函数如 <code>encodeURI()</code>、<code>decodeURI()</code> 等时触发。也可以通过构造函数创建该对象的实例。</p>
<p>该错误类型在目前的 ECMAScript 规范中仍处于草案（Draft）阶段，<a href="https://www.ecma-international.org/ecma-262/6.0/#sec-native-error-types-used-in-this-standard-evalerror" target="_blank" rel="noopener">详情点击</a>。</p>
<h3 id="InternalError"><a href="#InternalError" class="headerlink" title="InternalError"></a>InternalError</h3><p> <code>InternalError</code> 对象表示出现在 JavaScript 引擎内部的错误。 例如： “InternalError: too much recursion”（内部错误：递归过深）。</p>
<p>该错误类型目前尚未成为规范的一部分。</p>
<h3 id="EvalError"><a href="#EvalError" class="headerlink" title="EvalError"></a>EvalError</h3><p><code>EvalError</code>对象表示全局函数<code>eval()</code>中发生的错误。</p>
<p> 该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留，<a href="https://www.ecma-international.org/ecma-262/6.0/#sec-native-error-types-used-in-this-standard-evalerror" target="_blank" rel="noopener">详情点击</a>。</p>
<hr>
<h2 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h2><p>当 JavaScript 内置错误类型不能满足需要时，还可以自定义错误。自定义错误就是继承 <code>Error</code> 对象，并对其进行一定的扩展：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.message = message || <span class="string">'Default Message'</span></span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'MyError'</span></span><br><span class="line">&#125;</span><br><span class="line">MyError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">MyError.prototype.constructor = MyError</span><br></pre></td></tr></table></figure>

<p>接着，我们就可以生成这种自定义类型的错误了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> MyError(<span class="string">'this is my customizable error'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="错误的处理"><a href="#错误的处理" class="headerlink" title="错误的处理"></a>错误的处理</h2><h3 id="抛出错误-throw-语句"><a href="#抛出错误-throw-语句" class="headerlink" title="抛出错误 - throw 语句"></a>抛出错误 - throw 语句</h3><p> 通常，可以在创建 <code>Error</code> 实例后，通过 <code>throw</code> 关键字抛出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'go wrong!'</span>)</span><br><span class="line"><span class="comment">// Error: go wrong!</span></span><br></pre></td></tr></table></figure>

<p> 实际上，<strong><code>throw</code> 可以抛出任何类型的值</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抛出一个字符串</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">'Error！'</span></span><br><span class="line"><span class="comment">// Uncaught Error！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个数值</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">42</span></span><br><span class="line"><span class="comment">// Uncaught 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个布尔值</span></span><br><span class="line"><span class="keyword">throw</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">// Uncaught true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个对象</span></span><br><span class="line"><span class="keyword">throw</span> &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Error!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught &#123;toString: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<p>对于 JavaScript 引擎来说，遇到 <code>throw</code> 语句，程序就中止了。引擎会接收到 <code>throw</code> 抛出的信息，可能是一个错误实例，也可能是其他类型的值。 </p>
<h3 id="捕获错误-try-…-catch结构"><a href="#捕获错误-try-…-catch结构" class="headerlink" title="捕获错误 - try … catch结构"></a>捕获错误 - try … catch结构</h3><p> 一旦发生错误，程序就中止执行了。 JavaScript提供了 <code>try...catch</code> 结构来捕获和处理错误， 选择是否往下执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'go wrong!'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error.message = '</span> + error.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上方代码，try 代码块中抛出错误，该错误将立即被 catch 捕获，将该错误作为参数传递给 catch，并执行 catch 中的代码。</p>
<p>也就是说，<strong>如果不确定某些代码是否会报错，就可以把它们放在 <code>try...catch</code> 代码块之中，便于进一步对错误进行处理</strong>。 <code>catch</code> 代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。 </p>
<p><code>try...catch</code> 可以嵌套使用。</p>
<h3 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h3><p>可以在 <code>try...catch</code> 结构最后添加一个 <strong><code>finally</code> 代码块，表示不管是否出现错误，都必需在最后运行的语句</strong>。</p>
<p>如下代码，就是一个使用 <code>try...catch...finally</code> 的经典场景。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openFile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		writeFile(data) <span class="comment">// 将可能出错的写入文件放入try代码块中</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">		handleError(err) <span class="comment">// 如果在写入文件过程中出现错误，将在此处理</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">		closeFile() <span class="comment">// 总是会关闭文件</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>即使在 <code>try</code> 和 <code>catch</code> 的代码块中存在 <code>return</code> 语句，<code>finally</code> 中的代码依然会执行。</strong></p>
<p>如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">still</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'result'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'FINALLY'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(still(<span class="string">'test'</span>))</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// FINALLY</span></span><br><span class="line"><span class="comment">// result</span></span><br></pre></td></tr></table></figure>

<p>从阮一峰老师的博客中可以看到： <strong>在 <code>try</code> 或 <code>catch</code> 中，<code>return</code> 语句的执行是排在 <code>finally</code> 代码之前的，只是等 <code>finally</code> 代码执行完毕后才返回</strong>。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(countUp())</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(count)</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中可以看到，<code>countUp()</code> 的返回值 <code>count</code> 先被确定为 0，但是此时并没有直接返回，而是先执行 <code>finally</code> 代码块中的内容。</p>
<p><strong><code>finall</code> 代码块中的 <code>return</code> 语句会覆盖掉在 <code>try</code> 或 <code>catch</code> 中的 <code>return</code></strong>。也就是说， <strong>如果 <code>finall</code> 代码块中存在 <code>return</code>，那么该条 <code>return</code>语句中的值将作为 <code>try...catch...finally</code> 的返回值。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'from_try'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'from_finally'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error" target="_blank" rel="noopener">MDN —— Error</a></li>
<li><a href="https://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">Standard ECMA-262 6th Edition / June 2015 ECMAScript® 2015 Language Specification</a></li>
<li><a href="https://wangdoc.com/javascript/features/error.html" target="_blank" rel="noopener">阮一峰的网络日志 —— 错误处理机制</a></li>
<li><a href="https://itbilu.com/javascript/js/V1oOv4Vv-.html" target="_blank" rel="noopener">IT笔录 —— JavaScript Error对象及错误类型</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>详解state与setState</title>
    <url>/2020/02/15/%E8%AF%A6%E8%A7%A3state%E4%B8%8EsetState/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>本文参考了一些资料，逐一通过例子对 state 和 setState() 进行梳理、总结，并在此记录。</p>
</blockquote>
<blockquote>
<p>使用过 <strong><a href="https://reactjs.org/" target="_blank" rel="noopener">react</a></strong> 的小伙伴都知道， React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。</p>
<p>而 <strong>setState()</strong> 是 react 中的一个非常重要的方法。当我们调用 setState() 的时候，react 会更新组件的状态 <strong>state</strong>，并且自动重新调用 <strong>render</strong> 方法，然后再把 render 方法所渲染的最新的内容显示到页面上。</p>
</blockquote>
<a id="more"></a>

<hr>
<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p> 一个组件的显示形态是可以由它数据状态和配置参数决定的。一个组件可以拥有自己的<strong>状态</strong>， react 的 <strong><a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">state</a></strong> 就是用来存储这种可变化的状态的。</p>
<p>以下方这个 Counter 计数器为例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击按钮 'A 测试1', count数量加1</span></span><br><span class="line">  test1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="number">3</span> &#125;)  <span class="comment">// 调用对象形式的setState()更新状态</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击按钮 'A 测试2', count数量加1</span></span><br><span class="line">  test2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;  <span class="comment">// 调用函数形式的setState()更新状态</span></span><br><span class="line">      count: state.count + <span class="number">1</span></span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()2之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击按钮 'A 测试3', 调用带回调函数的setState()</span></span><br><span class="line">  test3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(</span><br><span class="line">      state =&gt; (&#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;),</span><br><span class="line">      () =&gt; &#123;<span class="comment">// 状态数据更新且界面更新后立即执行</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'在callback中'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击按钮 'A 测试4', 调用两次参数为对象形式的setState()</span></span><br><span class="line">  test4 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()4之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击按钮 'A 测试5', 调用两次参数为函数形式的setState()</span></span><br><span class="line">  test5 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;))</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()5之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'A render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;A组件: &#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.test1&#125;&gt;A 测试1&lt;/</span>button&gt; &amp;nbsp;&amp;nbsp;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.test2&#125;&gt;A 测试<span class="number">2</span>&lt;<span class="regexp">/button&gt; &amp;nbsp;&amp;nbsp;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.test3&#125;&gt;A 测试3&lt;/</span>button&gt; &amp;nbsp;&amp;nbsp;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.test4&#125;&gt;A 测试<span class="number">4</span>&lt;<span class="regexp">/button&gt; &amp;nbsp;&amp;nbsp;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.test5&#125;&gt;A 测试5&lt;/</span>button&gt; &amp;nbsp;&amp;nbsp;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Counter /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure>

<p>  上面代码是一个 <code>Counter</code> 组件，<code>count</code> 存放在的实例的 <code>state</code> 对象当中，这个对象在构造函数里面初始化。这个组件的 <code>render</code> 函数内，会根据组件的 <code>state</code> 的中的 <code>count</code> 值的变化而对应显示。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p> 当我们要改变组件的状态的时候，不能直接用 <del><code>this.state = xxx</code></del> 这种方式来修改，如果这样做 React 就没办法知道你修改了组件的状态，它也就没有办法更新页面。所以，一定要使用 React 提供的 <code>setState</code> 方法，<strong>它接受一个函数或者对象作为参数</strong>。 </p>
<p> 例如，此代码不会重新渲染组件： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.state.count = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p> 而是应该使用 <code>setState()</code>: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="setState-的基本用法"><a href="#setState-的基本用法" class="headerlink" title="setState()的基本用法"></a>setState()的基本用法</h2><p><code>setState()</code> 更新状态的两种用法</p>
<h3 id="setState-stateChange-callback-——-接收的第一个参数为对象"><a href="#setState-stateChange-callback-——-接收的第一个参数为对象" class="headerlink" title="setState(stateChange[, callback]) —— 接收的第一个参数为对象"></a>setState(stateChange[, callback]) —— 接收的第一个参数为对象</h3><ul>
<li><strong>stateChange</strong> 为一个<strong>对象</strong>， 这个对象表示该组件的新状态。但你只需要传入需要更新的部分，而不需要传入整个对象 。 <code>stateChange</code> 会将传入的对象<strong>浅层合并</strong>到新的 state 中 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line"></span><br><span class="line">test1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setState()2之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>以上方这个组件 Counter 为例，点击按钮 <kbd>A 测试1</kbd>，调用函数 test1，控制台输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; setState()之后 0</span><br><span class="line">&gt; A render() 1</span><br></pre></td></tr></table></figure>

<p>我们可以看出，这种形式的setState()是异步的。</p>
<h3 id="setState-updater-callback-——-接收的第一个参数为函数"><a href="#setState-updater-callback-——-接收的第一个参数为函数" class="headerlink" title="setState(updater[, callback]) —— 接收的第一个参数为函数"></a>setState(updater[, callback]) —— 接收的第一个参数为函数</h3><ul>
<li><strong>updater</strong> 为返回值为 <strong>stateChange对象</strong>的<strong>函数</strong>：<code>(state, props) =&gt; stateChange</code>。React 会把上一个 <code>setState</code> 的结果传入这个函数作为第一个参数， 将此次更新被应用时的 <a href="https://zh-hans.reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">props</a> 做为第二个参数 。即：<strong>updater 函数中 接收的参数 state 和 props 的值永远被保证为最新的</strong>。并且，updater 的返回值会与 state 进行<strong>浅合并</strong>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line"></span><br><span class="line">test2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      count: state.count + <span class="number">1</span></span><br><span class="line">  &#125;))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>以组件 Counter 为例，点击按钮 <kbd>A 测试2</kbd>，调用函数 test2，控制台输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; setState()2之后 0</span><br><span class="line">&gt; A render() 1</span><br></pre></td></tr></table></figure>

<p>这种形式的setState()也是异步的。</p>
<h3 id="setState-param-callback-——-带回调函数的setState"><a href="#setState-param-callback-——-带回调函数的setState" class="headerlink" title="setState(param, callback) —— 带回调函数的setState()"></a>setState(param, callback) —— 带回调函数的setState()</h3><ul>
<li><strong>callback</strong> 是可选的回调函数,  它将在 <code>setState</code> 完成合并并重新渲染组件后执行 。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line"></span><br><span class="line">test3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(</span><br><span class="line">    state =&gt; (&#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;),</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'在callback中'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>以组件 Counter 为例，点击按钮 <kbd>A 测试3</kbd>，调用函数 test3，控制台输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; A render() 1</span><br><span class="line">&gt; 在callback中 1</span><br></pre></td></tr></table></figure>

<p>此时可以获取到 <code>setState()</code> 后最新的状态数据。</p>
<p><strong>注意：</strong></p>
<p>关于 setState() 的第二个参数为可选的回调函数，React官方文档中是这样描述的： <strong>通常，我们建议使用 <code>componentDidUpdate()</code> 来代替此方式</strong>。  </p>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><blockquote>
<blockquote>
<p><strong>如果后续状态不依赖于当前状态 ===&gt; 使用对象方式</strong></p>
</blockquote>
<blockquote>
<p><strong>如果后续状态依赖于当前状态 ===&gt; 使用函数方式</strong></p>
</blockquote>
</blockquote>
<hr>
<h2 id="setState-真的是异步的吗？"><a href="#setState-真的是异步的吗？" class="headerlink" title="setState()真的是异步的吗？"></a>setState()真的是异步的吗？</h2><p>在上面的代码中，我们可以看到，在此时的场景中，对象参数形式 和 函数参数形式 的 <code>setState()</code>都是异步的。那么， <code>setState()</code> 真的是异步的吗？</p>
<h3 id="先给出结论："><a href="#先给出结论：" class="headerlink" title="先给出结论："></a>先给出结论：</h3><ul>
<li><strong>由 React 控制的事件处理过程中的 <code>setState</code> 都是异步的，如：生命周期函数、合成事件</strong>  </li>
<li><strong>由非 React 控制的事件处理过程中的 <code>setState</code> 都是同步的，如：定时器回调中、原生事件监听回调中、promise成功/失败的回调中 ……</strong></li>
</ul>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>接下来我们用几个例子验证一下：</p>
<h4 id="生命周期函数中的-setState"><a href="#生命周期函数中的-setState" class="headerlink" title="生命周期函数中的 setState()"></a>生命周期函数中的 <code>setState()</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之前'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>输出顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; render() 0</span><br><span class="line">&gt; setState()之前 0</span><br><span class="line">&gt; setState()之后 0</span><br><span class="line">&gt; render() 1</span><br></pre></td></tr></table></figure>

<p>结果显而易见，<code>setState()</code> 此时是异步执行的。</p>
<h4 id="合成事件中的-setState"><a href="#合成事件中的-setState" class="headerlink" title="合成事件中的 setState()"></a>合成事件中的 <code>setState()</code></h4><p> 首先得了解一下什么是合成事件，react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在 <code>jsx</code> 中常见的 <code>onClick</code> 、<code>onChange</code> 这些都是合成事件。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">	increment = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之前'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.increment&#125;&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>点击调用，输出顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; render() 0</span><br><span class="line">&gt; setState()之前 0</span><br><span class="line">&gt; setState()之后 0</span><br><span class="line">&gt; render() 1</span><br></pre></td></tr></table></figure>

<p><code>setState()</code> 此时也是异步执行的。</p>
<h4 id="定时器中的-setState"><a href="#定时器中的-setState" class="headerlink" title="定时器中的 setState()"></a>定时器中的 <code>setState()</code></h4><p>首先得了解一下什么是合成事件，react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在 <code>jsx</code> 中常见的 <code>onClick</code> 、<code>onChange</code> 这些都是合成事件。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">	componentDidMount() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setState()之前'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>输出顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; render() 0</span><br><span class="line">&gt; setState()之前 0</span><br><span class="line">&gt; render() 1</span><br><span class="line">&gt; setState()之后 1</span><br></pre></td></tr></table></figure>

<p>此时，<code>setState()</code> 此时是同步执行的。</p>
<p>在定时器中去 <code>setState()</code> 并不算是一个单独的场景，它是随着你外层去决定的。你可以在合成事件中使用定时器，可以在钩子函数中使用定时器 ，也可以在原生事件使用定时器，但是不管是哪个场景下，基于事件轮询机制（event loop）下， 定时器中的 <code>setState()</code> 永远是同步执行的。</p>
<h4 id="原生事件监听回调中的-setState"><a href="#原生事件监听回调中的-setState" class="headerlink" title="原生事件监听回调中的 setState()"></a>原生事件监听回调中的 <code>setState()</code></h4><p> 原生事件是指非 react 合成事件，原生自带的事件监听 <code>addEventListener</code> ，或者也可以用原生js、jq直接 <code>document.querySelector().onclick</code> 这种绑定事件的形式都属于原生事件。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  changeValue = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之前'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.changeValue)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>点击调用，输出顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; render() 0</span><br><span class="line">&gt; setState()之前 0</span><br><span class="line">&gt; render() 1</span><br><span class="line">&gt; setState()之后 1</span><br></pre></td></tr></table></figure>

<p>此时的<code>setState()</code> 此时也是同步执行的。</p>
<h4 id="promise回调中的-setState"><a href="#promise回调中的-setState" class="headerlink" title="promise回调中的 setState()"></a>promise回调中的 <code>setState()</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setState()之前'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setState()之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render()'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="string">`Counter is: <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span>`</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>输出顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; render() 0</span><br><span class="line">&gt; setState()之前 0</span><br><span class="line">&gt; render() 1</span><br><span class="line">&gt; setState()之后 1</span><br></pre></td></tr></table></figure>

<p>此时的<code>setState()</code> 此时也是同步执行的。</p>
<p>这里， promise 回调中的 <code>setState()</code>，和之前所说的一样，不管是哪个场景下，promise 回调中的 <code>setState()</code> 永远是同步执行的。</p>
<h3 id="同步-异步-是由什么决定的呢？"><a href="#同步-异步-是由什么决定的呢？" class="headerlink" title="同步/异步 是由什么决定的呢？"></a>同步/异步 是由什么决定的呢？</h3><p>深入源码你会发现：<sup>引自参考文章 6</sup></p>
<blockquote>
<p>在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是<strong>由 React 控制的事件处理过程 setState 不会同步更新 this.state</strong>。  </p>
</blockquote>
<hr>
<h2 id="关于异步的setState-的批量处理"><a href="#关于异步的setState-的批量处理" class="headerlink" title="关于异步的setState()的批量处理"></a>关于异步的setState()的批量处理</h2><h3 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line"></span><br><span class="line">test4 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setState()4之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>以组件 Counter 为例，点击按钮 <kbd>A 测试4</kbd>，调用函数 test4，控制台输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; setState()4之后 0</span><br><span class="line">&gt; A render() 1</span><br></pre></td></tr></table></figure>

<p> 同一周期内会对多个 <code>setState</code> 进行批量处理。例如，如果在同一周期内多次设置 count 增加，则相当于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(</span><br><span class="line">	previousState,</span><br><span class="line">    &#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;,</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p> 后调用的 <code>setState()</code> 将覆盖同一周期内先调用 <code>setState</code> 的值，因此 count 得值仅增加一次， 如果后续状态取决于当前状态，建议使用 updater 函数的形式代替： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test5 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;))</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setState()5之后'</span>, <span class="keyword">this</span>.state.count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由于接收的参数 state 和 props 的值永远被保证为最新的</strong>，所以输出以下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; setState()5之后 0</span><br><span class="line">&gt; A render() 2</span><br></pre></td></tr></table></figure>



<h3 id="多次调用-如何处理"><a href="#多次调用-如何处理" class="headerlink" title="多次调用, 如何处理?"></a>多次调用, 如何处理?</h3><ul>
<li>setState({}): 合并更新一次状态, 只调用一次 <code>render()</code> 更新界面 ===&gt; <strong>状态更新和界面更新都合并了</strong>。</li>
<li>setState(fn): 更新多次状态, 但只调用一次 <code>render()</code> 更新界面 ===&gt; <strong>状态更新没有合并, 但界面更新合并了</strong>。</li>
</ul>
<h3 id="结论：-1"><a href="#结论：-1" class="headerlink" title="结论："></a>结论：</h3><p><strong>由于 React 会对同一周期内的 <code>setState()</code> 进行合并，所以， 在使用 React 的时候，并不需要担心多次进行 <code>setState</code> 会带来性能问题</strong>  </p>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>掌握 <code>setState()</code> 的基本用法，分清 <code>setState()</code> 在不同应用场景下的执行流程，注意  <code>setState()</code> 的合并处理。开发中基本不会再跳这个方法的坑了。</p>
<p> 如果哪里有说的不对的地方，欢迎指正。</p>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#setstate" target="_blank" rel="noopener">React官方文档 —— setState()</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="noopener">阮一峰的网络日志 —— React 入门实例教程</a></li>
<li><a href="http://huziketang.mangojuice.top/books/react/lesson10" target="_blank" rel="noopener">React.js 小书 —— 组件的 state 和 setState</a></li>
<li><a href="https://www.runoob.com/react/react-state.html" target="_blank" rel="noopener">菜鸟教程 —— React State(状态)</a></li>
<li><a href="https://juejin.im/post/5b45c57c51882519790c7441#heading-0" target="_blank" rel="noopener">你真的理解setState吗？</a></li>
<li><a href="https://www.zhihu.com/question/66749082/answer/246217812" target="_blank" rel="noopener">问一个react更新State的问题？ - Lucas HC的回答 - 知乎 </a></li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>Component和PureComponent</title>
    <url>/2020/02/14/Component%E5%92%8CPureComponent/</url>
    <content><![CDATA[<blockquote>
<p><code>React.PureComponent</code> 与 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent" target="_blank" rel="noopener"><code>React.Component</code></a> 很相似。两者的区别在于 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent" target="_blank" rel="noopener"><code>React.Component</code></a> 并未实现 <a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate" target="_blank" rel="noopener"><code>shouldComponentUpdate()</code></a>，而 <code>React.PureComponent</code> 中以浅层对比 prop 和 state 的方式来实现了该函数。</p>
</blockquote>
<a id="more"></a>

<h2 id="使用Component存在的问题"><a href="#使用Component存在的问题" class="headerlink" title="使用Component存在的问题"></a>使用Component存在的问题</h2><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>我们先来看看下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">class A extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m1: &#123;</span><br><span class="line">      count: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  testA &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;A render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;A组件: m1.count&#x3D;&#123;this.state.m1.count&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.testA&#125;&gt;test A&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;B m1&#x3D;&#123;this.state.m1&#125;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">class B extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m2: &#123;</span><br><span class="line">      count: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;B render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;B组件: &lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;div&gt;m2.count&#x3D;&#123;this.state.m2.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div&gt;m1.count&#x3D;&#123;this.props.m1.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;A&#x2F;&gt;, document.getElementById(&#39;example&#39;))</span><br></pre></td></tr></table></figure>

<p>上面的代码中，组件A是组件B的父组件。同时，组件A将维护的状态 <code>m1</code> 作为B组件的属性传递给他。</p>
<p>点击 <kbd>test A</kbd>，输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; A render()</span><br><span class="line">&gt; B render()</span><br></pre></td></tr></table></figure>

<p>我们会发现，此时，即使 A组件 的 <code>state</code> 没有发生变化，A组件也会重新渲染。即使 B组件 的 <code>state</code> 和 <code>props</code> 都没有发生改变，但只要 A组件 重新渲染，B组件 也会重新渲染。</p>
<p>也就是说，当前使用的继承类 <code>Component</code> 存在这两个问题：</p>
<ul>
<li><strong>当前组件 <code>setState()</code>，会重新执行 <code>render()</code>，即使 state 没有任何变化。</strong></li>
<li><strong>父组件重新 <code>render()</code>, 当前组件也会重新执行 <code>render()</code>, 即使 state 和 <code>porps</code> 没有任何变化。</strong></li>
</ul>
<p>这样，就导致了本不必要的性能浪费。  </p>
<h3 id="为什么会存在这些问题？"><a href="#为什么会存在这些问题？" class="headerlink" title="为什么会存在这些问题？"></a>为什么会存在这些问题？</h3><p>首先我们来看一下 React 的生命周期：</p>
<p><a href="https://i.loli.net/2020/04/05/9KNUBvCmtXxwQA4.jpg" target="_blank"><img src="https://i.loli.net/2020/04/05/9KNUBvCmtXxwQA4.jpg" style="zoom:60%;"  ></a></p>
<center>图源来自网络</center>

<p>从这张图中可以很轻松的看到，组件运行时，无论是父组件重新 <code>render()</code>，还是子组件的 state 发生改变，都会调用 <strong><code>shouldComponentUpdate()</code></strong> 这个方法。 它<strong>接收两个参数：nextProps和nextState</strong>，分别表示新的 props 和新的 state 的值。并且，当函数返回 ture 时，组件会重新调用 <code>render()</code> 进行 update ；当函数返回 false 时，组件不会重新渲染。</p>
<p>然而，<strong>Component 类的 <code>shouldComponentUpdate()</code> 默认返回 true, 即使数据没有变化 <code>render()</code> 也会重新执行</strong>，这就导致了我们上方的问题。</p>
<hr>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="重写shouldComponentUpdate"><a href="#重写shouldComponentUpdate" class="headerlink" title="重写shouldComponentUpdate()"></a>重写shouldComponentUpdate()</h3><p>上面我们说，<code>shouldComponentUpdate()</code> 默认返回 true，所以导致了不必要的重新渲染。于是我们可以在<code>shouldComponentUpdate()</code>中加入条件判断，从而优化性能。</p>
<p>在上面的例子中，我们在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">class A extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m1: &#123;</span><br><span class="line">      count: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  testA &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  shouldComponentUpdate(nextProps, nextState)&#123;</span><br><span class="line">    return nextState.m1 &#x3D;&#x3D;&#x3D; this.state.m1 ? false : true</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;A render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;A组件: m1.count&#x3D;&#123;this.state.m1.count&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.testA&#125;&gt;test A&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;B m1&#x3D;&#123;this.state.m1&#125;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">class B extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m2: &#123;</span><br><span class="line">      count: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState)&#123;</span><br><span class="line">    return nextProps.m1 &#x3D;&#x3D;&#x3D; this.props.m1 &amp;&amp; nextState.m2 &#x3D;&#x3D;&#x3D; this.state.m2 ? false : true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;B render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;B组件: &lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;div&gt;m2.count&#x3D;&#123;this.state.m2.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div&gt;m1.count&#x3D;&#123;this.props.m1.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;A&#x2F;&gt;, document.getElementById(&#39;example&#39;))</span><br></pre></td></tr></table></figure>

<p>可是这样，又有了一个新的问题。当组件的 state 或 props 很多时，这样无疑会非常麻烦。</p>
<p>所以，我们可以使用 PureComponent 很轻松的解决。</p>
<h3 id="使用PureComponent"><a href="#使用PureComponent" class="headerlink" title="使用PureComponent"></a>使用PureComponent</h3><p> React中提供了一个 <code>PureComponent</code> 的类，当我们的组件继承于它时，组件更新时就会默认先比较新旧属性和状态，从而决定组件是否更新。</p>
<p> 不过值得注意的是，<strong><code>PureComponent</code>进行的是浅比较，所以组件状态或属性改变时，都需要返回一个新的对象或数组</strong>。</p>
<p>就像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">class A extends React.PureComponent &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m1: &#123;</span><br><span class="line">      count: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  testA &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(state &#x3D;&gt; (&#123;</span><br><span class="line">      m1: &#123;...state.m1, count: 2&#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  shouldComponentUpdate(nextProps, nextState)&#123;</span><br><span class="line">    return nextState.m1 &#x3D;&#x3D;&#x3D; this.state.m1 ? false : true</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;A render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;A组件: m1.count&#x3D;&#123;this.state.m1.count&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.testA&#125;&gt;test A&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;B m1&#x3D;&#123;this.state.m1&#125;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">class B extends React.PureComponent &#123;</span><br><span class="line"></span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    m2: &#123;</span><br><span class="line">      count: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState)&#123;</span><br><span class="line">    return nextProps.m1 &#x3D;&#x3D;&#x3D; this.props.m1 &amp;&amp; nextState.m2 &#x3D;&#x3D;&#x3D; this.state.m2 ? false : true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;B render()&#39;)</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;B组件: &lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;div&gt;m2.count&#x3D;&#123;this.state.m2.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div&gt;m1.count&#x3D;&#123;this.props.m1.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;A&#x2F;&gt;, document.getElementById(&#39;example&#39;))</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent" target="_blank" rel="noopener">React官方文档 —— React.PureComponent</a></li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>同步回调与异步回调</title>
    <url>/2020/02/06/%E5%90%8C%E6%AD%A5%E5%9B%9E%E8%B0%83%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>对js回调函数进行归纳总结</p>
</blockquote>
<blockquote>
<p>涉及的名词：单线程、回调函数  </p>
</blockquote>
<a id="more"></a>

<hr>
<h2 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h2><h3 id="js是单线程的"><a href="#js是单线程的" class="headerlink" title="js是单线程的"></a>js是单线程的</h3><h4 id="什么是单线程？"><a href="#什么是单线程？" class="headerlink" title="什么是单线程？"></a>什么是单线程？</h4><p>所谓“单线程”，就是同一时间只能处理一个任务，如果有多个任务，就必须依次执行。只有当前一个任务执行完了，后一个任务才会执行。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">'1'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>执行上面的代码，执行顺序：</p>
<ol>
<li>页面弹窗显示<strong>1</strong>，此时控制台没有内容。</li>
<li>点击弹窗确定，控制台输出<strong>2。</strong>  </li>
</ol>
<p>即<code>console.log(&#39;2&#39;)</code>这条语句会在<code>alert(&#39;1&#39;)</code>执行结束后才开始执行</p>
<h4 id="为什么JavaScript是单线程？"><a href="#为什么JavaScript是单线程？" class="headerlink" title="为什么JavaScript是单线程？"></a>为什么JavaScript是单线程？</h4><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
<p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程。  </p>
<hr>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><h4 id="回调函数是什么？"><a href="#回调函数是什么？" class="headerlink" title="回调函数是什么？"></a>回调函数是什么？</h4><p>MDN对回调函数的定义： 被作为实参传入另一函数，并在该外部函数内被调用，用以来完成某些任务的函数，称为<strong>回调函数</strong> 。</p>
<p>想要弄清楚回调函数，首先要清楚js中的函数，JavaScript中的函数本质是一个对象，准确来说是通过<code>new Function()</code>创建的Function的实例对象。因此我们可以将函数像对象一样存保存在变量中，当然也就可以将保存在变量中的函数通过参数传递给另一个函数，这个作为参数传递的函数，就是<strong>回调函数</strong>。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">setTimeOut(fn(<span class="number">1</span>), <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>



<h4 id="为什么使用回调函数？"><a href="#为什么使用回调函数？" class="headerlink" title="为什么使用回调函数？"></a>为什么使用回调函数？</h4><p>js的单线程特性，使得所有任务需依次执行，如果前一个任务的执行需要很长时间，那么整个程序的执行时间就都会被拉长。</p>
<p> 为了解决这个问题，Javascript语言将任务的执行模式分成两种：<u>同步（Synchronous）</u>和<u>异步（Asynchronous）</u> 。</p>
<p><strong>同步任务</strong>指的是需要在主线程上排队依次执行的任务，前一个任务结束，才会执行后一个任务。 任务执行的顺序与代码排列的顺序是一致的、同步的，同步任务会导致阻塞；<strong>异步任务</strong>指的是不会阻塞主线程上的下一个同步任务，而是会进入的回调队列（callback queue）的任务。</p>
<p>而回调函数，正是实现异步编程的方法之一。  </p>
<hr>
<h2 id="同步回调与异步回调"><a href="#同步回调与异步回调" class="headerlink" title="同步回调与异步回调"></a>同步回调与异步回调</h2><p>回调函数不等于异步， 同步(阻塞)的场景下也经常用到回调</p>
<h3 id="同步回调"><a href="#同步回调" class="headerlink" title="同步回调"></a>同步回调</h3><p>立即执行，完全执行完了才会执行下一个任务，不会放入回调队列中</p>
<p>如：数组遍历相关的回调函数 / Promise的excutor函数</p>
<p><strong>例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'遍历的回调'</span>, item, index)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'forEach()之后'</span>)</span><br></pre></td></tr></table></figure>

<p>数组的forEach()方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历的回调, 1, 0</span></span><br><span class="line"><span class="comment">// 遍历的回调, 2, 1</span></span><br><span class="line"><span class="comment">// 遍历的回调, 3, 2</span></span><br><span class="line"><span class="comment">// forEach()之后</span></span><br></pre></td></tr></table></figure>

<p>执行结果  </p>
<h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><p>不会立即执行, 会放入回调队列中将来执行</p>
<p>如：定时器回调 / ajax回调 / 事件监听回调/ Promise的成功和失败的回调</p>
<p><strong>例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'回调函数'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'setTimeout()之后'</span>)</span><br></pre></td></tr></table></figure>

<p>定时器回调</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setTimeout()之后</span></span><br><span class="line"><span class="comment">// 回调函数</span></span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></li>
<li><a href="[http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html](http://www.ruanyifeng.com/blog/2012/12/asynchronous＿javascript.html)">Javascript异步编程的4种方法</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>回调函数</tag>
      </tags>
  </entry>
</search>
